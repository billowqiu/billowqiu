---
title: 简易模版栈及数制转换
id: 130
categories:
  - 数据结构/算法
date: 2009-11-01 22:17:00
tags:
---

    

&nbsp;<pre style="border: 1px dotted #785;background: #f5f5f5;">#pragma once

const int  INIT_SIZE = 100;
const int  INCRENT_SIZE = 10;

template &lt;typename T&gt;
class CStack
{
private:
T* m_pBase;/*基址*/
int m_nSize;
int m_nTop;
public:

CStack()
{
m_pBase = new T[INIT_SIZE];
m_nSize = INIT_SIZE;
m_nTop = 0;
}

~CStack(void)
{
delete [] m_pBase;
}
bool IsEmpty()const
{
return m_nTop == 0;
}
void Push(const T&amp; val)
{
//空间已满
if (m_nTop == m_nSize)
{
//增加
T* newBase = new T[m_nSize+INCRENT_SIZE];
//复制原来的数据
::memcpy(newBase,m_pBase,m_nSize*sizeof(T));
//删除原来的空间
delete []m_pBase;
//新的空间地址
m_pBase = newBase;
m_nSize += INCRENT_SIZE;
}
m_pBase[m_nTop++] = val;
}
int Pop(T&amp; val)
{
if (m_nTop)
{
val = m_pBase[--m_nTop];
return 0;
}
return -1;
}
};
</pre> 

下面是个小的测试程序

<pre style="border: 1px dotted #785;background: #f5f5f5;">// StackTest.cpp : 定义控制台应用程序的入口点。
//

#include "stdafx.h"
#include &lt;iostream&gt;

#include "Stack.h"
void DecToOthers(int decVal,const int x)
{
CStack&lt;int&gt; stack;
while (decVal)
{
stack.Push(decVal%x);
decVal = decVal / x;
}
while(!stack.IsEmpty())
{
int n;
stack.Pop(n);
std::cout&lt;&lt;n;
}
std::cout&lt;&lt;std::endl;
}

int _tmain(int argc, _TCHAR* argv[])
{
DecToOthers(1348,8);

DecToOthers(128,2);

CStack&lt;int&gt; stack;
for (int i=0;i&lt;200;i++)
{
stack.Push(i);
}
while(!stack.IsEmpty())
{
int n;
stack.Pop(n);
std::cout&lt;&lt;n&lt;&lt;"  ";
}

return 0;
}</pre> 

</div>