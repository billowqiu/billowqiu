---
title: 派生类的拷贝构造函数
id: 203
categories:
  - C++
date: 2006-12-25 18:20:00
tags:
---

    <DIV class=cnt id=blog_text>

刚刚弄了一个关于派生类的实验，里面涉及到了派生类的拷贝构造函数，这时才发现自己在这个知识点上还很模糊。在CSDN上面看了下相关的一篇文章后，稍微有了点感觉。现总以一个例子总结如下：

情况(1). 派生类的copy&nbsp;&nbsp; constructor未定义

#include&nbsp;&nbsp; &lt;iostream&gt;&nbsp;&nbsp; 
using&nbsp;&nbsp; namespace&nbsp;&nbsp; std&nbsp;&nbsp; ;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; 
class&nbsp;&nbsp; base&nbsp;&nbsp; 
{&nbsp;&nbsp; 
public:&nbsp;&nbsp; 
base()&nbsp;&nbsp; {&nbsp;&nbsp; cout&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; "base::base()"&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; endl&nbsp;&nbsp; ;&nbsp;&nbsp; }&nbsp;&nbsp; 
base(&nbsp;&nbsp; const&nbsp;&nbsp; base&amp;&nbsp;&nbsp; )&nbsp;&nbsp; {&nbsp;&nbsp; cout&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; "base::base(&nbsp;&nbsp; const&nbsp;&nbsp; base&amp;)"&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; endl&nbsp;&nbsp; ;&nbsp;&nbsp; }&nbsp;&nbsp; 
virtual&nbsp;&nbsp; ~base()&nbsp;&nbsp; {&nbsp;&nbsp; cout&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; "base::~base()"&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; endl&nbsp;&nbsp; ;&nbsp;&nbsp; }&nbsp;&nbsp; 
};&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; 
class&nbsp;&nbsp; child&nbsp;&nbsp; :&nbsp;&nbsp; public&nbsp;&nbsp; base&nbsp;&nbsp; 
{&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; 
public:&nbsp;&nbsp; 
child()&nbsp;&nbsp; {&nbsp;&nbsp; cout&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; "child::child()"&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; endl&nbsp;&nbsp; ;&nbsp;&nbsp; }&nbsp;&nbsp; 
/*------------------------------------------------------------------&nbsp;&nbsp; 
child(&nbsp;&nbsp; const&nbsp;&nbsp; child&amp;&nbsp;&nbsp; )&nbsp;&nbsp; {&nbsp;&nbsp; cout&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; "child::child(&nbsp;&nbsp; const&nbsp;&nbsp; child&amp;&nbsp;&nbsp; )" &lt;&lt;&nbsp;&nbsp; endl&nbsp;&nbsp; ;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
-------------------------------------------------------------------*/&nbsp;&nbsp; 
~child()&nbsp;&nbsp; {&nbsp;&nbsp; cout&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; "child::~child()"&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; endl&nbsp;&nbsp; ;&nbsp;&nbsp; }&nbsp;&nbsp; 
int&nbsp;&nbsp; test(int&nbsp;&nbsp; i)&nbsp;&nbsp; {&nbsp;&nbsp; cout&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; "int&nbsp;&nbsp; child::test(int)"&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; endl&nbsp;&nbsp; ;&nbsp;&nbsp;

return&nbsp;&nbsp; 0&nbsp;&nbsp; ;&nbsp;&nbsp; }&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; 
};&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; 
int main()&nbsp;&nbsp; 
{&nbsp;&nbsp; 
child&nbsp;&nbsp; c1&nbsp;&nbsp; ;&nbsp;&nbsp; 
cout&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; "----------------------------"&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; endl&nbsp;&nbsp; ;&nbsp;&nbsp; 
child&nbsp;&nbsp; c2(c1)&nbsp;&nbsp; ;&nbsp;&nbsp; 
cout&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; "----------------------------"&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; endl&nbsp;&nbsp; ;&nbsp;&nbsp; 
}&nbsp;&nbsp; 
输出结果:&nbsp;&nbsp; 
base::base()&nbsp;&nbsp; 
child::child()&nbsp;&nbsp; 
----------------------------&nbsp;&nbsp; 
base::base(&nbsp;&nbsp; const&nbsp;&nbsp; base&amp;) 
----------------------------&nbsp;&nbsp; 
child::~child()&nbsp;&nbsp; 
base::~base()&nbsp;&nbsp; 
child::~child()&nbsp;&nbsp; 
base::~base()&nbsp;&nbsp;

注意 child&nbsp;&nbsp; c2(c1)&nbsp;&nbsp; ;&nbsp;&nbsp; 调用了基类的拷贝构造函数，这是为什么呢？因为派生类没有显式定义自己的拷贝构造函数，而基类定义了。首先child公有继承base，且base::copy&nbsp;&nbsp; ctor也是public的，那么对child类而言，基类copy&nbsp;&nbsp; ctor是可见的。 child&nbsp;&nbsp; c2(c1)&nbsp;&nbsp; ;&nbsp;&nbsp; 这句，编译器先找child自己的copy&nbsp;&nbsp; ctor，没有。这时就去找基类的copy&nbsp;&nbsp; ctor。由于它的参数是这样定义的：const&nbsp;&nbsp; base&amp;&nbsp;&nbsp; ，即用到了基类对象的引用，所以这里有多态的能力，比如child&nbsp;&nbsp; c2(c1)&nbsp;&nbsp; ;

看下面这个例子

#include&nbsp;&nbsp; &lt;iostream&gt;&nbsp;&nbsp; 
using&nbsp;&nbsp; namespace&nbsp;&nbsp; std&nbsp;&nbsp; ;&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; 
class&nbsp;&nbsp; base&nbsp;&nbsp; 
{&nbsp;&nbsp; 
public:&nbsp;&nbsp; 
base(){cout&lt;&lt;"base::base()"&lt;&lt; endl;}&nbsp;&nbsp; 
base(const base&amp; rhs)&nbsp;&nbsp; 
{&nbsp;&nbsp; 
cout&lt;&lt;"base::base(const base&amp;)"&lt;&lt;endl;&nbsp;&nbsp;&nbsp;&nbsp; 
rhs.show();&nbsp;&nbsp;&nbsp;&nbsp; 
}&nbsp;&nbsp; 
virtual&nbsp;&nbsp; void show() const {cout&lt;&lt;"base::show()"&lt;&lt;endl;}&nbsp;&nbsp; 
virtual&nbsp;&nbsp; ~base()&nbsp;&nbsp; {cout&lt;&lt;"base::~base()"&lt;&lt;endl;}&nbsp;&nbsp; 
};&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; 
class&nbsp;&nbsp; child:public base&nbsp;&nbsp; 
{&nbsp;&nbsp; 
public:&nbsp;&nbsp; 
child()&nbsp;&nbsp; {cout&lt;&lt;"child::child()"&lt;&lt;endl;}&nbsp;&nbsp; 
/*------------------------------------------------------------------&nbsp;&nbsp; 
child(&nbsp;&nbsp; const&nbsp;&nbsp; child&amp;&nbsp;&nbsp; )&nbsp;&nbsp; {&nbsp;&nbsp; cout&nbsp;&nbsp; &lt;&lt;&nbsp;&nbsp; "child::child(&nbsp;&nbsp; const&nbsp;&nbsp; child&amp;&nbsp;&nbsp; )" &lt;&lt;&nbsp;&nbsp; endl&nbsp;&nbsp; ;&nbsp;&nbsp; }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
-------------------------------------------------------------------*/&nbsp;&nbsp; 
~child(){cout&lt;&lt;"child::~child()"&lt;&lt;endl;}&nbsp;&nbsp; 
virtual void show()const {cout&lt;&lt;"child::show()"&lt;&lt;endl;}&nbsp;&nbsp; 
int test(int i) {cout&lt;&lt;"int child::test(int)"&lt;&lt;endl;return 0;}&nbsp;&nbsp; 
};&nbsp;&nbsp; 
&nbsp;&nbsp;&nbsp; 
int&nbsp;&nbsp; main()&nbsp;&nbsp; 
{&nbsp;&nbsp; 
&nbsp;&nbsp; child&nbsp;&nbsp; c1&nbsp;&nbsp; ;&nbsp;&nbsp; 
&nbsp;&nbsp; cout&lt;&lt;"----------------------------"&lt;&lt;endl;&nbsp;&nbsp; 
&nbsp;&nbsp; child&nbsp;&nbsp; c2(c1);&nbsp;&nbsp; 
&nbsp;&nbsp; cout&lt;&lt;"----------------------------"&lt;&lt;endl;&nbsp;&nbsp; 
}&nbsp;&nbsp;

输出为：

base::base()&nbsp;&nbsp; 
child::child()&nbsp;&nbsp; 
----------------------------&nbsp;&nbsp; 
base::base(&nbsp;&nbsp; const&nbsp;&nbsp; base&amp;)&nbsp;&nbsp;

child::show()
----------------------------&nbsp;&nbsp; 
child::~child()&nbsp;&nbsp; 
base::~base()&nbsp;&nbsp; 
child::~child()&nbsp;&nbsp; 
base::~base()&nbsp;&nbsp;

2基类也没有显式定义自己的拷贝构造函数

#include &lt;iostream&gt; 
using namespace std ; 

class base 
{ 
public: 
base() { cout &lt;&lt; "base::base()" &lt;&lt; endl ; } 
/*base( const base&amp; ) { cout &lt;&lt; "base::base( const base&amp;)" &lt;&lt; endl ; } */
virtual ~base() { cout &lt;&lt; "base::~base()" &lt;&lt; endl ; } 
}; 

class child : public base 
{ 

public: 
child() { cout &lt;&lt; "child::child()" &lt;&lt; endl ; } 
/*------------------------------------------------------------------ 
child( const child&amp; ) { cout &lt;&lt; "child::child( const child&amp; )" &lt;&lt; endl ; }&nbsp;&nbsp;&nbsp;
-------------------------------------------------------------------*/ 
~child() { cout &lt;&lt; "child::~child()" &lt;&lt; endl ; } 
int test(int i) { cout &lt;&lt; "int child::test(int)" &lt;&lt; endl ; return 0 ; } 

};&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; int main() 
{ 
child c1 ; 
cout &lt;&lt; "----------------------------" &lt;&lt; endl ; 
child c2(c1) ; 
cout &lt;&lt; "----------------------------" &lt;&lt; endl ; 
}&nbsp;&nbsp;

输出结果: 
base::base() 
child::child() 
----------------------------&nbsp;&nbsp;&nbsp;
---------------------------- 
child::~child() 
base::~base() 
child::~child() 
base::~base()&nbsp;&nbsp;

这时child c2(c1) ; 调用的是自己的默认拷贝构造函数，同时也会调用基类的默认构造函数（为什么是构造函数不是拷贝构造函数，下面的一种情况就会看到），既然默认的构造函数什么所以不会有什么输出信息。

3基类和派生类都显式定义了自己都拷贝构造函数

#include &lt;iostream&gt; 
using namespace std ; 

class base 
{ 
public: 
base() { cout &lt;&lt; "base::base()" &lt;&lt; endl ; }&nbsp;&nbsp;&nbsp;
base( const base&amp; ) { cout &lt;&lt; "base::base( const base&amp;)" &lt;&lt; endl ; }&nbsp;&nbsp;&nbsp;
virtual ~base() { cout &lt;&lt; "base::~base()" &lt;&lt; endl ; } 
}; 

class child : public base 
{ 

public: 
child() { cout &lt;&lt; "child::child()" &lt;&lt; endl ; }&nbsp;&nbsp;&nbsp;
child( const child&amp; ) { cout &lt;&lt; "child::child( const child&amp; )" &lt;&lt; endl ; }&nbsp;&nbsp;&nbsp;
~child() { cout &lt;&lt; "child::~child()" &lt;&lt; endl ; } 
int test(int i) { cout &lt;&lt; "int child::test(int)" &lt;&lt; endl ; return 0 ; } 

};&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp; int main() 
{ 
child c1 ; 
cout &lt;&lt; "----------------------------" &lt;&lt; endl ; 
child c2(c1) ; 
cout &lt;&lt; "----------------------------" &lt;&lt; endl ; 
}&nbsp;&nbsp;

输出为：

base::base() 
child::child() 
---------------------------- 
base::base() 
child::child( const child&amp; ) 
---------------------------- 
child::~child() 
base::~base() 
child::~child() 
base::~base()&nbsp;&nbsp;

注意这里child c2(c1) ;&nbsp;&nbsp; 调用了基类的构造函数而不是拷贝构造函数，这又是为什么呢？
请问拷贝构造函数是不是构造函数？？&nbsp;&nbsp;&nbsp; 是，是个特殊的构造函数，但是他也是构造函数。C2调用自己的拷贝构造函数的时候，编译器只是认为你调用了构造函数，根据参数类型是调用我们所说的拷贝构造函数，但是当他决定调用基类的哪个构造函数的时候，他要看你传递给基类的参数了，你什么都没有给传递，当然调用默认构造函数了。

我想通过上面三种情况的讲解大家应该都能明白派生类拷贝构造函数的奥妙了，通过这个例子也对我学习C++的过程敲了下警钟：知识面还是不广，综合运用所学东西的能力还不够，尤其是那个多态的地方，如果是单独的多态可能一下子就看出来了，但是用在这里就傻眼了。
</DIV>
</div>