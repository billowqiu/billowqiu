---
title: STL介绍
id: 198
categories:
  - C++
date: 2008-04-13 15:36:00
tags:
---

    

翻译的一篇SGI STL文档还要好多不太会翻译，以后在慢慢领悟吧！

# <SPAN><FONT face=宋体>Introduction to the Standard Template Library</FONT></SPAN>

# <FONT face=宋体>标准模板库简介</FONT>

<SPAN><FONT face=宋体 size=3>The Standard Template Library, or _STL_, is a C++ library of container classes, algorithms, and iterators; it provides many of the basic algorithms and data structures of computer science. The STL is a _generic_ library, meaning that its components are heavily parameterized: almost every component in the STL is a template. You should make sure that you understand how templates work in C++ before you use the STL.</FONT></SPAN>

<FONT face=宋体 size=3>标准模板库，或<SPAN>STL</SPAN>，是一个包括容器类，算法和迭代器的<SPAN>C++</SPAN>库；它提供了许多计算机的基本算法和数据结构。<SPAN>STL</SPAN>是一个泛型库，这意味这它是由很深的参数机制实现的：几乎每一个<SPAN>STL</SPAN>的组件都是模板。你在使用<SPAN>STL</SPAN>之前应该确信你已经懂得了<SPAN>C++</SPAN>的模板。</FONT>

## <SPAN><FONT face=宋体>Containers and algorithms</FONT></SPAN>

## <FONT face=宋体>容器和算法</FONT>

<SPAN><FONT face=宋体 size=3>Like many class libraries, the STL includes _container_ classes: classes whose purpose is to contain other objects. The STL includes the classes <TT>[<FONT color=#0000ee><U>vector</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/Vector.html)</TT>, <TT>[<FONT color=#0000ee><U>list</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/List.html)</TT>, <TT>[<FONT color=#0000ee><U>deque</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/Deque.html)</TT>, <TT>[<FONT color=#0000ee><U>set</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/set.html)</TT>, <TT>[<FONT color=#0000ee><U>multiset</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/multiset.html)</TT>, <TT>[<FONT color=#0000ee><U>map</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/Map.html)</TT>, <TT>[<FONT color=#0000ee><U>multimap</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/Multimap.html)</TT>, <TT>[<FONT color=#0000ee><U>hash_set</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/hash_set.html)</TT>, <TT>[<FONT color=#0000ee><U>hash_multiset</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/hash_multiset.html)</TT>, <TT>[<FONT color=#0000ee><U>hash_map</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/hash_map.html)</TT>, and <TT>[<FONT color=#0000ee><U>hash_multimap</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/hash_multimap.html)</TT>. Each of these classes is a template, and can be instantiated to contain any type of object. You can, for example, use a <TT>vector&lt;int&gt;</TT> in much the same way as you would use an ordinary C array, except that <TT>vector</TT> eliminates the chore of managing dynamic memory allocation by hand.</FONT></SPAN>

<FONT face=宋体 size=3>像许多类库，<SPAN>STL</SPAN>包括容器类：用于包含其他类对象的类。<SPAN>STL</SPAN>包括的容器类有<TT><SPAN>[<FONT color=#0000ee><U>vector</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/Vector.html)</SPAN></TT><SPAN>, <TT>[<FONT color=#0000ee><U>list</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/List.html)</TT>, <TT>[<FONT color=#0000ee><U>deque</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/Deque.html)</TT>, <TT>[<FONT color=#0000ee><U>set</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/set.html)</TT>, <TT>[<FONT color=#0000ee><U>multiset</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/multiset.html)</TT>, <TT>[<FONT color=#0000ee><U>map</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/Map.html)</TT>, <TT>[<FONT color=#0000ee><U>multimap</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/Multimap.html)</TT>, <TT>[<FONT color=#0000ee><U>hash_set</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/hash_set.html)</TT>, <TT>[<FONT color=#0000ee><U>hash_multiset</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/hash_multiset.html)</TT>, <TT>[<FONT color=#0000ee><U>hash_map</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/hash_map.html)</TT>,</SPAN>和<TT><SPAN>[<FONT color=#0000ee><U>hash_multimap</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/hash_multimap.html)</SPAN></TT>。每一个容器类都是模板，而且可以被实例化去包含任何类型的对象。例如你可以使用<SPAN>vector&lt;int&gt;</SPAN>像使用一个原生的<SPAN>C</SPAN>数组，出此之外<SPAN>vector</SPAN>还消除了一些手动动态内存管理的琐碎事情。</FONT>
<PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>vector&lt;int&gt; v(3);<SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>// Declare a vector of 3 elements.</FONT></FONT></SPAN></PRE><PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>v[0] = 7;</FONT></FONT></SPAN></PRE><PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>v[1] = v[0] + 3;</FONT></FONT></SPAN></PRE><PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>v[2] = v[0] + v[1];<SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>// v[0] == 7, v[1] == 10, v[2] == 17<SPAN style="mso-spacerun: yes">  </SPAN></FONT></FONT></SPAN></PRE><PRE><FONT size=3><FONT face=宋体><SPAN><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>vector&lt;int&gt; v(3);<SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>// </SPAN>声明一个包含三个元素的<SPAN>vector.</SPAN></FONT></FONT></PRE><PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>v[0] = 7;</FONT></FONT></SPAN></PRE><PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>v[1] = v[0] + 3;</FONT></FONT></SPAN></PRE><PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>v[2] = v[0] + v[1];<SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>// v[0] == 7, v[1] == 10, v[2] == 17<SPAN style="mso-spacerun: yes">  </SPAN></FONT></FONT></SPAN></PRE><PRE><SPAN><FONT face=宋体 size=3> </FONT></SPAN></PRE>

<SPAN><FONT face=宋体 size=3>The STL also includes a large collection of _algorithms_ that manipulate the data stored in containers. You can reverse the order of elements in a <TT>vector</TT>, for example, by using the <TT>[<FONT color=#0000ee><U>reverse</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html)</TT> algorithm. </FONT></SPAN>

<FONT size=3><FONT face=宋体><SPAN>STL</SPAN>也包括一个很大的算法集合用于处理存储在容器的数据。例如你可以通过使用<TT><SPAN>[<FONT color=#0000ee><U>reverse</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html)</SPAN>算法</TT>倒序保存在<SPAN>vector</SPAN>中的元素。</FONT></FONT>
<PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>reverse(v.begin(), v.end()); // v[0] == 17, v[1] == 10, v[2] == 7</FONT></FONT></SPAN></PRE>

<SPAN><FONT size=3><FONT face=宋体>There are two important points to notice about this call to <TT>reverse</TT>. First, it is a global function, not a member function. Second, it takes two arguments rather than one: it operates on a _range_ of elements, rather than on a container. In this particular case the range happens to be the entire container <TT>v.</TT></FONT></FONT></SPAN>

<FONT face=宋体 size=3>在使用<TT><SPAN>[<FONT color=#0000ee><U>reverse</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html)</SPAN>时</TT>有两个重要点值得注意<SPAN>,</SPAN>第一点是它是一个全局函数，而不是一个成员函数；第二点是它包括两个参数而不是一个参数，容器元素的边界而不是容器。在我们这个例子中，边界即为整个容器。</FONT>

<SPAN><FONT face=宋体 size=3>The reason for both of these facts is the same: <TT>reverse</TT>, like other STL algorithms, is decoupled from the STL container classes. This means that <TT>reverse</TT> can be used not only to reverse elements in vectors, but also to reverse elements in lists, and even elements in C arrays. The following program is also valid.</FONT></SPAN>

<FONT size=3><FONT face=宋体>这两点其实是一样的：<TT><SPAN>[<FONT color=#0000ee><U>reverse</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html)</SPAN>，像其他的<SPAN>STL</SPAN>算法，是与<SPAN>STL</SPAN>容器类，这意味这<SPAN>[<FONT color=#0000ee><U>reverse</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html)</SPAN>不仅可以用于倒序<SPAN>vectors</SPAN>中的元素，还可以用于<SPAN>lists</SPAN>，甚至用于<SPAN>C</SPAN>数组。下面的程序是合法的。</TT></FONT></FONT>
<PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>double A[6] = { 1.2, 1.3, 1.4, 1.5, 1.6, 1.7 };</FONT></FONT></SPAN></PRE><PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>reverse(A, A + 6);</FONT></FONT></SPAN></PRE><PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>for (int i = 0; i &lt; 6; ++i)</FONT></FONT></SPAN></PRE><PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>cout &lt;&lt; "A[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; A[i];</FONT></FONT></SPAN></PRE>

<SPAN><FONT face=宋体 size=3>This example uses a _range_, just like the example of reversing a <TT>vector</TT>: the first argument to reverse is a pointer to the beginning of the range, and the second argument points one element past the end of the range. This range is denoted <TT>[A, A + 6)</TT>; the asymmetrical notation is a reminder that the two endpoints are different, that the first is the beginning of the range and the second is _one past_ the end of the range. </FONT></SPAN>

<FONT face=宋体 size=3>这个例子中使用的区间，就像在倒序<SPAN>vector</SPAN>中使用的：第一个参数是指向倒序的区间的开始，第二个参数是指向超过区间的第一个元素。这个区间表示的是<SPAN>[A</SPAN>，<SPAN>A+6],</SPAN>非对称的符号提示两点区间端点是不同的，第一个端点是区间的起始点，第二个是超过区间的第一个点。</FONT>

## <SPAN><FONT face=宋体>Iterators</FONT></SPAN>

## <FONT face=宋体>迭代器</FONT>

<SPAN><FONT face=宋体 size=3>In the example of reversing a C array, the arguments to <TT>reverse</TT> are clearly of type <TT>double*</TT>. What are the arguments to reverse if you are reversing a <TT>vector</TT>, though, or a <TT>list</TT>? That is, what exactly does <TT>reverse</TT> declare its arguments to be, and what exactly do <TT>v.begin()</TT> and <TT>v.end()</TT> return? </FONT></SPAN>

<FONT size=3><FONT face=宋体>在倒序<SPAN>C</SPAN>数组的例子中，传递给<TT><SPAN>[<FONT color=#0000ee><U>reverse</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html)</SPAN>的参数比较清晰就是<SPAN>double*</SPAN>。那么当你倒序一个<SPAN>vector</SPAN>或者<SPAN>list</SPAN>时传递给<SPAN>[<FONT color=#0000ee><U>reverse</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html)</SPAN>的参数是什么呢？也就是，<SPAN>[<FONT color=#0000ee><U>reverse</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html)</SPAN>声明的参数类型到底是什么，<SPAN>v.begin()</SPAN>和<SPAN>v.end()</SPAN>返回的是什么呢？</TT></FONT></FONT>

<SPAN><FONT face=宋体 size=3>The answer is that the arguments to <TT>reverse</TT> are _iterators_, which are a generalization of pointers. Pointers themselves are iterators, which is why it is possible to reverse the elements of a C array. Similarly, <TT>vector</TT> declares the nested types <TT>iterator</TT> and <TT>const_iterator</TT>. In the example above, the type returned by <TT>v.begin()</TT> and <TT>v.end()</TT> is <TT>vector&lt;int&gt;::iterator</TT>. There are also some iterators, such as <TT>[<FONT color=#0000ee><U>istream_iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/istream_iterator.html)</TT> and <TT>[<FONT color=#0000ee><U>ostream_iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/ostream_iterator.html)</TT>, that aren't associated with containers at all. </FONT></SPAN>

<FONT size=3><FONT face=宋体>答案是传递给<TT><SPAN>[<FONT color=#0000ee><U>reverse</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html)</SPAN>的参数是迭代器，一个泛型指针。指向它们自己的是迭代器，为什么可以倒序<SPAN>C</SPAN>数组中的元素呢。类似地，<SPAN>vector</SPAN>声明了内嵌类型的<SPAN>iterator</SPAN></TT><SPAN> and <TT>const_iterator</TT></SPAN>。在上面的例子中，<TT><SPAN>v.begin()</SPAN></TT>和<TT><SPAN>v.end()</SPAN>返回的类型是<SPAN>vector&lt;int&gt;::iterator</SPAN>。还有一些其他的迭代器，比如<SPAN>[<FONT color=#0000ee><U>istream_iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/istream_iterator.html)</SPAN></TT>和<TT><SPAN>[<FONT color=#0000ee><U>ostream_iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/ostream_iterator.html)</SPAN>，它们并没有和容器相关联。</TT></FONT></FONT>

<SPAN><FONT face=宋体 size=3>Iterators are the mechanism that makes it possible to decouple algorithms from containers: algorithms are templates, and are parameterized by the type of iterator, so they are not restricted to a single type of container. Consider, for example, how to write an algorithm that performs linear search through a range. This is the STL's <TT>[<FONT color=#0000ee><U>find</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/find.html)</TT> algorithm. </FONT></SPAN>

<FONT size=3><FONT face=宋体>迭代器是一种使得算法与容器分离的机制：算法是模板，被迭代器的类型参数化，所以他们没有限制非要在一个单独类型的容器上。考虑这样一个例子，怎么写一个算法实现在一个区间上线性查找。<SPAN>STL</SPAN>的<TT><SPAN>[<FONT color=#0000ee><U>find</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/find.html)</SPAN>即是这样的算法：<SPAN></SPAN></TT></FONT></FONT>

<SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>template &lt;class InputIterator, class T&gt;</FONT></FONT></SPAN>
<PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>InputIterator find(InputIterator first, InputIterator last, const T&amp; value) {</FONT></FONT></SPAN></PRE><PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>while (first != last &amp;&amp; *first != value) ++first;</FONT></FONT></SPAN></PRE><PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>return first;</FONT></FONT></SPAN></PRE><PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>}</FONT></FONT></SPAN></PRE><PRE><TT><SPAN>[<FONT face=宋体 color=#0000ee size=3><U>find</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/find.html)</SPAN><FONT face=宋体 size=3>要求三个参数：两个迭代器定义了一个区间，一个<SPAN>value</SPAN>用于在区间中查找。它在区间<SPAN>[first,last)</SPAN>中检查每一个迭代器，从开始到结束，在找到一个指向<SPAN>value</SPAN>的迭代器或者到达区间尾时停止。</FONT></TT></PRE>

<FONT size=3><FONT face=宋体><TT><SPAN>Find</SPAN></TT><SPAN> takes three arguments: two iterators that define a range, and a value to search for in that range. It examines each iterator in the range <TT>[first, last)</TT>, proceeding from the beginning to the end, and stops either when it finds an iterator that points to <TT>value</TT> or when it reaches the end of the range. </SPAN></FONT></FONT>

<FONT size=3><FONT face=宋体><TT><SPAN>First</SPAN></TT><SPAN> and <TT>last</TT> are declared to be of type <TT>InputIterator</TT>, and <TT>InputIterator</TT> is a template parameter. That is, there isn't actually any type called <TT>InputIterator</TT>: when you call <TT>find</TT>, the compiler substitutes the actual type of the arguments for the formal type parameters <TT>InputIterator</TT> and <TT>T</TT>. If the first two arguments to <TT>find</TT> are of type <TT>int*</TT> and the third is of type <TT>int</TT>, then it is as if you had called the following function.</SPAN></FONT></FONT>

<FONT size=3><FONT face=宋体><SPAN>First</SPAN>和<SPAN>last</SPAN>被声明为<SPAN>InputIterator</SPAN>类型，是一个模板参数类型。实际上并没有叫做<SPAN>InputItearot</SPAN>的类型：当你调用<TT><SPAN>[<FONT color=#0000ee><U>find</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/find.html)</SPAN>时，编译器会用实参类型替换型参<SPAN>InputIteartor</SPAN>和<SPAN>T</SPAN>。假如传递给<SPAN>[<FONT color=#0000ee><U>find</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/find.html)</SPAN>的前面两个参数是<SPAN>int*</SPAN>，第三个参数是<SPAN>int</SPAN>的话，实际上你调用的函数是下面这样的：</TT></FONT></FONT>
<PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>int* find(int* first, int* last, const int&amp; value) {</FONT></FONT></SPAN></PRE><PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>while (first != last &amp;&amp; *first != value) ++first;</FONT></FONT></SPAN></PRE><PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>return first;</FONT></FONT></SPAN></PRE><PRE><SPAN><FONT size=3><FONT face=宋体><SPAN style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </SPAN>}</FONT></FONT></SPAN></PRE>

## <SPAN><FONT face=宋体>Concepts and Modeling</FONT></SPAN>

## <FONT face=宋体>概念和模型</FONT>

<SPAN><FONT face=宋体 size=3>One very important question to ask about any template function, not just about STL algorithms, is what the set of types is that may correctly be substituted for the formal template parameters. Clearly, for example, <TT>int*</TT> or <TT>double*</TT> may be substituted for <TT>find</TT>'s formal template parameter <TT>InputIterator</TT>. Equally clearly, <TT>int</TT> or <TT>double</TT> may not: <TT>find</TT> uses the expression <TT>*first</TT>, and the dereference operator makes no sense for an object of type <TT>int</TT> or of type <TT>double</TT>. The basic answer, then, is that <TT>find</TT> implicitly defines a set of requirements on types, and that it may be instantiated with any type that satisfies those requirements. Whatever type is substituted for <TT>InputIterator</TT> must provide certain operations: it must be possible to compare two objects of that type for equality, it must be possible to increment an object of that type, it must be possible to dereference an object of that type to obtain the object that it points to, and so on. </FONT></SPAN>

<FONT size=3><FONT face=宋体>一个关于模板函数的非常重要的问题，不仅仅是<SPAN>STL</SPAN>算法，是正确的替换形式模板参。明显地，例如，<SPAN>int*</SPAN>和<SPAN>double*</SPAN>也许会替换<TT><SPAN>[<FONT color=#0000ee><U>find</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/find.html)</SPAN>的形式模板参数<SPAN>Input-</SPAN></TT></FONT></FONT>

<TT><FONT size=3><FONT face=宋体><SPAN>Iterato</SPAN>。同样地，<SPAN>int</SPAN>或者<SPAN>double</SPAN>也许不会：<SPAN>[<FONT color=#0000ee><U>find</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/find.html)</SPAN>使用表达式<SPAN>*first</SPAN>，解引用运算符对一个<SPAN>int</SPAN>或者<SPAN>double</SPAN>类型没有任何意义。一个简单的答案是，<SPAN>[<FONT color=#0000ee><U>find</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/find.html)</SPAN>也许显示定义了一个需求类型集合，它会这些参数能满足需求的时候被实例化（也就是不满足要求的会报错了）。能够替换<SPAN>InputIterator</SPAN>的参数必须提供能够以下操作：它必须可以比较两个类型是否相等，它必须可以自增，而且还可以解引用获得它指向的元素，等等。</FONT></FONT></TT>

<FONT size=3><FONT face=宋体><TT><SPAN>Find</SPAN></TT><SPAN> isn't the only STL algorithm that has such a set of requirements; the arguments to <TT>[<FONT color=#0000ee><U>for_each</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/for_each.html)</TT> and <TT>[<FONT color=#0000ee><U>count</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/count.html)</TT>, and other algorithms, must satisfy the same requirements. These requirements are sufficiently important that we give them a name: we call such a set of type requirements a _concept_, and we call this particular concept **[<FONT color=#0000ee><U>Input Iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/InputIterator.html)**. We say that a type _conforms to a concept_, or that it _is a model of a concept_, if it satisfies all of those requirements. We say that <TT>int*</TT> is a model of **Input Iterator** because <TT>int*</TT> provides all of the operations that are specified by the **Input Iterator** requirements. </SPAN></FONT></FONT>

<FONT size=3><FONT face=宋体><SPAN>STL</SPAN>算法中并不是只要<SPAN>Find</SPAN>有这样的一个需求集合，<TT><SPAN>[<FONT color=#0000ee><U>for_each</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/for_each.html)</SPAN></TT>和<TT><SPAN>[<FONT color=#0000ee><U>count</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/count.html)</SPAN>的参数，还要其他的算法同样需要满足同样的要求。这些需求是足够重要的，我们给他们起个名字：我们称这样的类型需求集合为概念，这样一个特殊的概念叫做输入迭代器。我们称满足这样要求的概念为一个模型。<SPAN>Int*</SPAN>是一个</TT>**<SPAN>Input Iterator</SPAN>**因为<SPAN>int*</SPAN>提供了所有**<SPAN>Input Iterator</SPAN>**要求的的操作。</FONT></FONT>

<SPAN><FONT face=宋体 size=3>Concepts are not a part of the C++ language; there is no way to declare a concept in a program, or to declare that a particular type is a model of a concept. Nevertheless, concepts are an extremely important part of the STL. Using concepts makes it possible to write programs that cleanly separate interface from implementation: the author of <TT>find</TT> only has to consider the interface specified by the concept **Input Iterator**, rather than the implementation of every possible type that conforms to that concept. Similarly, if you want to use <TT>find</TT>, you need only to ensure that the arguments you pass to it are models of **Input Iterator. **This is the reason why <TT>find</TT> and <TT>reverse</TT> can be used with <TT>list</TT>s, <TT>vector</TT>s, C arrays, and many other types: programming in terms of concepts, rather than in terms of specific types, makes it possible to reuse software components and to combine components together. </FONT></SPAN>

## <SPAN><FONT face=宋体>Refinement</FONT></SPAN>

## <FONT face=宋体>精巧</FONT>

<FONT size=3><FONT face=宋体>**<SPAN>Input Iterator</SPAN>**<SPAN> is, in fact, a rather weak concept: that is, it imposes very few requirements. An **Input Iterator** must support a subset of pointer arithmetic (it must be possible to increment an **Input Iterator** using prefix and postfix <TT>operator++</TT>), but need not support all operations of pointer arithmetic. This is sufficient for <TT>[<FONT color=#0000ee><U>find</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/find.html)</TT>, but some other algorithms require that their arguments satisfy additional requirements. <TT>[<FONT color=#0000ee><U>Reverse</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html)</TT>, for example, must be able to decrement its arguments as well as increment them; it uses the expression <TT>--last</TT>. In terms of concepts, we say that <TT>reverse</TT>'s arguments must be models of **[<FONT color=#0000ee><U>Bidirectional Iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/BidirectionalIterator.html)** rather than **Input Iterator**. </SPAN></FONT></FONT>

<FONT size=3><FONT face=宋体>**<SPAN>Input Iterator</SPAN>**事实上是一个非常弱的概念：它强加了很少的要求。一个**<SPAN>Input Iterator</SPAN>**必须提供一个指针算术的子集（它必须可以去通过前缀或者后缀的<SPAN>++</SPAN>递增一个**<SPAN>Input Iterator</SPAN>**），但是不需要提供所以的指针运算。这些对于<SPAN>find</SPAN>来说已经足够了，但是其他的一些算法需要一些额外的要求。例如<TT><SPAN>[<FONT color=#0000ee><U>Reverse</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html)</SPAN>必须可以通过<SPAN>--</SPAN>实现递减。按照概念的说法，我们说<SPAN>[<FONT color=#0000ee><U>Reverse</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html)</SPAN>的参数为</TT>**<SPAN>[<FONT color=#0000ee><U>Bidirectional Iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/BidirectionalIterator.html)</SPAN>**模型而非**<SPAN>Input Iterator</SPAN>**。</FONT></FONT>

<SPAN><FONT face=宋体 size=3>The **Bidirectional Iterator** concept is very similar to the **Input Iterator** concept: it simply imposes some additional requirements. The types that are models of **Bidirectional Iterator** are a subset of the types that are models of** Input Iterator**: every type that is a model of **Bidirectional Iterator** is also a model of **Input Iterator**. <TT>Int*</TT>, for example, is both a model of **Bidirectional Iterator** and a model of **Input Iterator**, but <TT>[<FONT color=#0000ee><U>istream_iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/istream_iterator.html)</TT>, is only a model of **Input Iterator**: it does not conform to the more stringent **Bidirectional Iterator** requirements. </FONT></SPAN>

<FONT size=3><FONT face=宋体>**<SPAN>Bidirectional Iterator</SPAN>**的概念和**<SPAN>Input Iterator</SPAN>**非常相似<SPAN>: </SPAN>它仅仅加了一些额外的要求。**<SPAN>Bidirectional Iterator</SPAN>**的模型也是一个**<SPAN>Input Iterator</SPAN>**的子集<SPAN>: </SPAN></FONT></FONT>

<FONT face=宋体 size=3>任何**<SPAN>Bidirectional Iterator</SPAN>**<SPAN> </SPAN>的模型同时也是一个**<SPAN>Input Iterator</SPAN>**<SPAN> </SPAN>的模型。 例如<SPAN>,<TT> Int*</TT>,</SPAN>既是 **<SPAN>Bidirectional Iterator</SPAN>**<SPAN> </SPAN>的模型也是一个**<SPAN>Input Iterator </SPAN>**的模型<SPAN>, </SPAN>但是<TT><SPAN>[<FONT color=#0000ee><U>istream_iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/istream_iterator.html)</SPAN></TT>仅仅是一个的模型**<SPAN>Input Iterator</SPAN>**<SPAN>: </SPAN>它并没有符合**<SPAN>Bidirectional Iterator</SPAN>**更严格的要求。</FONT>

<SPAN><FONT face=宋体 size=3>We describe the relationship between **Input Iterator** and **Bidirectional Iterator** by saying that **Bidirectional Iterator** is a _refinement_ of **Input Iterator**. Refinement of concepts is very much like inheritance of C++ classes; the main reason we use a different word, instead of just calling it "inheritance", is to emphasize that refinement applies to concepts rather than to actual types.</FONT></SPAN>

<FONT face=宋体 size=3>我们描述**<SPAN>Input Iterator</SPAN>**和**<SPAN>Bidirectional Iterator</SPAN>**的关系时说**<SPAN>Bidirectional Iterator</SPAN>**是一个更精巧的**<SPAN>InputIterator</SPAN>**。精巧概念非常像<SPAN>C++</SPAN>类的派生，我们用一个不同的词的主要原因是强调精巧是应用与概念而不是实际的类型。</FONT>

<SPAN><FONT face=宋体 size=3>There are actually three more iterator concepts in addition to the two that we have already discussed: the five iterator concepts are **[<FONT color=#0000ee><U>Output Iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/OutputIterator.html)**, **[<FONT color=#0000ee><U>Input Iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/InputIterator.html)**, **[<FONT color=#0000ee><U>Forward Iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/ForwardIterator.html)**, **[<FONT color=#0000ee><U>Bidirectional Iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/BidirectionalIterator.html)**, and **[<FONT color=#0000ee><U>Random Access Iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/RandomAccessIterator.html);** **Forward Iterator** is a refinement of **Input Iterator**, **Bidirectional Iterator** is a refinement of **Forward Iterator**, and **Random Access Iterator** is a refinement of **Bidirectional Iterator**. (**[<FONT color=#0000ee><U>Output Iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/OutputIterator.html)** is related to the other four concepts, but it is not part of the hierarchy of refinement: it is not a refinement of any of the other iterator concepts, and none of the other iterator concepts are refinements of it.) The _[<FONT color=#0000ee><U>Iterator Overview</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/Iterators.html)_ has more information about iterators in general. </FONT></SPAN>

<FONT size=3><FONT face=宋体>除了我们已经讨论的两个外实际上还要更多的迭代器类型：五种迭代器类型分别为<SPAN>[**<FONT color=#0000ee><U>Output Iterator</U></FONT>**](http://hi.baidu.com/fc/桌面/SGI-STL/OutputIterator.html), [**<FONT color=#0000ee><U>Input Iterator</U></FONT>**](http://hi.baidu.com/fc/桌面/SGI-STL/InputIterator.html), [**<FONT color=#0000ee><U>Forward Iterator</U></FONT>**](http://hi.baidu.com/fc/桌面/SGI-STL/ForwardIterator.html), [**<FONT color=#0000ee><U>Bidirectional Iterator</U></FONT>**](http://hi.baidu.com/fc/桌面/SGI-STL/BidirectionalIterator.html)</SPAN>和<SPAN>[**<FONT color=#0000ee><U>Random Access Iterator</U></FONT>**](http://hi.baidu.com/fc/桌面/SGI-STL/RandomAccessIterator.html); **Forward Iterator** </SPAN>是一个精巧的**<SPAN>Input Itearot</SPAN>**<SPAN>,** Bidirectional Iterator**</SPAN>是一个更精巧的 **<SPAN>Forward Iterator</SPAN>**<SPAN>, **Random Access Iterator** </SPAN>是一个更精巧的**<SPAN>Bidirectional Iterator</SPAN>**<SPAN>. (**[<FONT color=#0000ee><U>Output Iterator</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/OutputIterator.html)** </SPAN>和其他四中迭代器相关，但不是派生和精巧关系<SPAN>) _[<FONT color=#0000ee><U>Iterator Overview</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/Iterators.html)_ </SPAN>有更多的关于<SPAN>iterators</SPAN>的一般信息<SPAN>. </SPAN></FONT></FONT>

<SPAN><FONT face="Times New Roman"></FONT></SPAN>

<SPAN><FONT face=宋体 size=3>Container classes, like iterators, are organized into a hierarchy of concepts. All containers are models of the concept **[<FONT color=#0000ee><U>Container</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/Container.html)**; more refined concepts, such as **[<FONT color=#0000ee><U>Sequence</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/Sequence.html)** and **[<FONT color=#0000ee><U>Associative Container</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/AssociativeContainer.html)**, describe specific types of containers. </FONT></SPAN>

<FONT face=宋体 size=3>容器类，像迭代器一样被组织进一个概念中。所以的容器都是概念**<SPAN>[<FONT color=#800080><U>Container</U></FONT>](file:///E:/System_Document/桌面/SGI-STL/Container.html)</SPAN>**的模型；更加精巧的概念，比如说**<SPAN>[<FONT color=#800080><U>Sequence</U></FONT>](file:///E:/System_Document/桌面/SGI-STL/Sequence.html)</SPAN>**<SPAN> and **[<FONT color=#0000ee><U>Associative Container</U></FONT>](file:///E:/System_Document/桌面/SGI-STL/AssociativeContainer.html)**, </SPAN>描述了更特别的容器。</FONT>
<FONT size=3>

## 

## <SPAN><FONT face=宋体>下面这部分暂时不翻译，以后看需要时在看。</FONT></SPAN>

## <SPAN><FONT face=宋体>Other parts of the STL</FONT></SPAN>

<SPAN><FONT face=宋体>If you understand algorithms, iterators, and containers, then you understand almost everything there is to know about the STL. The STL does, however, include several other types of components. </FONT></SPAN>

<SPAN><FONT face=宋体>First, the STL includes several _utilities_: very basic concepts and functions that are used in many different parts of the library. The concept** [<FONT color=#0000ee><U>Assignable</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/Assignable.html)**, for example, describes types that have assignment operators and copy constructors; almost all STL classes are models of **Assignable**, and almost all STL algorithms require their arguments to be models of **Assignable**. </FONT></SPAN>

<SPAN><FONT face=宋体>Second, the STL includes some low-level mechanisms for allocating and deallocating memory. _[<FONT color=#0000ee><U>Allocators</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/Allocators.html)_ are very specialized, and you can safely ignore them for almost all purposes. </FONT></SPAN>

<SPAN><FONT face=宋体>Finally, the STL includes a large collection of _[<FONT color=#0000ee><U>function objects</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/functors.html)_, also known as _functors_. Just as iterators are a generalization of pointers, function objects are a generalization of functions: a function object is anything that you can call using the ordinary function call syntax. There are several different concepts relating to function objects, including **[<FONT color=#0000ee><U>Unary Function</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/UnaryFunction.html)** (a function object that takes a single argument, _i.e._ one that is called as <TT>f(x)</TT>) and **[<FONT color=#0000ee><U>Binary Function</U></FONT>](http://hi.baidu.com/fc/桌面/SGI-STL/BinaryFunction.html)** (a function object that takes two arguments, _i.e._ one that is called as <TT>f(x, y)</TT>). Function objects are an important part of generic programming because they allow abstraction not only over the types of objects, but also over the operations that are being performed.</FONT></SPAN>
</FONT>
</div>