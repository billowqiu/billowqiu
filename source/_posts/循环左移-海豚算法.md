---
title: 循环左移-海豚算法
id: 114
categories:
  - 数据结构/算法
date: 2010-08-29 21:55:00
tags:
---

    

题目要求是这样的：

&nbsp;

/*

设将n (n &gt; 1) 个整数存放到一维数组 R中。设计一个在时间和空间两方面尽可能高效的算法。

将 R 中的序列循环左移 p（0 &lt; p &lt; n）个位置，即将 R 中的数据由 (a0, a1, &hellip;&hellip;an-1)

变换为(ap, ap-1, &hellip;an-1, a0, a1, &hellip;, ap-1)。要求：

&nbsp;&nbsp; &nbsp; &nbsp; (1) 给出算法的基本设计思想。

&nbsp;&nbsp; &nbsp; &nbsp; (2) 根据设计思想，采用C或C++或JaVa语言描述算法，关键之处给出注释。

&nbsp;&nbsp; &nbsp; &nbsp; (3) 说明你所设计算法的时间复杂度和空间复杂度。

*/

下面是我的一个低效实现：

<span style="font-family: monospace; font-size: small;"><span style="white-space: pre-wrap;"><pre style="border: 1px dotted #785;background: #f5f5f5;">#include &lt;iostream&gt;
bool circleLeftMove( int nArr[], int nSize, int nMove )
{
    //判断边界条件
    if( nSize &lt;= 1 )
    {
        return false;
    }
    if( nMove &lt;= 0 || nMove &gt;= nSize )
    {
        return false;
    }
    //将需要移动的前nMove个数移动到一个缓存中
    int *pTemp = new int[nMove];
    for( int i=0; i&lt;nMove; ++i )
    {
        pTemp[i] = nArr[i];
    }
    //移动nMove开始的剩余数到0～(nSize - nMove)位置上
    int nStart = nMove;
    for( int j=0; j&lt;(nSize-nMove); ++j )
    {
        nArr[j] = nArr[nStart++];
    }
    //将缓存中的数据放到原始数组后面
    nStart = nSize-nMove;
    for( int i=0; i&lt;nMove; ++i )
    {
        nArr[nStart++] = pTemp[i];
    }
    //释放缓存
    delete []pTemp;
    return true;
}
void print( int arr[], int nSize )
{
    for(int i=0; i&lt;nSize; ++i )
    {
        std::cout &lt;&lt; "Num" &lt;&lt; i &lt;&lt; "==&gt;" &lt;&lt; arr[i] &lt;&lt; std::endl;
    }
}

int main(int argc, char *argv[])
{
    int nArr[]={0,1,2,3,4,5,6};
    std::cout &lt;&lt; "Before Circle Move:" &lt;&lt; std::endl;
    print( nArr, sizeof(nArr)/sizeof(nArr[0]) );
    int nMove;
    std::cout &lt;&lt; "Please Input The Move Count:";
    std::cin  &gt;&gt; nMove;
    std::cout &lt;&lt; std::endl;
    circleLeftMove( nArr, sizeof(nArr)/sizeof(nArr[0]), nMove );
    std::cout &lt;&lt; "After Circle Move " &lt;&lt; nMove &lt;&lt; std::endl;
    print( nArr, sizeof(nArr)/sizeof(nArr[0]) );
    return 0;
}
</pre> </span></span>

只是稍微测试了下，查看参考答案后发现这个算法叫做海豚算法，下面是其给出的参考实现：

大致思路为：

&nbsp;

首先把序列{ a0, a1, ..., ap, &hellip;, an-1 }逆转为{an-1, an-2, ..., ap, &hellip;,a0 }，

再分别逆转{ an-1, an-2, ..., ap }和{ ap-1, ap-2, &hellip;,a0 }，

最后得到{ ap, ap+1, &hellip;, an-1, a0, &hellip;, ap-1}。

<pre style="border: 1px dotted #785;background: #f5f5f5;">void reverse ( int A[ ], int left, int right )
{
    int n = right-left+1;
    if ( n &lt;= 1 ) return;
    if ( n &lt;= 1 ) return;
    for ( int i = 0; i &lt; n/2; i++ )
    {
        int temp = A[i];
        A[i] = A[n-i-1];
        A[n-i-1] = temp;
    }
}
void sift_Left ( int a[ ], int n, int p )
{
    reverse ( a, 0, n-1 );
    reverse ( a, 0, n-p-1 );
    reverse ( a, n-p, n-1 );
}</pre>&nbsp;

我实现的那个空间复杂度比较高O(p)，参考答案的为O(1)，时间上面都是O(n)。

通过比较其他实现，发现自己在算法方面确实需要提高，我完全是按照那种常规思路来实现，没有进行任何优化，这在效率有要求的时候显然就不行了，这里还悟出一点道理，高效算法一般都不是大多数人想到的那种常规方法，即根据要求一步步满足，而应该根据算法输出结果来分析其中的规律进而找到突破点。

&nbsp;

&nbsp;

</div>