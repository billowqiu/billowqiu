---
title: 消息传递过程
id: 188
categories:
  - VC
date: 2007-09-01 18:36:00
tags:
---

    <DIV class=cnt id=blog_text>

<FONT size=3><SPAN>![](http://blog.programfan.com/upfile/200709/200709010105037.gif)
</SPAN></FONT>

<FONT size=3><SPAN>据说是在</SPAN><SPAN>Run</SPAN><SPAN>中调用</SPAN><SPAN>AfxWndProc</SPAN><SPAN>（侯捷说的我在源码中找了会没找到，也不晓得是哪个间接调用的），在该函数里面接着调用</SPAN><SPAN>AfxCallWndProc</SPAN><SPAN>，然后</SPAN><SPAN>AfxCallWndProc</SPAN><SPAN>中有这么一段</SPAN></FONT>

<SPAN><FONT size=3>// special case for WM_INITDIALOG</FONT></SPAN>

<SPAN><FONT size=3>CRect rectOld;</FONT></SPAN>

<SPAN><FONT size=3>DWORD dwStyle = 0;</FONT></SPAN>

<SPAN><FONT size=3>if (nMsg == WM_INITDIALOG)</FONT></SPAN>

<SPAN><FONT size=3>_AfxPreInitDialog(pWnd, &amp;rectOld, &amp;dwStyle);</FONT></SPAN>

<SPAN><FONT size=3></FONT></SPAN>

<SPAN><FONT size=3>// delegate to object's WindowProc</FONT></SPAN>

<SPAN><FONT size=3>lResult = pWnd-&gt;WindowProc(nMsg, wParam, lParam);</FONT></SPAN>

<SPAN><FONT size=3></FONT></SPAN>

<SPAN><FONT size=3>// more special case for WM_INITDIALOG</FONT></SPAN>

<SPAN><FONT size=3>if (nMsg == WM_INITDIALOG)</FONT></SPAN>

<SPAN><FONT size=3>_AfxPostInitDialog(pWnd, rectOld, dwStyle);</FONT></SPAN>

<FONT size=3><SPAN>如果不是</SPAN><SPAN>WM_INITDIALOG</SPAN><SPAN>消息则调用</SPAN><SPAN>CWnd</SPAN><SPAN>的</SPAN><SPAN>WindowProc</SPAN><SPAN>，这时就有点迷惑了，应该说</SPAN><SPAN>CCmdTarget</SPAN><SPAN>是处理消息的基类其中的</SPAN><SPAN>OnCmdMsg</SPAN><SPAN>为什么不先调用呢，其实我也不清楚，查看了源代码后发现在</SPAN><SPAN>WindowProc</SPAN><SPAN>中会判断消息的类型里面有这么段：</SPAN></FONT>

**<SPAN style="FONT-SIZE: 15pt">CWnd::WindowProc</SPAN>**

<SPAN><FONT size=3>if (message == WM_COMMAND)</FONT></SPAN>

<SPAN><FONT size=3>{</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>if (OnCommand(wParam, lParam))</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>{</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>lResult = 1;</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>goto LReturnTrue;</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>}</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>return FALSE;</FONT></SPAN>

<SPAN><FONT size=3>}</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>**CWnd::OnCommand**</FONT></SPAN>

<FONT size=3><SPAN>如果是命令消息加速键等用户接口对象的</SPAN><SPAN>WM_COMMAND</SPAN><SPAN>通知消息（有些控件也会发送此消息比如按钮的单击），则调用</SPAN><SPAN>OnCommand</SPAN><SPAN>处理，而在</SPAN><SPAN>OnCommand</SPAN><SPAN>中会判断是一般命令消息还是控件消息，其中如果不是控件消息的话会调用</SPAN><SPAN>OnCmdMsg(nID, CN_UPDATE_COMMAND_UI, &amp;state, NULL);</SPAN><SPAN>看到了吧这里就调用了从</SPAN><SPAN>CCmdTarget</SPAN><SPAN>继承来的虚函数（我只找到了</SPAN><SPAN>CWnd</SPAN><SPAN>的这个地方调用了改消息）。</SPAN></FONT>

<SPAN><FONT size=3>接着是控件消息</FONT></SPAN>

<SPAN><FONT size=3>// special case for notifies</FONT></SPAN>

<SPAN><FONT size=3>if (message == WM_NOTIFY)</FONT></SPAN>

<SPAN><FONT size=3>{</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>NMHDR* pNMHDR = (NMHDR*)lParam;</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>if (pNMHDR-&gt;hwndFrom != NULL &amp;&amp; OnNotify(wParam, lParam, &amp;lResult))</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>goto LReturnTrue;</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>return FALSE;</FONT></SPAN>

<SPAN><FONT size=3>}</FONT></SPAN>

<FONT size=3><SPAN>关于</SPAN><SPAN>WM_NOTIFY</SPAN><SPAN>的一点说明</SPAN><SPAN>: Win32</SPAN><SPAN>使用新的</SPAN><SPAN>WM_NOFITY</SPAN><SPAN>来处理复杂的通知消息。</SPAN><SPAN>WM_COMMAND</SPAN><SPAN>类型的通知消息仅仅能传递一个控制窗口句柄</SPAN><SPAN>(lparam)</SPAN><SPAN>、控制窗</SPAN><SPAN>ID</SPAN><SPAN>和通知代码</SPAN><SPAN>(wparam)</SPAN><SPAN>。</SPAN><SPAN>WM_NOTIFY</SPAN><SPAN>能传递任意复杂的信息。</SPAN></FONT>

<FONT size=3><SPAN>因此控件消息也得以处理，</SPAN><SPAN>WindowProc</SPAN><SPAN>后面的消息处理可想而知了即其他</SPAN><SPAN>WM</SPAN><SPAN>开头的</SPAN><SPAN>Windows</SPAN><SPAN>标准消息。</SPAN></FONT>

<FONT size=3><SPAN>CFrameWnd</SPAN><SPAN>中改写了</SPAN><SPAN>OnCmdMsg</SPAN></FONT>

<SPAN><FONT size=3>BOOL CFrameWnd::OnCmdMsg(UINT nID, int nCode, void* pExtra,</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>AFX_CMDHANDLERINFO* pHandlerInfo)</FONT></SPAN>

<SPAN><FONT size=3>{</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>CPushRoutingFrame push(this);</FONT></SPAN>

<SPAN><FONT size=3></FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>// pump through current view FIRST</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>CView* pView = GetActiveView();</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>if (pView != NULL &amp;&amp; pView-&gt;OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>return TRUE;</FONT></SPAN>

<SPAN><FONT size=3></FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>// then pump through frame</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>if (CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>return TRUE;</FONT></SPAN>

<SPAN><FONT size=3></FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>// last but not least, pump through app</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>CWinApp* pApp = AfxGetApp();</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>if (pApp != NULL &amp;&amp; pApp-&gt;OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))</FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>return TRUE;</FONT></SPAN>

<SPAN><FONT size=3></FONT></SPAN>

<SPAN><FONT size=3><SPAN style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </SPAN>return FALSE;</FONT></SPAN>

<SPAN><FONT size=3>}</FONT></SPAN>

<FONT size=3><SPAN>由于在</SPAN><SPAN>CFrameWnd</SPAN><SPAN>中产生的消息一般都是</SPAN><SPAN>WM_COMMAND</SPAN><SPAN>消息，因此当</SPAN><SPAN>CWnd::WindowProc</SPAN><SPAN>被调用时会转到</SPAN><SPAN>OnCommand</SPAN><SPAN>而</SPAN><SPAN>CFrameWnd</SPAN><SPAN>又改写了</SPAN><SPAN>CWnd</SPAN><SPAN>的</SPAN><SPAN>OnCommand</SPAN><SPAN>那么</SPAN><SPAN>CFrameWnd</SPAN><SPAN>的</SPAN><SPAN>OnCmdMsg</SPAN><SPAN>是如何被调用的呢，原来在</SPAN><SPAN>CFrameWnd::OnCommand</SPAN><SPAN>中调用了</SPAN><SPAN>CWnd</SPAN><SPAN>的</SPAN><SPAN>OnCommand</SPAN><SPAN>，显然</SPAN><SPAN>CFrameWnd::OnCmdMsg</SPAN><SPAN>就被调用了，由上面的</SPAN><SPAN>CFrameWnd::OnCmdMsg</SPAN><SPAN>可以清楚的看到</SPAN><SPAN>CFrameWnd</SPAN><SPAN>对标准消息传递的过程的改写首先让当前的活动视图处理，通过查看视图的源代码可以发现视图的</SPAN><SPAN>OnCmdMsg</SPAN><SPAN>先让</SPAN><SPAN>CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo)</SPAN><SPAN>处理（最终就是调用</SPAN><SPAN>CCmdTarget::OnCmdMsg</SPAN><SPAN>，通过查看源代码可以发现</SPAN><SPAN>// look through message map to see if it applies to us</SPAN><SPAN>，其实就是查找此视图及相关基类的消息映射表进行相应的处理），接着是让</SPAN><SPAN>m_pDocument-&gt;OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);</SPAN><SPAN>处理，不用查看文档的代码也可以猜到文档模板的</SPAN><SPAN>OnCmdMsg</SPAN><SPAN>会调用，当视图的</SPAN><SPAN>OnCmdMsg</SPAN><SPAN>返回后如果没有处理的话又会调用</SPAN><SPAN>CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo)</SPAN><SPAN>（此时是</SPAN><SPAN>CFrameWnd</SPAN><SPAN>处理），最后如果还没有处理的话又给</SPAN><SPAN>App</SPAN><SPAN>对象处理，一直到让</SPAN><SPAN>DefWindowProc</SPAN><SPAN>处理。</SPAN></FONT>

<SPAN><FONT size=3>对话框的消息处理与此不同，具体可以根据源代码追踪</FONT></SPAN>

<FONT size=3><SPAN>呵呵，第一次跟踪查找</SPAN><SPAN>MFC</SPAN><SPAN>源代码，不知道以上结论正确与否，不过对我理解消息传递的过程还是有点帮助，写下来以免忘了。</SPAN></FONT>
</DIV>
</div>