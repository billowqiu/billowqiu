<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="taocoding">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="taocoding">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="taocoding">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/9/">





  <title>taocoding</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d13234060d812cb98a47e937139083a9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">taocoding</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/10/16/什么是设计模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/10/16/什么是设计模式/" itemprop="url">什么是设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-10-16T22:57:00+08:00">
                2009-10-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Think In C++上面说，可以把模式的基本概念看做一般情况下程序设计的基本概念：增加一些抽象层(让我想到了沉思录上面经常说的一句话C++的惯用法用类来表示概念)。当人们对某事物进行抽象的时候，隔离特定的细节，最直接的动机之一就是为了<em><span style="color: #ff00ff;">变化的事物与不变的事物分离开</span></em>。做到这一点的另一个方法是，一旦发现程序中的某些部分可能被修改，那么就要阻止那些修改在代码中到处传播副作用。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设计模式的目标是封装变化。书中讲到这样就可以把继承和组合看做一种设计模式，但是由编程语言直接支持的特性不能被称为设计模式，毕竟设计模式应该是和语言无关的。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 设计模式的分类：1创建型：用于怎样创建一个对象，通常包括隔离对象创建的细节，这样代码不依赖于对象是什么类型，因此在增加一种新的对象类型时不需要改变代码。2结构型：影响对象之间的连接方式，确保系统的变化不需要改变对象间的连接。3行为型：在程序中处理具有特定操作类型的对象，这些对象封装要执行的操作过程，比如解释一种语言，遍历一个序列或者实现一个算法。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 今天就到这，明天开始学习每一个具体的模式。</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/10/16/http协议之处理cookie/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/10/16/http协议之处理cookie/" itemprop="url">HTTP协议之处理Cookie</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-10-16T15:13:00+08:00">
                2009-10-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/系统编程/" itemprop="url" rel="index">
                    <span itemprop="name">系统编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>&ldquo;由于工作需要，最近在学习HTTP协议相关的一些知识，在登陆一个jsp网站时，POST过去的请求被拒绝了，通过抓包分析可以看到此网站需要设置Cookie，这里找打一篇文章写得很不错，只截抄了关于Cookie协议的一部分&rdquo;</em></p>
<p>&nbsp;</p>
<blockquote>
<p>大多数的 Web 应用程序都要求维护某种会话状态，如用户购物车的内容。这种会话状态的保持很多情况下需要借助于Cookie或者Session的帮助。本文结合在线页面翻译 （Machine Translation System）项目中对于Cookie的处理方法，探讨一下如何在HTTP应用代理中正确处理Cookie的传递和管理问题。<br><!--START RESERVED FOR FUTURE USE INCLUDE FILES--><!-- include java script once we verify teams wants to use this and it will work on dbcs and cyrillic characters --><!--END RESERVED FOR FUTURE USE INCLUDE FILES--></p>
</blockquote>
<p>读者定位为具有Java和Web开发经验的开发和设计人员。</p>
<p>读者可以学习到关于Cookie的工作原理和Cookie协议的细节，以及在一个HTTP应用代理的场景下Cookie的管理和处理思想，并可以直接使用文中的代码和思路，提高工作效率。</p>
<p>随着越来越多的系统移植到了Web上，HTTP协议具有了比以前更广泛的应用。不同的系统对WEB实现提出了不同的要求，基于HTTP协议的网络应用正趋于复杂化和多元化。很多应用需要把用户请求的页面进行处理后再返回给用户，比如页面关键字过滤，页面内容缓存、内容搜索、页面翻译等等。这些应用在实际效果上类似于一个HTTP应用代理：它们首先接受用户的请求，根据用户请求的URL去真正的目标服务器取回目标页面，再根据不同应用的要求做出相应处理后返回给用户。这样用户直接面对的就是这个HTTP应用代理，而通过它与其他页面进行交互。Cookie或Session技术的应用，解决了HTTP协议的一个问题 – 无法保持客户状态，因此它现在被广泛应用于各种Web站点中。上面提到的那些应用如果不能处理好Cookie和Session的传递、更新和废除等问题，就会极大的限制它们所能处理站点的范围，因此如何在HTTP应用代理中正确处理Cookie，成为一个必须解决的问题。本文结合在页面翻译（Machine Translation System）项目中对于Cookie的处理方法，探讨一下这方面的解决方案。</p>
<p>&nbsp;</p>
<p>Machine Translation System（以下简称MTS）是一个在线实时页面翻译系统，为用户在线提供把英文页面翻译成其他9种语言的服务。用户通过向MTS系统提交一个类似下面的URL使用此服务，其中参数url指明了用户所需要翻译的目标地址，参数language指明了所需翻译成的目标语言，<a href="http://www.mts.com是假想中提供MTS服务的站点。" target="_blank" rel="noopener">www.mts.com是假想中提供MTS服务的站点。</a></p>
<p><a href="http://www.mts.com/translate?url=http://www.ibm.com/&amp;language=French" target="_blank" rel="noopener"><span style="color: #5c81a7;">HTTP://www.mts.com/translate?url=http://www.ibm.com/&amp;language=French</span></a></p>
<p>一个完整的MTS系统处理过程可以分解成以下几个步骤：</p>
<ul>
<li>用户向MTS提交合适的URL。<em>   MTS在接到用户的请求后，解析出用户需要翻译的目标地址和目标语言，根据用户请求的目标地址，把请求转发到目标服务器。</em>   MTS接受来自目标服务器的应答，包括页面信息和HTTP头信息。<em>   MTS在确定得到正确的目标页面后，把页面内容送入WebSphere Translation Server进行翻译。</em>   把翻译后的页面连同修改后的HTTP头信息提交给用户。</li>
</ul>
<p><a name="N1006C"><strong>MTS逻辑图</strong></a><br><img src="http://www.ibm.com/developerworks/cn/java/j-cookie/images/image002.jpg" alt="MTS逻辑图"></p>
<p>当然，这其中涉及到很多的应用处理。比如与各种HTTP/HTTPS站点建立联结、根据HTTP头信息进行页面跳转和错误处理、为始终保持用户在翻译模式下而对目标的HTML页面进行分析和修改，根据系统设置对某些DNT（Do Not Translate）的页面进行过滤和跳转，当然还有对Cookie的处理等等。其他问题跟这篇文章关联不大，我们重点讨论在这种情况下的Cookie处理。Cookie跟随目标服务器的HTTP头信息被MTS接收到，经过MTS整理之后发给客户端浏览器。MTS在接到下一次用户对同一个站点的翻译请求时，再把从客户端得到的Cookie发送给目标服务器。</p>
<p>在以上的场景中，MTS充当的作用类似于一种HTTP应用代理服务器，它代替用户取得目标页面，并在作出相应处理后再提交给用户。当然，这种代理服务器不需要用户修改浏览器的代理服务器参数或者网络配置，而只是简单的在浏览器的地址栏中输入一个MTS能够识别的URL即可。此篇文章也是在这样一个应用场景的基础上，展开对HTTP应用代理服务器如何处理Cookie的讨论。</p>
<p><a name="N10082"><span class="atitle">问题的产生</span></a></p>
<p>在MTS系统中，目标服务器的Cookie在两个地方会产生问题。当MTS接收目标服务器应答的时候，Cookie随着HTTP头信息被MTS接收到的。这时候目标服务器认为MTS就是最终客户，因此它赋予了Cookie与目标服务器相符的属性。而如果MTS把这些Cookie原封不动的保存在HTTP头信息中，传给真正的最终用户的话，用户的浏览器会因为这些Cookie不合法而忽略它们。同理，当Cookie从浏览器端传回目标服务器的时候，也会遇到相同的问题。因此有必要对Cookie进行一些处理，以保证用户的浏览器能真正识别和利用这些Cookie。</p>
<p>但是为何用户浏览器无法识别从目标服务器传过来的原始Cookie呢？这是因为出于安全性的考虑，Cookie规范制定的时候对Cookie的产生和接受设置了一些严格的规范，不符合这些规范的Cookie，浏览器和服务器都将予以忽略。下面我们从Cookie规范入手进行介绍。</p>
<p>&nbsp;</p>
<p>目前有以下几种Cookie规范：</p>
<ul>
<li>Netscape cookie草案：是最早的cookie规范，基于rfc2109。尽管这个规范与rc2109有较大的差别，但是很多服务器都与之兼容。<em>   rfc2109， 是w3c发布的第一个官方cookie规范。理论上讲，所有的服务器在处理cookie(版本1)时，都要遵循此规范。遗憾的是，这个规范太严格了，以致很多服务器不正确的实施了该规范或仍在使用Netscape规范。</em>   rfc2965规范定义了cookie版本2，并说明了cookie版本1的不足。</li>
</ul>
<p>rfc2965规范的使用，目前并不多。rfc2109规范相应要严格得多，在实际应用上，并不是所有的浏览器和Web服务器都严格遵守。因此相比较而言，Netscape cookie草案倒是一个比较简洁和被广泛支持的Cookie规范，因此我们在这里以Netscape cookie草案为基础进行讨论，对于其他两种规范，我们的讨论和代码具有相同的意义。关于Netscape cookie草案的细节，大家可以参照Netscape官方站点，这里我们列举一些和我们讨论有关的内容。</p>
<p>根据Netscape cookie草案的描述，Cookie 是Web 服务器向用户的浏览器发送的一段ASCII码文本。一旦收到Cookie，浏览器会把Cookie的信息片断以”名/值”对(name-value pairs)的形式储存保存在本地。这以后，每当向同一个Web 服务器请求一个新的文档时，Web 浏览器都会发送之站点以前存储在本地的Cookie。创建Cookie的最初目的是想让Web服务器能够通过多个HTTP请求追踪客户。有些复杂的网络应用需要在不同的网页之间保持一致，它们需要这种会话状态的保持能力。</p>
<p>浏览器与Web服务器通过HTTP协议进行通讯，而Cookie就是保存在HTTP协议的请求或者应答头部（在HTTP协议中，数据包括两部分，一部分是头部，由一些名值对构成，用来描述要被传输数据的一些信息。一部分是主体(body)，是真正的数据（如HTML页面等））进行传送的。</p>
<p>在HTML文档被发送之前，Web服务器通过传送HTTP 包头中的Set-Cookie 消息把一个cookie 发送到用户的浏览器中。下面是一个遵循Netscape cookie草案的完整的Set-Cookie 头：</p>
<table border="0" cellspacing="0" cellpadding="0" width="100%"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">Set-Cookie：customer=huangxp; path=/foo; domain=.ibm.com;<br>expires= Wednesday, 19-OCT-05 23:12:40 GMT; [secure]<br></pre><br></td><br></tr><br></tbody><br></table>

<p>Set-Cookie的每个属性解释如下：</p>
<ul>
<li>Customer=huangxp 一个”名称＝值”对，把名称customer设置为值”huangxp”，这个属性在Cookie中必须有。<em>   path=/foo 控制哪些访问能够触发cookie 的发送。如果没有指定path，cookie 会在所有对此站点的HTTP 传送时发送。如果path=/directory，只有访问/directory 下面的网页时，cookie才被发送。在这个例子中，用户在访问目录/foo下的内容时，浏览器将发送此cookie。如果指定了path，但是path与当前访问的url不符，则此cookie将被忽略。</em>   domain=.ibm.com 指定cookie被发送到哪台计算机上。正常情况下，cookie只被送回最初向用户发送cookie 的计算机。在这个例子中，cookie 会被发送到任何在.ibm.com域中的主机。如果domain 被设为空，domain 就被设置为和提供cookie 的Web 服务器相同。如果domain不为空，并且它的值又和提供cookie的Web服务器域名不符，这个Cookie将被忽略。<em>   expires= Wednesday, 19-OCT-05 23:12:40 GMT 指定cookie 失效的时间。如果没有指定失效时间，这个cookie 就不会被写入计算机的硬盘上，并且只持续到这次会话结束。</em>   secure 如果secure 这个词被作为Set-Cookie 头的一部分，那么cookie 只能通过安全通道传输（目前即SSL通道）。否则，浏览器将忽略此Cookie。</li>
</ul>
<p>一旦浏览器接收了cookie，这个cookie和对远端Web服务器的连续请求将一起被浏览器发送。例如 前一个cookie 被存入浏览器并且浏览器试图请求 URL <a href="http://www.ibm.com/foo/index.html" target="_blank" rel="noopener">http://www.ibm.com/foo/index.html</a> 时，下面的HTTP 包头就被发送到远端的Web服务器。</p>
<p>GET /foo/index.html HTTP/1.0<br>Cookie：customer=huangxp </p>
<p>&nbsp;</p>
<p>在了解了Cookie协议的一些基本内容之后，让我们看看一次典型的网络浏览过程中浏览器如何识别和处理Cookie：</p>
<ul>
<li>浏览器对于Web服务器应答包头中Cookie的操作步骤：<br>1. 从Web服务器的应答包头中提取所有的cookie。<br>2. 解析这些cookie的组成部分（名称，值，路径等等）。<br>3. 判定主机是否允许设置这些cookie。允许的话，则把这些Cookie存储在本地。*   浏览器对Web服务器请求包头中所有的Cookie进行筛选的步骤：<br>1. 根据请求的URL和本地存储cookie的属性，判断那些Cookie能被发送给Web服务器。<br>2. 对于多个cookie，判定发送的顺序。<br>3. 把需要发送的Cookie加入到请求HTTP包头中一起发送。</li>
</ul>
<p>以上我们了解了在一个典型的浏览器与Web服务器交互的时候，Cookie的传递过程。下面我们将看到，如果在MTS代理网络浏览的过程中，不对Cookie进行修改，上面的Cookie传递过程将无法实现。</p>
<p>1. 假设用户希望把 <a href="http://www.ibm.com/foo/index.html" target="_blank" rel="noopener">http://www.ibm.com/foo/index.html</a> 页面翻译成法文，应该使用如下的url对MTS发出请求</p>
<p>： </p>
<p><a href="http://www.mts.com/translate?url=http://www.ibm.com/foo/index.html&amp;language=French" target="_blank" rel="noopener">http://www.mts.com/translate?url=http://www.ibm.com/foo/index.html&amp;language=French</a></p>
<p>2. MTS接收用户的请求，连接远程目标服务器 <a href="http://www.ibm.com/foo/index.html。目标服务器做出应答，返回HTTP头和HTML页面内容。其中，典型的HTTP头内容如下：" target="_blank" rel="noopener">http://www.ibm.com/foo/index.html。目标服务器做出应答，返回HTTP头和HTML页面内容。其中，典型的HTTP头内容如下：</a></p>
<table border="0" cellspacing="0" cellpadding="0" width="100%"><br><tbody><br><tr><br><td class="code-outline"><br><pre class="displaycode">HTTP/1.1 200 OK<br>Date: Mon, 24 Oct 2005 06:54:41 GMT<br>Server: IBM_HTTP_Server<br>Cache-Control: no-cache<br>Content-Length: 19885<br>Connection: close<br>Set-Cookie：customer=huangxp; path=/foo; domain=.ibm.com;<br>expires= Wednesday, 19-OCT-05 23:12:40 GMT<br>Content-Type: text/html<br></pre><br></td><br></tr><br></tbody><br></table>

<p>3. MTS不对Set-Cookie后的内容作任何处理，直接把它加到用户浏览器的应答头上发送给浏览器。</p>
<p>4. 浏览器将从Set-Cookie中解析出domain和path的值，分别是.ibm.com和/foo，并与请求的url：<a href="http://www.mts.com/translate?url=http://www.ibm.com/foo/index.html&amp;language=French进行比较。请求url的domain是www.mts.com，path是/，与Set-Cookie中的属性不符，所以浏览器将忽略此Cookie。" target="_blank" rel="noopener">http://www.mts.com/translate?url=http://www.ibm.com/foo/index.html&amp;language=French进行比较。请求url的domain是www.mts.com，path是/，与Set-Cookie中的属性不符，所以浏览器将忽略此Cookie。</a></p>
<p>另外，在浏览器发送Cookie的时候也会遇到同样的问题，同样如上例，如果浏览器里本来已经存储了<a href="http://www.ibm.com/foo/的Cookie，但由于用户要通过MTS访问此站点，浏览器经不会把已经存储的Cookie上转到MTS中，MTS也就无法把之传递到http://ibm.com/foo/上。" target="_blank" rel="noopener">http://www.ibm.com/foo/的Cookie，但由于用户要通过MTS访问此站点，浏览器经不会把已经存储的Cookie上转到MTS中，MTS也就无法把之传递到http://ibm.com/foo/上。</a></p>
<p>基于上面Cookie规范的介绍和例证，我们能看出，浏览器在接受某一个站点的Cookie的时候，需要检查Cookie的参数domain、path、secure，看是否与当前的站点和URL相符，如果不符的话，就会忽略。另一方面。浏览器在上传Cookie的时候，也会根据当前所访问站点的属性，上传相关的Cookie，而其他的Cookie则不予上传。</p>
<p>至此，我们讨论了需要修改Cookie的根本原因在于Cookie规范的限制。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/10/12/dib数据转换为ddb/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/10/12/dib数据转换为ddb/" itemprop="url">DIB数据转换为DDB</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-10-12T15:55:00+08:00">
                2009-10-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前段时间做视频拍照时，需要将接受到的视频数据进行拍照，由于传输过来的是原始的DIB数据，因此需要将其转换为DDB，经过查找MSDN得出如下片段，比较实用，留个记号</p>
<pre style="border: 1px dotted #785;background: #f5f5f5;">HDC hdc = ::GetDC(NULL);
HBITMAP hbmpFriend = NULL;

BITMAPINFO bmi; 
memset(&amp;bmi,sizeof(BITMAPINFO),0);
bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER); 
bmi.bmiHeader.biWidth = nwidth; 
bmi.bmiHeader.biHeight = nheight; 
bmi.bmiHeader.biPlanes =1; 
bmi.bmiHeader.biBitCount = 24; 

// If the bitmap is not compressed, set the BI_RGB flag. 
bmi.bmiHeader.biCompression = BI_RGB; 

// Compute the number of bytes in the array of color 
// indices and store the result in biSizeImage. 
// For Windows NT, the width must be DWORD aligned unless 
// the bitmap is RLE compressed. This example shows this. 
// For Windows 95/98/Me, the width must be WORD aligned unless the 
// bitmap is RLE compressed.
bmi.bmiHeader.biSizeImage = ((bmi.bmiHeader.biWidth * 24 +31) &amp; ~31) /8
* bmi.bmiHeader.biHeight; 
// Set biClrImportant to 0, indicating that all of the 
// device colors are important. 
bmi.bmiHeader.biClrImportant = 0; 
bmi.bmiHeader.biXPelsPerMeter = 0;
bmi.bmiHeader.biYPelsPerMeter = 0;

hbmpFriend = ::CreateCompatibleBitmap(hdc,nwidth,nheight);

int nRetCopyLines = SetDIBits(hdc, (HBITMAP)hbmpFriend, 
0, nheight, (LPVOID)pRGB, (BITMAPINFO*)&amp;bmi, DIB_RGB_COLORS);

if (hbmpFriend &amp;&amp; nRetCopyLines)
{
//该干啥就干啥
}

::DeleteObject(hbmpFriend);
::ReleaseDC(NULL, hdc);</pre> 

<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/10/11/clearcase一点心得/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/10/11/clearcase一点心得/" itemprop="url">ClearCase一点心得</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-10-11T19:38:00+08:00">
                2009-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/软件工程/" itemprop="url" rel="index">
                    <span itemprop="name">软件工程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&nbsp;&nbsp;&nbsp; 使用这个工具快一年了，个人感觉是非常强大的，不知道还有没有更强大的，没怎么用过SVN之类的，以后有时间也多试试。</p>
<p>最近在一次误装VS SP后，导致CC与VS关联失效，但是当时也没意识到是什么导致的，以为是和服务器连接的问题，又把管理员搞来了，他看了半天也不知道是什么问题，结果又是我想起了由于装SP导致的，(其实之前也因为自己的一次恶搞导致CC比较工具出现问题，那次也是让管理员搞的，当时只记得是换了个比较工具，当时也是自己没想出是什么原因导致的，结果他过来也不知道是什么原因，尴尬之下又是我想起了自己的恶搞，哎每次都是别人到现场才想出来，看来自己独立思索的能力还得加强)。之后管理员说让我重装，我当时觉得这个太麻烦了，而且说不定View之类还得重建(理论上应该可以不用重建，但是想着就麻烦)，后来他又说有个什么教程写不用重装，搞得很牛X的说等会让我拷贝一份，结果打开一看根本就是牛头不对马嘴，别人讲的是VSS和VS的关联，我估计他自己都没看过这”教程”，或者是看了也不&nbsp; 懂。&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 到了这份上我也不好再打找他来了，毕竟办公室还有那么多人，影响别人也不好，网上搜了半天也无果，不知道是什么激发了自己的灵感想到这类软件一般都是在安装过程中关联的，那么弄个修复安装不就OK了，于是关掉所有VS，找到相关程序，确实有个修复安装选项，点击，打开VS，O(&cap;_&cap;)O哈哈~，搞定了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是当我更新程序后习惯性的Compare有改动的文件时，再次出现比较工具提示找不到路径，没办法只得硬着头皮找了，只怪自己上次没看他弄的啥比较工具，拿同事电脑上共享的CC文件夹比较，替换还是不行，这次网络算是帮了个大忙，具体步骤就不说了，看下面的链接</p>
<p><a href="http://www-01.ibm.com/support/docview.wss?rs=984&amp;uid=swg21256807" target="_blank" rel="noopener">http://www-01.ibm.com/support/docview.wss?rs=984&amp;uid=swg21256807</a></p>
<p>其中这个KDiff3比自带的那个强大而且开源，也可以单独使用相当不错。</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/10/07/社会保障卡/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/10/07/社会保障卡/" itemprop="url">社会保障卡</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-10-07T19:45:00+08:00">
                2009-10-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/生活轨迹/" itemprop="url" rel="index">
                    <span itemprop="name">生活轨迹</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 社会保障卡是由劳动和社会保障部统一规划，由各地劳动保障部门面向社会发行，应用于劳动和社会保障各项业务领域的集成电路卡（IC卡）。其中，面向城镇从业人员、失业人员和离退休人员发放的称为社会保障（个人）卡，面向用人单位发放的称为社会保障（用人单位）卡。由于社会保障（个人）卡是目前劳动保障部有关卡规划和规范的重点，各地实际发放的也多集中于这一种卡，所以通常我们所说的社会保障卡，就是指社会保障（个人）卡。</p>
<p>　　社会保障卡卡面和卡内均记载持卡人姓名、性别、公民身份号码等基本信息，卡内标识了持卡人的个人状态（就业、失业、退休、失业等），可以记录持卡人社会保险缴费情况、养老保险个人账户信息、医疗保险个人账户信息、职业资格和技能、就业经历、工伤及职业病伤残程度等。社会保障卡是劳动者在劳动保障领域办事的电子凭证。持卡人可以凭卡就医，进行医疗保险个人账户结算；可以凭卡办理养老保险事务；可以凭卡到相关部门办理求职登记和失业登记手续，申领失业保险金，申请参加就业培训；可以凭卡申请劳动能力鉴定和申领享受工伤保险待遇等。此外，社会保障卡还是握在劳动者手中开启与系统联络之门的钥匙，凭借这把钥匙，持卡人可以上网查询信息，将来还可以在网上办理有关劳动和社会保障事务。</p>
<p>　　社会保障卡的全称是&ldquo;中华人民共和国社会保障卡&rdquo;。从这一名称的含义上讲，发放的对象是政府有关部门实施社会保障的人群；从其内容上讲，可以涉及有关个人社会保障的方方面面，既包括社会保险，也包括就业服务，一些地区的地方政府根据当地的管理需要，还将更多的社会管理事务也放入其中；从其涉及的地域上讲，这是全国范围内可以使用的IC卡，可以适应全国统一劳动力市场和社会保障系统联网的需要，适应人员流动的需求。</p>
<p>　　要正确理解社会保障卡这一概念，还必须清楚社会保障卡与其他行业性IC卡，特别是同银行卡的关系。由于社会保障卡上存有的供持卡人在医院就医结算的&ldquo;个人账户&rdquo;，类似于银行卡的&ldquo;电子钱包&rdquo;，一些地区或厂商便采用银行卡的标准来设计社会保障卡。银行卡标准是针对银行卡应用而制订的规范，其文件存储格式、指令操作、安全管理等方面都是针对与金融有关的各种交易行为设计的。而劳动保障领域发放的IC卡主要是用于行政管理，其主要功能是对信息记录进行管理，与银行卡的功能有很大不同。社会保障卡中的&ldquo;医疗保险个人账户&rdquo;也同银行卡中的&ldquo;电子钱包&rdquo;有本质的区别，它记载的是个人账户中&ldquo;帐&rdquo;的情况，而不是真正的&ldquo;钱&rdquo;。持卡人将个人账户余额划到卡中之后，医疗保险机构仍然要对账户的使用负责，即使持卡人的卡丢失、损坏，只要挂失前个人账户上的资金未被他人冒用，便仍旧归持卡人所有，仍可以使用这部分账户进行医疗消费。而银行卡中的电子钱包一旦用户将钱圈存到卡中，这笔钱便同银行无任何关系，一旦卡丢失、损坏，其损失完全由持卡人承担。因此，医疗保险个人账户绝不能采用电子钱包的模式进行处理。还有些地方将社会保障应用和金融应用放到一张卡上，对此，是不提倡的，因为将商业性应用和管理性应用集于一卡，在管理上会造成许多弊端，会给持卡人和管理机构带来许多不便，甚至给持卡人造成损失。</p>
<p>&nbsp;</p>
<p>原文链接:<a href="http://www.gov.cn/banshi/2005-07/18/content_15856.htm" target="_blank" rel="noopener">http://www.gov.cn/banshi/2005-07/18/content_15856.htm</a></p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/09/26/vs2005向导生成的win32程序编译gdi问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/09/26/vs2005向导生成的win32程序编译gdi问题/" itemprop="url">VS2005向导生成的win32程序编译GDI+问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-09-26T13:59:00+08:00">
                2009-09-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>昨天用VS2005向导生成的Win32程序，当向其中添加GDI+相关文件引用时会提示如下错误</p>
<p>&nbsp;</p>
<p>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(67) : error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(67) : error C2440: &ldquo;初始化&rdquo;: 无法从&ldquo;const char [37]&rdquo;转换为&ldquo;int&rdquo;<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 没有使该转换得以执行的上下文<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(67) : error C2146: 语法错误 : 缺少&ldquo;;&rdquo;(在标识符&ldquo;IImageBytes&rdquo;的前面)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(67) : error C2470: &ldquo;IImageBytes&rdquo;: 看起来像函数定义，但没有参数列表；跳过明显的函数体<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(67) : error C2059: 语法错误 : &ldquo;public&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(246) : error C2146: 语法错误 : 缺少&ldquo;;&rdquo;(在标识符&ldquo;id&rdquo;的前面)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(246) : error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(246) : error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(384) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(395) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(405) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(443) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(444) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(445) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(453) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(465) : error C2535: &ldquo;Gdiplus::Image::Image(void)&rdquo;: 已经定义或声明成员函数<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(384) : 参见&ldquo;Gdiplus::Image::Image&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(499) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(510) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1133) : error C2065: &ldquo;IStream&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1133) : error C2065: &ldquo;stream&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1133) : error C2065: &ldquo;image&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1133) : error C2275: &ldquo;Gdiplus::GpImage&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusgpstubs.h(61) : 参见&ldquo;Gdiplus::GpImage&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1133) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1133) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1139) : error C2275: &ldquo;Gdiplus::GpImage&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusgpstubs.h(61) : 参见&ldquo;Gdiplus::GpImage&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1139) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1139) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1156) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1244) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1247) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1250) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1262) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1275) : error C2065: &ldquo;bitmap&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1275) : error C2275: &ldquo;Gdiplus::GpBitmap&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusgpstubs.h(62) : 参见&ldquo;Gdiplus::GpBitmap&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1275) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1275) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1281) : error C2275: &ldquo;Gdiplus::GpBitmap&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusgpstubs.h(62) : 参见&ldquo;Gdiplus::GpBitmap&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1281) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1281) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2128) : error C2065: &ldquo;header&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2128) : error C2275: &ldquo;Gdiplus::MetafileHeader&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetaheader.h(112) : 参见&ldquo;Gdiplus::MetafileHeader&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2128) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2128) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2146) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2166) : error C2065: &ldquo;metafile&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2166) : error C2275: &ldquo;Gdiplus::GpMetafile&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusgpstubs.h(63) : 参见&ldquo;Gdiplus::GpMetafile&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2166) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2166) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2213) : error C2275: &ldquo;HDC&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/windef.h(260) : 参见&ldquo;HDC&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2213) : error C2146: 语法错误 : 缺少&ldquo;)&rdquo;(在标识符&ldquo;referenceHdc&rdquo;的前面)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2213) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2213) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2213) : error C2275: &ldquo;HDC&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/windef.h(260) : 参见&ldquo;HDC&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2219) : error C2059: 语法错误 : &ldquo;)&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2224) : error C2275: &ldquo;HDC&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/windef.h(260) : 参见&ldquo;HDC&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2224) : error C2146: 语法错误 : 缺少&ldquo;)&rdquo;(在标识符&ldquo;referenceHdc&rdquo;的前面)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2224) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2224) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2224) : error C2275: &ldquo;HDC&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/windef.h(260) : 参见&ldquo;HDC&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2230) : error C2059: 语法错误 : &ldquo;)&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdipluspath.h(133) : error C2061: 语法错误 : 标识符&ldquo;byte&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(80) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(197) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(197) : error C2535: &ldquo;Gdiplus::Metafile::Metafile(void)&rdquo;: 已经定义或声明成员函数<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(80) : 参见&ldquo;Gdiplus::Metafile::Metafile&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(213) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(213) : error C2535: &ldquo;Gdiplus::Metafile::Metafile(void)&rdquo;: 已经定义或声明成员函数<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(80) : 参见&ldquo;Gdiplus::Metafile::Metafile&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(231) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(231) : error C2535: &ldquo;Gdiplus::Metafile::Metafile(void)&rdquo;: 已经定义或声明成员函数<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(80) : 参见&ldquo;Gdiplus::Metafile::Metafile&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(277) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(370) : error C2535: &ldquo;Gdiplus::Metafile::Metafile(void)&rdquo;: 已经定义或声明成员函数<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(80) : 参见&ldquo;Gdiplus::Metafile::Metafile&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(207) : error C2065: &ldquo;referenceHdc&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(207) : error C2065: &ldquo;type&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(208) : error C2065: &ldquo;description&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(225) : error C2065: &ldquo;frameRect&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(225) : error C2065: &ldquo;frameUnit&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(45) : error C2275: &ldquo;BOOL&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/windef.h(152) : 参见&ldquo;BOOL&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(45) : error C2146: 语法错误 : 缺少&ldquo;)&rdquo;(在标识符&ldquo;useEmbeddedColorManagement&rdquo;的前面)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(45) : error C2761: &ldquo;{ctor}&rdquo;: 不允许成员函数重新声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(45) : error C2059: 语法错误 : &ldquo;)&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(46) : error C2143: 语法错误 : 缺少&ldquo;;&rdquo;(在&ldquo;{&rdquo;的前面)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(46) : error C2447: &ldquo;{&rdquo;: 缺少函数标题(是否是老式的形式表?)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(80) : error C2275: &ldquo;BOOL&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/windef.h(152) : 参见&ldquo;BOOL&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(80) : error C2146: 语法错误 : 缺少&ldquo;)&rdquo;(在标识符&ldquo;useEmbeddedColorManagement&rdquo;的前面)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(80) : error C2761: &ldquo;Gdiplus::Image *Gdiplus::Image::FromStream(void)&rdquo;: 不允许成员函数重新声明</p>
<p>&nbsp;</p>
<p>但是自己新建一个空工程然后添加相关的文件就没问题，找了半天猜猜可能是StdAfx里面的宏有问题，试了几下发现然来是</p>
<p>#define WIN32_LEAN_AND_MEAN&nbsp;&nbsp;// 从 Windows 头中排除极少使用的资料</p>
<p>这个定义导致的，去掉就OK了，没想到M$自己的东西都这样。</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/09/05/socket基础知识/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/09/05/socket基础知识/" itemprop="url">socket基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-09-05T17:52:00+08:00">
                2009-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/系统编程/" itemprop="url" rel="index">
                    <span itemprop="name">系统编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果一个socket成功创建了，它存在于一个地址一个地址家族(socket函数的第一个参数即为地址家族)，为什么要提供这个参数呢，因为Windows Sockets提供了一个与协议无关的编程接口，使得开发人员可以开发直接使用任何一种协议的网络程序。尽管如此，要实现网络通信定位和网络连接，为主机定址是必须得，bind函数就是干这个的。</span><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 另外在调用send/sendto时如果这是一个未绑定的socket，那么Windows Sockets会执行一个隐式的bind调用，系统会给其分配一个唯一值，并标记为绑定状态，可以通过getsockname 获取相关scoket name。因此在bind之前没有send/sendto之类操作，那么调用recv/recvfrom会得到10022的错误代码，即&ldquo;提供了一个无效的参数&rdquo;，也就是在socket没有绑定一个ip/port之前是不能接受数据的，联想到我们一般的C/S模式，S端都会先bind到一个ip/port，因为S是服务提供者，他不会主动发送数据，而是等待C来要求服务也就是发送数据，所以我们一般在C端不需要显示调用bind而是当send/sendto之类函数调用时，由系统绑定一个唯一的ip/port。对于S端我们一般都是指定一个固定的ip/port，而C端，MSDN上面的建议是最好让系统自动分配一个，可以在调用bind的时候可以将port设为0以免发生冲突。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/09/01/调试mfc源代码/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/09/01/调试mfc源代码/" itemprop="url">调试MFC源代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-09-01T08:19:00+08:00">
                2009-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>将C:/WINDOWS/system32下面的MFCXXXX.PDB拷贝到程序所在目录即可，以后就不会出现MFC42D.dll之类的Call Stack了，调试Modal对话框问题中偶然意识到的。</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/08/25/返回值为引用的一点测试/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/08/25/返回值为引用的一点测试/" itemprop="url">返回值为引用的一点测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-08-25T22:10:00+08:00">
                2009-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近做多人视频时设计了一个简单的类，但是简单的类也很能说明问题，也再次说明有些基础知识还是理解得不够深刻，刚写了个测试程序以便日后查阅，主要是关于返回值为引用类型时的一点测试:</p>
<pre style="border: 1px dotted #785;background: #f5f5f5;">#include &lt;iostream&gt;
using namespace std;

class CConstRef
{
public:
CConstRef(int iA):m_iA(iA)
{
}
const int&amp; GetA()const
{
return m_iA;
}
int&amp; GetA()
{
return m_iA;
}
void PrintAddress()const
{
cout&lt;&lt;"Address of m_iA = "&lt;&lt;&amp;m_iA&lt;&lt;endl;
}
private:
int m_iA;
};

int main(int argc, char* argv[])
{
//常量对象
const CConstRef cCA(8);
//非常量对象
CConstRef CA(9);
//////////////////////////////////////////////////////////////////////////
//注意下面的调用都是返回对象cCA的成员m_iA的引用,且此引用都是用来初始化另一引用
//因此地址都相同
//调用int&amp; GetA()
int&amp; ra = CA.GetA();
CA.PrintAddress();
cout&lt;&lt;"Address of ra = "&lt;&lt;&amp;ra&lt;&lt;endl;
ra = 3;
cout&lt;&lt;"Now the CA.m_iA = "&lt;&lt;CA.GetA()&lt;&lt;endl;

//调用int&amp; GetA()
const int&amp; ra1 = CA.GetA();
cout&lt;&lt;"Address of ra1 = "&lt;&lt;&amp;ra1&lt;&lt;endl;
//////////////////////////////////////////////////////////////////////////
//调用int&amp; GetA()
int va = CA.GetA();
CA.PrintAddress();
cout&lt;&lt;"Address of va = "&lt;&lt;&amp;va&lt;&lt;endl;
va = 3;
cout&lt;&lt;"Now the CA.m_iA = "&lt;&lt;CA.GetA()&lt;&lt;endl;

//调用int&amp; GetA()
const int va1 = CA.GetA();
cout&lt;&lt;"Address of va1 = "&lt;&lt;&amp;va1&lt;&lt;endl;
//////////////////////////////////////////////////////////////////////////
//下面的rb就是cCA.m_iA
const int&amp; rb = cCA.GetA();

cCA.PrintAddress();
cout&lt;&lt;"Address of rb = "&lt;&lt;&amp;rb&lt;&lt;endl;

/*
error: invalid initialization of reference of type 'int&amp;' from expression of type 'const int'
上面的错误时G++提示的，这么说来其实编译器给我们返回的是const int而不是const int&amp;
*/
// int&amp; rb1 = cCA.GetA();

//下面的的vb和vb1都是是cCA.m_iA的一个副本
const int vb = cCA.GetA();
cout&lt;&lt;"Address of vb = "&lt;&lt;&amp;vb&lt;&lt;endl;

int vb1 = cCA.GetA();
cout&lt;&lt;"Address of vb1 = "&lt;&lt;&amp;vb1&lt;&lt;endl;
vb1 = 10;

cout&lt;&lt;"Now the cCA.m_iA = "&lt;&lt;cCA.GetA()&lt;&lt;endl;

return 0;
}
</pre> 

<p>下面是在MinGW的G++下输出的结果</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/ToCpp/EntryImages/20090825/Result.PNG" alt="返回引用" title="返回引用"></p>
<p>&nbsp;</p>
<blockquote>
<p>&nbsp;</p>
<p><span style="background-color: #ff0000;"><span style="color: #00ff00;"><span style="background-color: #ffffff;"><strong>路路漫漫其修远兮，吾将上下而求索！</strong></span></span></span><br></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/07/21/c设计模式之一-工厂模式（简单工厂、工厂和抽象/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/07/21/c设计模式之一-工厂模式（简单工厂、工厂和抽象/" itemprop="url">C++设计模式之一 工厂模式（简单工厂、工厂和抽象工厂）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-07-21T23:34:00+08:00">
                2009-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文地址：<a href="http://www.cnblogs.com/Seasky/archive/2009/02/06/1385609.html" target="_blank" rel="noopener">http://www.cnblogs.com/Seasky/archive/2009/02/06/1385609.html</a></p>
<p><a href="http://files.cnblogs.com/Seasky/FactoryPattern.7z" title="工厂模式实例代码" target="_blank" rel="noopener">实例代码下载</a>&nbsp;<br><a href="http://files.cnblogs.com/Seasky/FactoryPatternChart.zip" title="结构图下载" target="_blank" rel="noopener">结构类图下载</a>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp; 今天开始这个系列之前，心里有些恐慌，毕竟园子里的高手关于设计模式的经典文章很多很多，特别是大侠<a href="http://terrylee.cnblogs.com/" target="_blank" rel="noopener">李会军</a>、<a href="http://zhenyulu.cnblogs.com/" target="_blank" rel="noopener">吕震宇</a> 老师的文章更是堪称经典。他们的文笔如行云流水，例子活泼生动，讲解深入浅出。好在他们都是用C#描述，也没有提供必要的源码下载，所以我这里用C++实现。首先我想声明的是我的文笔绝对不如他们的好，例子也没有他们的形象，不过我打算把C++的代码实现和类图提供给大家，就算作为一种补充吧。</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp; 开始设计模式自然而然到提到几个原则：I、开闭法则（OCP）；II、里氏代换法则（LSP）；III、依赖倒置法则(DIP)；IV、接口隔离法则（ISP）；V、合成/聚合复用原则（CARP）；VI、迪米特法则（LoD），这几个法则在<a href="http://zhenyulu.cnblogs.com/" target="_blank" rel="noopener">吕震宇</a> 老师的<a href="http://www.cnblogs.com/zhenyulu/articles/36061.html" target="_blank" rel="noopener">设计模式（二）</a>和<a href="http://www.cnblogs.com/zhenyulu/articles/36068.html" target="_blank" rel="noopener">设计模式（三）</a>中有非常详尽的阐述和深入浅出的举例分析。有兴趣的朋友打开链接看一下就可以了。</p>
<p>&nbsp; &nbsp; &nbsp; 补充说明：</p>
<ul>
<li>我这里所以代码都是用VS2005的C++编译器实现。所以不能保证在其他IDE中能顺利编译，但是我想如果你使用其他编译器，也应该不会有太大问题，主要也应该是stdafx.h文件中包含的头文件问题。<em>   里面出行的结构图都是用微软的Visio2003 绘制，大家下载后可以直接用Visio打开。</em>   在以后所有的模式例子中都有客户程序，客户程序这个角色不是模式本身的内容，它是模式之外的部分，但是正是这个客户程序完成了对模式的使用，模式本身的结构是讲解的重点，但是客户程序如何使用模式也是理解模式的一个重要方面，因此在我后续的介绍中都有客户程序这个角色，并会说明究竟调用模式中的哪些角色完成对模式的使用。</li>
</ul>
<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><h5 id="生活例子"><a href="#生活例子" class="headerlink" title="生活例子"></a>生活例子</h5><p>&nbsp; &nbsp; &nbsp; 吃饭是人的基本需求，如果人类不需要吃饭，可能我们就能活得清闲许多，也就不需要像现在一样没日没夜的工作，学习。我们学习是为了找到更好的工作，好工作为了赚更多的钱，最终为了吃饱饭，吃好饭。因此可以说吃饭是与人息息相关，下面就从吃饭的例子来引入工厂模式的学习。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 如果你想吃饭了，怎么办自己做吗？自己做就相当于程序中直接使用new。当然是自己下个指令，别人来做更爽。那就把做饭的任务交给你的老婆吧，那么她就是一个做饭的工厂了，你告诉她要要吃红烧肉，等会她就从厨房给你端出来一盘香喷喷的红烧肉了，再来个清蒸鱼吧，大鱼大肉不能太多，那就再来个爆炒空心菜，最后再来个西红柿鸡蛋汤。下图 1) 就是这个问题的模型。<br><img src="http://images.cnblogs.com/cnblogs_com/Seasky/167561/r_1-2.JPG" alt="">&nbsp;<br>（图1）<br>&nbsp; &nbsp; &nbsp; &nbsp;显然到了这里，你是Client，你老婆就是工厂，她拥有做红烧肉的方法，做清蒸鱼的方法，做爆炒空心菜、西红柿鸡蛋汤的方法，这些方法返回值就是食物抽象。红烧肉、清蒸鱼、爆炒空心菜、西红柿鸡蛋汤就是食物的继承类，到这里你就可以大吃二喝了。简单工厂模式也成型了。哈哈，娶一个手艺不错的老婆还真好，吃的好，吃的爽，又清闲。</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp; 下面来看标准的简单工厂模式的分析。&nbsp;</p>
<h5 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h5><p>把一系列拥有共同特征的产品的创建封装 </p>
<h5 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h5><p><img src="http://images.cnblogs.com/cnblogs_com/Seasky/167561/r_1-3.JPG" alt="">&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; （图2）</p>
<h5 id="角色分析"><a href="#角色分析" class="headerlink" title="角色分析"></a>角色分析</h5><div style="padding-right: 20px; padding-left: 30px; padding-bottom: 10px; padding-top: 0px;"><strong>产品基类</strong>： 工厂创建的所有产品的基类, 它负责描述所有实例所共有的公共接口。它用来作为工厂方法的返回参数。<br>代码实现：<br><pre class="programlisting">        //—这时一个系列的产品基类<br>class Product<br>{<br>protected:<br>Product(void);<br>public:<br>virtual ~Product(void);<br>public:<br>virtual void Function() = 0;<br>};<br>//cpp<br>Product::Product(void)<br>{<br>}<br>Product::~Product(void)<br>{<br>}<br></pre><br><strong>具体产品类</strong>：产品1和产品2，这个角色实现了抽象产品角色所定义的接口。<br>代码实现：<br><pre class="programlisting">        //产品A<br>class ConcreteProductA:public Product<br>{<br>public:<br>ConcreteProductA(void);<br>public:<br>virtual ~ConcreteProductA(void);<br>public:<br>virtual void Function();<br>};<br>//cpp<br>ConcreteProductA::ConcreteProductA()<br>{<br>cout&lt;&lt;”创建 A 产品”&lt;&lt;endl;<br>}<br>ConcreteProductA::~ConcreteProductA()<br>{<br>cout&lt;&lt;”释放 A 产品”&lt;&lt;endl;<br>}<br>void ConcreteProductA::Function()<br>{<br>cout&lt;&lt;”这是产品 A 具有的基本功能”&lt;&lt;endl;<br>}<br>//产品B与A类似不这里不再给出，大家可以下载源码<br></pre><br><br><strong>工厂类</strong>：负责具体产品的创建，有两种方式实现产品的创建，I、创建不同的产品用不同的方法；II、创建不同产品用相同的方法，然后通过传递参数实现不同产品的创建。本实例中两种模式都给出了，大家自行分析。<br><br><pre class="programlisting">//简单工厂，此类不需要继承，直接硬编码实现生成的产品<br>class SimpleFactory<br>{<br>public:<br>SimpleFactory(){}<br>public:<br>~SimpleFactory(){}<br>public:<br>Product <em>CreateProduct(int ProuctType);<br>Product </em>CreateProductA();<br>Product <em>CreateProductB();<br>};<br>//CPP<br>Product </em> SimpleFactory::CreateProduct(int ProductType=0)<br>{<br>Product <em>p = 0;<br>switch(ProductType)<br>{<br>case 0:<br>p= new ConcreteProductA();<br>break;<br>case 1:<br>p= new ConcreteProductB();<br>break;<br>default:<br>p= new ConcreteProductA();<br>break;<br>}<br>return p;<br>}<br>Product </em>SimpleFactory::CreateProductA()<br>{<br>return new ConcreteProductA();<br>}<br>Product <em>SimpleFactory::CreateProductB()<br>{<br>return new ConcreteProductB();<br>}<br></em></pre><br><strong>客户端程序</strong>：访问的角色包括产品基类、工厂类。不直接访问具体产品类。通过基类指针的多态实现产品功能的调用。<br><strong>访问描述</strong>：客户程序通过调用工厂的方法返回抽象产品，然后执行产品的方法。<br><pre class="programlisting">//调用代码<br>SimpleFactory sf;<br>Product p = sf.CreateProductA();<br>p-&gt;Function();<br>delete p;<br>p = sf.CreateProductB();<br>p-&gt;Function();<br>delete p;<br></pre><br></div>

<h5 id="优缺点说明"><a href="#优缺点说明" class="headerlink" title="优缺点说明"></a>优缺点说明</h5><p><strong>优点</strong>：1) 首先解决了代码中大量New的问题。为何要解决这个问题，好处的说明我想放到结尾总结中。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;2) 用工厂方法在一个类的内部创建对象通常比直接创建对象更灵活。<br><strong>缺点</strong>：对修改不封闭，新增加产品您要修改工厂。违法了鼎鼎大名的开闭法则（OCP）。</p>
<h5 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h5><ul>
<li>大家可以参看 吕震宇 老师的<a href="http://www.cnblogs.com/zhenyulu/articles/36462.html" target="_blank" rel="noopener">C#设计模式（四）</a>参看这个模式的分析，里面还给出了这个模式的两个变体，实现比较简单，有兴趣的朋友可以自行用C++实现一下。*   产品基类的代码中构造函数我用了Protected，而没有使用Public，主要是为了体现编码中的一个最小权限原则。说明此类不许用户直接实例化。虽然这里使用了virtual void Function() = 0;编译器也会控制不让用户直接实例化，不过我依然认为使用私有化构造函数来保护类不直接实例化是一个良好的编程风格。</li>
</ul>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><h5 id="生活例子-1"><a href="#生活例子-1" class="headerlink" title="生活例子:"></a>生活例子:</h5><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 人是最贪得无厌的动物，老婆手艺再好，总有不会做的菜，你想吃回锅肉，怎么办，让老婆学呗，于是就给她就新增了做回锅肉的方法，以后你再想吃一个新菜，就要给你老婆新加一个方法，显然用老婆做菜的缺点也就暴露出来了，用程序设计的描述就是对修改永远不能封闭。当然优点也是有的，你有了老婆这个工厂，这些菜不用你自己做了，只要直接调用老婆这个工厂的方法就可以了。 </p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;面对上面对修改不能封闭的问题，有没有好的解决方案吗，如果你有钱，问题就迎刃而解了，把老婆抽象变成一个基类，你多娶几个具体的老婆，分别有做鱼的，做青菜的，炖汤的老婆，如果你想吃一个新菜，就再新找个女人，从你的老婆基类继承一下，让她来做这个新菜。显然多多的老婆这是所有男人的梦想，没有办法，法律不允许，那么咱们只是为了做饭，老婆这个抽象类咱们不叫老婆了，叫做厨师吧，她的子类也自然而然的该叫做鱼的厨师、炖汤的厨师了。现在来看这个模式发生了变化，结构中多了一个厨师的抽象，抽象并不具体的加工产品了，至于是炖汤还是炖鱼，是由这个抽象工厂的继承子类来实现，现在的模式也就变成工厂方法模式了，这个上面的结构图1)就变成了下面的图3的结构了。<br><img src="http://images.cnblogs.com/cnblogs_com/Seasky/167561/r_1-4.JPG" alt=""><br>&nbsp; &nbsp; &nbsp;&nbsp; （图3）</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;现在再来分析现在的模式，显然简单工厂的缺陷解决了，新增加一个菜只需要新增加一个厨师就行了，原来的厨师还在做原来的工作，这样你的设计就对修改封闭了。你看把老婆解放出来，招聘大量的厨师到你家里这个方案多么的完美，你老婆也会爱死你了。当然前提就是你要有多多的钱噢，当然这里的钱的多少在软件领域应该看你的客户软件投资方的要求。<br>下面来一下标准的工厂模式的实现 </p>
<h5 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h5><ul>
<li>定义一个用户创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。*   上面是GOF关于此模式的意图描述，我想补充的是您可以这样理解：为了改善简单工厂对修改不能关闭的问题。</li>
</ul>
<h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p>&nbsp; <img src="http://images.cnblogs.com/cnblogs_com/Seasky/167561/r_1-5.JPG" alt=""><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;图4</p>
<h5 id="角色分析-1"><a href="#角色分析-1" class="headerlink" title="角色分析"></a>角色分析</h5><div style="padding-right: 20px; padding-left: 30px; padding-bottom: 10px; padding-top: 0px;"><strong>产品基类</strong>：同简单工厂的产品基类，其实就是用和简单工厂中的是同一个类，这里并没有重写。<br><strong>具体产品类</strong>：也是用的简单工厂的具体产品类，为了体现对修改的关闭这里为系统新添加了一个具体产品类，就是&ldquo;新产品&rdquo;，代码中叫做&ldquo;ConcreteProductANew&rdquo;<br><strong>工厂基类</strong>：定义了工厂创建产品的接口，但是没有实现，具体创建工作由其继承类实现。<br>代码实例<br><br><pre class="programlisting">//工厂模式，此模式的工厂只定义加工产品的接口，具体生成交予其继承类实现<br>//只有具体的继承类才确定要加工何种产品<br>class Factory<br>{<br>public:<br>Factory(void);<br>public:<br>virtual ~Factory(void);<br>public:<br>virtual Product<em> CreateProduct(int ProductType = 0) =0;<br>};<br>//CPP<br>Factory::Factory(void)<br>{<br>}<br>Factory::~Factory(void)<br>{<br>}<br></em></pre><br><strong>具体工厂类</strong>：工厂基类的具体实现，由此类决定创建具体产品，这里 <strong>ConcreteFactory1</strong> 对于与图中的 <strong>工厂实现</strong>，<strong>ConcreteFactory2</strong> 对于与图中的<strong>新工厂</strong>。<br>下面给出实现代码<br><br><pre class="programlisting">//工厂实现<br>class ConcreteFactory1:public Factory<br>{<br>public:<br>ConcreteFactory1();<br>public:<br>virtual ~ConcreteFactory1();<br>public :<br>Product CreateProduct(int ProductType);<br>};<br>//新工厂，当要创建新类是实现此新工厂<br>class ConcreteFactory2:public Factory<br>{<br>public:<br>ConcreteFactory2();<br>public:<br>virtual ~ConcreteFactory2();<br>public :<br>Product<em> CreateProduct(int ProductType);<br>};<br>//CPP<br>ConcreteFactory1::ConcreteFactory1()<br>{<br>}<br>ConcreteFactory1::~ConcreteFactory1()<br>{<br>}<br>Product </em> ConcreteFactory1::CreateProduct(int ProductType = 0)<br>{<br>Product <em>p = 0;<br>switch(ProductType)<br>{<br>case 0:<br>p= new ConcreteProductA();<br>break;<br>case 1:<br>p= new ConcreteProductB();<br>break;<br>default:<br>p= new ConcreteProductA();<br>break;<br>}<br>return p;<br>}<br>ConcreteFactory2::ConcreteFactory2()<br>{<br>}<br>ConcreteFactory2::~ConcreteFactory2()<br>{<br>}<br>Product </em> ConcreteFactory2::CreateProduct(int ProductType = 0)<br>{<br>return new ConcreteProductANew();<br>}<br></pre><br><strong>客户端调用</strong>：访问角色（产品基类、工厂基类、工厂实现类）<br><strong>调用描述</strong>：客户程序通过工厂基类的方法调用工厂实现类用来创建所需要的具体产品。从而实现产品功能的访问。<br>代码实现<br><br><pre class="programlisting">Factory<em>fct = new ConcreteFactory1();<br>Product </em>p = fct-&gt;CreateProduct(0);<br>p-&gt;Function();<br>delete p;<br>p = fct-&gt;CreateProduct(1);<br>p-&gt;Function();<br>delete p;<br>delete fct;<br>fct = new ConcreteFactory2();<br>p=fct-&gt;CreateProduct();<br>delete p;<br>delete fct;<br></pre><br></div>

<h5 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h5><p><strong>优点 </strong></p>
<ul>
<li>简单工厂具有的优点*   解决了简单工厂的修改不能关闭的问题。系统新增产品，新增一个产品工厂即可，对抽象工厂不受影响。</li>
</ul>
<p><strong>缺点</strong>：对于创建不同系列的产品无能为力 </p>
<h5 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h5><ul>
<li>当一个类不知道它所必须创建的对象的类的时候。<em>   当一个类希望由它的子类来指定它所创建的对象的时候。</em>   当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</li>
</ul>
<h5 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h5><ul>
<li>吕震宇的<a href="http://www.cnblogs.com/zhenyulu/articles/36590.html" target="_blank" rel="noopener">C#设计模式（5）－Factory Method Pattern </a></li>
<li>TerryLee 的<a href="http://terrylee.cnblogs.com/archive/2006/01/04/310716.html" target="_blank" rel="noopener">.NET设计模式（5）：工厂方法模式（Factory Method） </a></li>
</ul>
<p>&nbsp;</p>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><h5 id="生活例子-2"><a href="#生活例子-2" class="headerlink" title="生活例子"></a>生活例子</h5><p>&nbsp; &nbsp;&nbsp;&nbsp; 世事多变，随着时间的推移，走过的地方越来越多，你天南海北的朋友也越来越多。你发现菜原来还分了许多菜系，鲁菜、粤菜、湘菜等等，它们各有各的风味，同样是红烧肉由不同菜系出来的味道也各不相同， 你招待不同的朋友要用不同的菜系，这下难办了，你的厨师都是鲁菜风味，怎么办，广东的朋友来了吃不惯。现在我们再回到简单工厂模式（就是老婆做菜的模式），我们把红烧肉再向下继承，生成鲁菜红烧肉、粤菜红烧肉、湘菜红烧肉；清蒸鱼向下继承为鲁菜清蒸鱼、粤菜清蒸鱼、湘菜清蒸鱼，其它也以此类推。我们也修改一下老婆的这个类，不让其返回食物基类，而是返回红烧肉、清蒸鱼、爆炒空心菜、西红柿鸡蛋汤这一层次，并把这些方法抽象化，作为菜系工厂基类，然后再从此基类继承出，鲁菜工厂、粤菜工厂、湘菜工厂等等，再由这些具体工厂实现创建具体菜的工作，哈哈你如果招待广东朋友就用粤菜工厂，返回的就是一桌粤菜菜系的红烧肉、清蒸鱼、空心菜和西红柿鸡蛋汤了，你的广东朋友一定会吃的非常合乎胃口了。噢，非常好，你已经实现了抽象工厂模式了。结构模型图也变成了下图 6)的样子了。<br><img src="http://images.cnblogs.com/cnblogs_com/Seasky/167561/r_1-6.JPG" alt=""><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; （图6）<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 现在可以看到，想新来做一个菜系，只需新聘请一个厨师就可以了，多么完美，但是你先别高兴太早，如果你想新增加一个菜就变得非常困难了。</p>
<h5 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h5><p>&nbsp; &nbsp; &nbsp; &nbsp;提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br><strong>结构</strong><br><img src="http://images.cnblogs.com/cnblogs_com/Seasky/167561/r_1-7.JPG" alt=""></p>
<h5 id="角色分析-2"><a href="#角色分析-2" class="headerlink" title="角色分析"></a>角色分析</h5><div style="padding-right: 20px; padding-left: 30px; padding-bottom: 10px; padding-top: 0px;"><strong>产品基类</strong>：这里包含产品基类A和产品基类B，实际上在我的示例代码中，这两个产品都从共同的基类继承而来，但是这个继承关系却是在这个模式之外的部分，而本身这个模式关心的是这两个产品基类的差异部分。<br>代码实现：这里的代码就是借用的简单工厂模式中具体产品类的代码实现部分，为了大家阅读方便，下面重新给出一下。<br><br><pre class="programlisting">        //产品A<br>class ConcreteProductA:public Product<br>{<br>public:<br>ConcreteProductA(void);<br>public:<br>virtual ~ConcreteProductA(void);<br>public:<br>virtual void Function();<br>};<br>//cpp<br>ConcreteProductA::ConcreteProductA()<br>{<br>cout&lt;&lt;”创建 A 产品”&lt;&lt;endl;<br>}<br>ConcreteProductA::~ConcreteProductA()<br>{<br>cout&lt;&lt;”释放 A 产品”&lt;&lt;endl;<br>}<br>void ConcreteProductA::Function()<br>{<br>cout&lt;&lt;”这是产品 A 具有的基本功能”&lt;&lt;endl;<br>}<br>//产品B与A类似不这里不再给出，大家可以下载源码<br></pre><br><br><strong><br>具体产品</strong>类：这里的具体产品类是产品A1，A2，B1、B2等，<br>代码实现：A1对应的实现就是&ldquo;&rdquo;<br><br><pre class="programlisting">class ConcreteProductA1:public ConcreteProductA<br>{<br>public:<br>ConcreteProductA1(void);<br>public:<br>virtual ~ConcreteProductA1(void);<br>public:<br>virtual void Function();<br>};<br>//CPP<br>ConcreteProductA1::ConcreteProductA1()<br>{<br>cout&lt;&lt;”创建 A1 产品”&lt;&lt;endl;<br>}<br>ConcreteProductA1::~ConcreteProductA1()<br>{<br>cout&lt;&lt;”释放 A1 产品”&lt;&lt;endl;<br>}<br>void ConcreteProductA1::Function()<br>{<br>cout&lt;&lt;”这时产品 A1 具有的基本功能”&lt;&lt;endl;<br>}<br></pre><br><br><strong>工厂抽象</strong>接口：定义了创建产品的接口，这里返回参数是返回的产品A，产品B，而本身产品A和B的共同基类，小弟认为正是这个特征构成了抽象工厂和工厂模式的区别。<br>代码实现<br><br><pre class="programlisting">//抽象工厂模式<br>class AbstractFactory<br>{<br>public:<br>AbstractFactory();<br>public:<br>virtual ~AbstractFactory();<br>public:<br>virtual ConcreteProductA<em> CreateA() = 0;<br>virtual ConcreteProductB</em> CreateB() = 0;<br>};<br>//CPP<br>AbstractFactory::AbstractFactory()<br>{<br>}<br>AbstractFactory::~AbstractFactory()<br>{<br>}<br></pre><br><br>具体工厂实现类：工厂1和工厂2。新增加系列，只需新实现一个工厂。<br>代码实现: 工厂1的就是ConcreteAbsFactory1，工厂2的代码类似，这里没有给出，可以在下载代码中看到<br><br><pre class="programlisting">////工厂1—–<br>class ConcreteAbsFactory1:public AbstractFactory<br>{<br>public:<br>ConcreteAbsFactory1();<br>public:<br>virtual ~ConcreteAbsFactory1();<br>public:<br>virtual ConcreteProductA<em> CreateA();<br>virtual ConcreteProductB</em> CreateB();<br>};<br>//CPP<br>ConcreteAbsFactory1::ConcreteAbsFactory1()<br>{<br>}<br>ConcreteAbsFactory1::~ConcreteAbsFactory1()<br>{<br>}<br>ConcreteProductA<em> ConcreteAbsFactory1::CreateA()<br>{<br>return new ConcreteProductA1();<br>}<br>ConcreteProductB </em> ConcreteAbsFactory1::CreateB()<br>{<br>return new ConcreteProductB1();<br>}<br></pre><br><br>客户端访问： 访问角色（产品基类、抽象工厂、具体工厂实现类）<br>访问描述： 通过抽象工厂的指针访问具体工厂实现来创建对应系列的产品，然后通过产品基类指针访问产品功能。<br>调用代码：<br><br><pre class="programlisting">          AbstractFactory <em>absfct = new ConcreteAbsFactory1();<br>ConcreteProductA </em>cpa = absfct-&gt;CreateA();<br>cpa-&gt;Function();<br>delete cpa;<br>ConcreteProductB *cpb = absfct-&gt;CreateB();<br>cpb-&gt;Function();<br>delete cpb;<br>delete absfct;<br>absfct = new ConcreteAbsFactory2();<br>cpa = absfct-&gt;CreateA();<br>cpa-&gt;Function();<br>delete cpa;<br>cpb = absfct-&gt;CreateB();<br>cpb-&gt;Function();<br>delete cpb;<br></pre><br></div>

<p>&nbsp;</p>
<h5 id="和工厂模式的分析比较"><a href="#和工厂模式的分析比较" class="headerlink" title="和工厂模式的分析比较"></a>和工厂模式的分析比较</h5><p>&nbsp; &nbsp; &nbsp;&nbsp; 现在可以和工厂模式对比一下，抽象工厂返回的接口不再是产品A和产品B的共同基类Product了，而是产品A、产品B基类（在工厂模式中它们为具体实现类，这里变成了基类）了。此时工厂的抽象和简单工厂中的工厂方法也很类似，就是这些特征区使其别于工厂模式而变成抽象工厂模式了，因此抽象工厂解决的是创建一系列有共同风格的产品（鲁菜还是粤菜），而工厂方法模式解决的创建有共同特征的一系列产品（红烧肉、清蒸鱼它们都是食物）。当然简单工厂的缺陷在抽象工厂中又再次出现了，我要新增加一个产品，工厂抽象接口就要改变了。因此抽象工厂并不比工厂模式完美，只不过是各自的适用领域不同而已。其实，这里如果把抽象工厂模式的接口返回产品A和产品B的共同基类（工厂模式返回的参数），你会发现，奇怪这个模式怎么这么眼熟，它不是恰恰退化成工厂模式了。<br>&nbsp; &nbsp; &nbsp; &nbsp;类模式与对象模式的区别讨论：先看定义类&ldquo;模式使用继承关系，把对象的创建延迟的子类，对象模式把对象的创建延迟到另一个对象中&rdquo;。 分析：首先它们创建对象都不是在基类中完成，都是在子类中实现，因此都符合类模式的概念；但是工厂模式的创建产品对象是在编译期决定的，要调用某个工厂固定的，而抽象工厂模式对产品的创建是在运行时动态决定的，只有到运行时才确定要调用那个工厂，调用工厂随运行环境而改变。（这里我一直很混乱，欢迎大家讨论）</p>
<h5 id="适用性-1"><a href="#适用性-1" class="headerlink" title="适用性"></a>适用性</h5><ul>
<li>一个系统要独立于它的产品的创建、组合和表示时<em>   一个系统要由多个 产品系列中的一个来配置时</em>   当你要强调一个系列相关的产品对象的设计以便进行联合使用时*   当你提供一个产品类库，而只想显示它们的接口而不是实现时。</li>
</ul>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ul>
<li>吕震宇的<a href="http://www.cnblogs.com/zhenyulu/articles/36885.html" target="_blank" rel="noopener">C#设计模式（6）</a>*   TerryLee 的<a href="http://terrylee.cnblogs.com/archive/2005/12/13/295965.html" target="_blank" rel="noopener">.NET设计模式（3）：抽象工厂模式（Abstract Factory）</a></li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;工厂本质就是用工厂方法替代直接New来创建对象。这里不是指的让用户重载一个新操作符号来进行创建对象的操作，而是说把New 操作封装在一个方法中，等用户需要创建对象时调用此方法而避免直接使用New而已。这样做的目的就是之一就是封装，避免代码中大量New的运算符，这当然不是主要目的，因为这样虽然New少了，CreateObject方法却多了，但是如果产品类的构造函数变了，我想常用工厂模式的修改源代码的工作应该简便许多吧，当然这算不上这个模式的好处，它的真正强大的功能其实在于适应变化，这也是整个设计模式最根本的目的；还有一点就是体现了抽象于实现的分离，当然创建型模式都具有这个特点，工厂模式非常明显吧了，把具体创建工作放置到工厂中，使客户端程序更专注与业务逻辑的，这样的代码结构也更进行合理。</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">billowqiu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">155</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/billowqiu" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:billowqiu@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">billowqiu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
