<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="taocoding">
<meta property="og:url" content="http://yoursite.com/page/9/index.html">
<meta property="og:site_name" content="taocoding">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="taocoding">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/9/">





  <title>taocoding</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d13234060d812cb98a47e937139083a9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">taocoding</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/10/11/clearcase一点心得/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/10/11/clearcase一点心得/" itemprop="url">ClearCase一点心得</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-10-11T19:38:00+08:00">
                2009-10-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/软件工程/" itemprop="url" rel="index">
                    <span itemprop="name">软件工程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&nbsp;&nbsp;&nbsp; 使用这个工具快一年了，个人感觉是非常强大的，不知道还有没有更强大的，没怎么用过SVN之类的，以后有时间也多试试。</p>
<p>最近在一次误装VS SP后，导致CC与VS关联失效，但是当时也没意识到是什么导致的，以为是和服务器连接的问题，又把管理员搞来了，他看了半天也不知道是什么问题，结果又是我想起了由于装SP导致的，(其实之前也因为自己的一次恶搞导致CC比较工具出现问题，那次也是让管理员搞的，当时只记得是换了个比较工具，当时也是自己没想出是什么原因导致的，结果他过来也不知道是什么原因，尴尬之下又是我想起了自己的恶搞，哎每次都是别人到现场才想出来，看来自己独立思索的能力还得加强)。之后管理员说让我重装，我当时觉得这个太麻烦了，而且说不定View之类还得重建(理论上应该可以不用重建，但是想着就麻烦)，后来他又说有个什么教程写不用重装，搞得很牛X的说等会让我拷贝一份，结果打开一看根本就是牛头不对马嘴，别人讲的是VSS和VS的关联，我估计他自己都没看过这”教程”，或者是看了也不&nbsp; 懂。&nbsp;&nbsp;&nbsp; </p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 到了这份上我也不好再打找他来了，毕竟办公室还有那么多人，影响别人也不好，网上搜了半天也无果，不知道是什么激发了自己的灵感想到这类软件一般都是在安装过程中关联的，那么弄个修复安装不就OK了，于是关掉所有VS，找到相关程序，确实有个修复安装选项，点击，打开VS，O(&cap;_&cap;)O哈哈~，搞定了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是当我更新程序后习惯性的Compare有改动的文件时，再次出现比较工具提示找不到路径，没办法只得硬着头皮找了，只怪自己上次没看他弄的啥比较工具，拿同事电脑上共享的CC文件夹比较，替换还是不行，这次网络算是帮了个大忙，具体步骤就不说了，看下面的链接</p>
<p><a href="http://www-01.ibm.com/support/docview.wss?rs=984&amp;uid=swg21256807" target="_blank" rel="noopener">http://www-01.ibm.com/support/docview.wss?rs=984&amp;uid=swg21256807</a></p>
<p>其中这个KDiff3比自带的那个强大而且开源，也可以单独使用相当不错。</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/10/07/社会保障卡/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/10/07/社会保障卡/" itemprop="url">社会保障卡</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-10-07T19:45:00+08:00">
                2009-10-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/生活轨迹/" itemprop="url" rel="index">
                    <span itemprop="name">生活轨迹</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 社会保障卡是由劳动和社会保障部统一规划，由各地劳动保障部门面向社会发行，应用于劳动和社会保障各项业务领域的集成电路卡（IC卡）。其中，面向城镇从业人员、失业人员和离退休人员发放的称为社会保障（个人）卡，面向用人单位发放的称为社会保障（用人单位）卡。由于社会保障（个人）卡是目前劳动保障部有关卡规划和规范的重点，各地实际发放的也多集中于这一种卡，所以通常我们所说的社会保障卡，就是指社会保障（个人）卡。</p>
<p>　　社会保障卡卡面和卡内均记载持卡人姓名、性别、公民身份号码等基本信息，卡内标识了持卡人的个人状态（就业、失业、退休、失业等），可以记录持卡人社会保险缴费情况、养老保险个人账户信息、医疗保险个人账户信息、职业资格和技能、就业经历、工伤及职业病伤残程度等。社会保障卡是劳动者在劳动保障领域办事的电子凭证。持卡人可以凭卡就医，进行医疗保险个人账户结算；可以凭卡办理养老保险事务；可以凭卡到相关部门办理求职登记和失业登记手续，申领失业保险金，申请参加就业培训；可以凭卡申请劳动能力鉴定和申领享受工伤保险待遇等。此外，社会保障卡还是握在劳动者手中开启与系统联络之门的钥匙，凭借这把钥匙，持卡人可以上网查询信息，将来还可以在网上办理有关劳动和社会保障事务。</p>
<p>　　社会保障卡的全称是&ldquo;中华人民共和国社会保障卡&rdquo;。从这一名称的含义上讲，发放的对象是政府有关部门实施社会保障的人群；从其内容上讲，可以涉及有关个人社会保障的方方面面，既包括社会保险，也包括就业服务，一些地区的地方政府根据当地的管理需要，还将更多的社会管理事务也放入其中；从其涉及的地域上讲，这是全国范围内可以使用的IC卡，可以适应全国统一劳动力市场和社会保障系统联网的需要，适应人员流动的需求。</p>
<p>　　要正确理解社会保障卡这一概念，还必须清楚社会保障卡与其他行业性IC卡，特别是同银行卡的关系。由于社会保障卡上存有的供持卡人在医院就医结算的&ldquo;个人账户&rdquo;，类似于银行卡的&ldquo;电子钱包&rdquo;，一些地区或厂商便采用银行卡的标准来设计社会保障卡。银行卡标准是针对银行卡应用而制订的规范，其文件存储格式、指令操作、安全管理等方面都是针对与金融有关的各种交易行为设计的。而劳动保障领域发放的IC卡主要是用于行政管理，其主要功能是对信息记录进行管理，与银行卡的功能有很大不同。社会保障卡中的&ldquo;医疗保险个人账户&rdquo;也同银行卡中的&ldquo;电子钱包&rdquo;有本质的区别，它记载的是个人账户中&ldquo;帐&rdquo;的情况，而不是真正的&ldquo;钱&rdquo;。持卡人将个人账户余额划到卡中之后，医疗保险机构仍然要对账户的使用负责，即使持卡人的卡丢失、损坏，只要挂失前个人账户上的资金未被他人冒用，便仍旧归持卡人所有，仍可以使用这部分账户进行医疗消费。而银行卡中的电子钱包一旦用户将钱圈存到卡中，这笔钱便同银行无任何关系，一旦卡丢失、损坏，其损失完全由持卡人承担。因此，医疗保险个人账户绝不能采用电子钱包的模式进行处理。还有些地方将社会保障应用和金融应用放到一张卡上，对此，是不提倡的，因为将商业性应用和管理性应用集于一卡，在管理上会造成许多弊端，会给持卡人和管理机构带来许多不便，甚至给持卡人造成损失。</p>
<p>&nbsp;</p>
<p>原文链接:<a href="http://www.gov.cn/banshi/2005-07/18/content_15856.htm" target="_blank" rel="noopener">http://www.gov.cn/banshi/2005-07/18/content_15856.htm</a></p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/09/26/vs2005向导生成的win32程序编译gdi问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/09/26/vs2005向导生成的win32程序编译gdi问题/" itemprop="url">VS2005向导生成的win32程序编译GDI+问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-09-26T13:59:00+08:00">
                2009-09-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>昨天用VS2005向导生成的Win32程序，当向其中添加GDI+相关文件引用时会提示如下错误</p>
<p>&nbsp;</p>
<p>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(67) : error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(67) : error C2440: &ldquo;初始化&rdquo;: 无法从&ldquo;const char [37]&rdquo;转换为&ldquo;int&rdquo;<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 没有使该转换得以执行的上下文<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(67) : error C2146: 语法错误 : 缺少&ldquo;;&rdquo;(在标识符&ldquo;IImageBytes&rdquo;的前面)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(67) : error C2470: &ldquo;IImageBytes&rdquo;: 看起来像函数定义，但没有参数列表；跳过明显的函数体<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(67) : error C2059: 语法错误 : &ldquo;public&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(246) : error C2146: 语法错误 : 缺少&ldquo;;&rdquo;(在标识符&ldquo;id&rdquo;的前面)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(246) : error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusimaging.h(246) : error C4430: 缺少类型说明符 - 假定为 int。注意: C++ 不支持默认 int<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(384) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(395) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(405) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(443) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(444) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(445) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(453) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(465) : error C2535: &ldquo;Gdiplus::Image::Image(void)&rdquo;: 已经定义或声明成员函数<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(384) : 参见&ldquo;Gdiplus::Image::Image&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(499) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusheaders.h(510) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1133) : error C2065: &ldquo;IStream&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1133) : error C2065: &ldquo;stream&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1133) : error C2065: &ldquo;image&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1133) : error C2275: &ldquo;Gdiplus::GpImage&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusgpstubs.h(61) : 参见&ldquo;Gdiplus::GpImage&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1133) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1133) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1139) : error C2275: &ldquo;Gdiplus::GpImage&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusgpstubs.h(61) : 参见&ldquo;Gdiplus::GpImage&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1139) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1139) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1156) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1244) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1247) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1250) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1262) : error C2061: 语法错误 : 标识符&ldquo;PROPID&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1275) : error C2065: &ldquo;bitmap&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1275) : error C2275: &ldquo;Gdiplus::GpBitmap&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusgpstubs.h(62) : 参见&ldquo;Gdiplus::GpBitmap&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1275) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1275) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1281) : error C2275: &ldquo;Gdiplus::GpBitmap&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusgpstubs.h(62) : 参见&ldquo;Gdiplus::GpBitmap&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1281) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(1281) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2128) : error C2065: &ldquo;header&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2128) : error C2275: &ldquo;Gdiplus::MetafileHeader&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetaheader.h(112) : 参见&ldquo;Gdiplus::MetafileHeader&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2128) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2128) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2146) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2166) : error C2065: &ldquo;metafile&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2166) : error C2275: &ldquo;Gdiplus::GpMetafile&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusgpstubs.h(63) : 参见&ldquo;Gdiplus::GpMetafile&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2166) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2166) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2213) : error C2275: &ldquo;HDC&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/windef.h(260) : 参见&ldquo;HDC&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2213) : error C2146: 语法错误 : 缺少&ldquo;)&rdquo;(在标识符&ldquo;referenceHdc&rdquo;的前面)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2213) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2213) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2213) : error C2275: &ldquo;HDC&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/windef.h(260) : 参见&ldquo;HDC&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2219) : error C2059: 语法错误 : &ldquo;)&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2224) : error C2275: &ldquo;HDC&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/windef.h(260) : 参见&ldquo;HDC&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2224) : error C2146: 语法错误 : 缺少&ldquo;)&rdquo;(在标识符&ldquo;referenceHdc&rdquo;的前面)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2224) : warning C4229: 使用了记时错误 : 忽略数据上的修饰符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2224) : error C2078: 初始值设定项太多<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2224) : error C2275: &ldquo;HDC&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/windef.h(260) : 参见&ldquo;HDC&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusflat.h(2230) : error C2059: 语法错误 : &ldquo;)&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdipluspath.h(133) : error C2061: 语法错误 : 标识符&ldquo;byte&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(80) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(197) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(197) : error C2535: &ldquo;Gdiplus::Metafile::Metafile(void)&rdquo;: 已经定义或声明成员函数<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(80) : 参见&ldquo;Gdiplus::Metafile::Metafile&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(213) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(213) : error C2535: &ldquo;Gdiplus::Metafile::Metafile(void)&rdquo;: 已经定义或声明成员函数<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(80) : 参见&ldquo;Gdiplus::Metafile::Metafile&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(231) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(231) : error C2535: &ldquo;Gdiplus::Metafile::Metafile(void)&rdquo;: 已经定义或声明成员函数<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(80) : 参见&ldquo;Gdiplus::Metafile::Metafile&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(277) : error C2061: 语法错误 : 标识符&ldquo;IStream&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(370) : error C2535: &ldquo;Gdiplus::Metafile::Metafile(void)&rdquo;: 已经定义或声明成员函数<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(80) : 参见&ldquo;Gdiplus::Metafile::Metafile&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(207) : error C2065: &ldquo;referenceHdc&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(207) : error C2065: &ldquo;type&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(208) : error C2065: &ldquo;description&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(225) : error C2065: &ldquo;frameRect&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusmetafile.h(225) : error C2065: &ldquo;frameUnit&rdquo;: 未声明的标识符<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(45) : error C2275: &ldquo;BOOL&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/windef.h(152) : 参见&ldquo;BOOL&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(45) : error C2146: 语法错误 : 缺少&ldquo;)&rdquo;(在标识符&ldquo;useEmbeddedColorManagement&rdquo;的前面)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(45) : error C2761: &ldquo;{ctor}&rdquo;: 不允许成员函数重新声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(45) : error C2059: 语法错误 : &ldquo;)&rdquo;<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(46) : error C2143: 语法错误 : 缺少&ldquo;;&rdquo;(在&ldquo;{&rdquo;的前面)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(46) : error C2447: &ldquo;{&rdquo;: 缺少函数标题(是否是老式的形式表?)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(80) : error C2275: &ldquo;BOOL&rdquo;: 将此类型用作表达式非法<br>1&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; f:/microsoft visual studio 8/vc/platformsdk/include/windef.h(152) : 参见&ldquo;BOOL&rdquo;的声明<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(80) : error C2146: 语法错误 : 缺少&ldquo;)&rdquo;(在标识符&ldquo;useEmbeddedColorManagement&rdquo;的前面)<br>1&gt;f:/microsoft visual studio 8/vc/platformsdk/include/gdiplusbitmap.h(80) : error C2761: &ldquo;Gdiplus::Image *Gdiplus::Image::FromStream(void)&rdquo;: 不允许成员函数重新声明</p>
<p>&nbsp;</p>
<p>但是自己新建一个空工程然后添加相关的文件就没问题，找了半天猜猜可能是StdAfx里面的宏有问题，试了几下发现然来是</p>
<p>#define WIN32_LEAN_AND_MEAN&nbsp;&nbsp;// 从 Windows 头中排除极少使用的资料</p>
<p>这个定义导致的，去掉就OK了，没想到M$自己的东西都这样。</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/09/05/socket基础知识/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/09/05/socket基础知识/" itemprop="url">socket基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-09-05T17:52:00+08:00">
                2009-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/系统编程/" itemprop="url" rel="index">
                    <span itemprop="name">系统编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 如果一个socket成功创建了，它存在于一个地址一个地址家族(socket函数的第一个参数即为地址家族)，为什么要提供这个参数呢，因为Windows Sockets提供了一个与协议无关的编程接口，使得开发人员可以开发直接使用任何一种协议的网络程序。尽管如此，要实现网络通信定位和网络连接，为主机定址是必须得，bind函数就是干这个的。</span><span style="font-size: x-small;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 另外在调用send/sendto时如果这是一个未绑定的socket，那么Windows Sockets会执行一个隐式的bind调用，系统会给其分配一个唯一值，并标记为绑定状态，可以通过getsockname 获取相关scoket name。因此在bind之前没有send/sendto之类操作，那么调用recv/recvfrom会得到10022的错误代码，即&ldquo;提供了一个无效的参数&rdquo;，也就是在socket没有绑定一个ip/port之前是不能接受数据的，联想到我们一般的C/S模式，S端都会先bind到一个ip/port，因为S是服务提供者，他不会主动发送数据，而是等待C来要求服务也就是发送数据，所以我们一般在C端不需要显示调用bind而是当send/sendto之类函数调用时，由系统绑定一个唯一的ip/port。对于S端我们一般都是指定一个固定的ip/port，而C端，MSDN上面的建议是最好让系统自动分配一个，可以在调用bind的时候可以将port设为0以免发生冲突。</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/09/01/调试mfc源代码/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/09/01/调试mfc源代码/" itemprop="url">调试MFC源代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-09-01T08:19:00+08:00">
                2009-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>将C:/WINDOWS/system32下面的MFCXXXX.PDB拷贝到程序所在目录即可，以后就不会出现MFC42D.dll之类的Call Stack了，调试Modal对话框问题中偶然意识到的。</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/08/25/返回值为引用的一点测试/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/08/25/返回值为引用的一点测试/" itemprop="url">返回值为引用的一点测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-08-25T22:10:00+08:00">
                2009-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近做多人视频时设计了一个简单的类，但是简单的类也很能说明问题，也再次说明有些基础知识还是理解得不够深刻，刚写了个测试程序以便日后查阅，主要是关于返回值为引用类型时的一点测试:</p>
<pre style="border: 1px dotted #785;background: #f5f5f5;">#include &lt;iostream&gt;
using namespace std;

class CConstRef
{
public:
CConstRef(int iA):m_iA(iA)
{
}
const int&amp; GetA()const
{
return m_iA;
}
int&amp; GetA()
{
return m_iA;
}
void PrintAddress()const
{
cout&lt;&lt;"Address of m_iA = "&lt;&lt;&amp;m_iA&lt;&lt;endl;
}
private:
int m_iA;
};

int main(int argc, char* argv[])
{
//常量对象
const CConstRef cCA(8);
//非常量对象
CConstRef CA(9);
//////////////////////////////////////////////////////////////////////////
//注意下面的调用都是返回对象cCA的成员m_iA的引用,且此引用都是用来初始化另一引用
//因此地址都相同
//调用int&amp; GetA()
int&amp; ra = CA.GetA();
CA.PrintAddress();
cout&lt;&lt;"Address of ra = "&lt;&lt;&amp;ra&lt;&lt;endl;
ra = 3;
cout&lt;&lt;"Now the CA.m_iA = "&lt;&lt;CA.GetA()&lt;&lt;endl;

//调用int&amp; GetA()
const int&amp; ra1 = CA.GetA();
cout&lt;&lt;"Address of ra1 = "&lt;&lt;&amp;ra1&lt;&lt;endl;
//////////////////////////////////////////////////////////////////////////
//调用int&amp; GetA()
int va = CA.GetA();
CA.PrintAddress();
cout&lt;&lt;"Address of va = "&lt;&lt;&amp;va&lt;&lt;endl;
va = 3;
cout&lt;&lt;"Now the CA.m_iA = "&lt;&lt;CA.GetA()&lt;&lt;endl;

//调用int&amp; GetA()
const int va1 = CA.GetA();
cout&lt;&lt;"Address of va1 = "&lt;&lt;&amp;va1&lt;&lt;endl;
//////////////////////////////////////////////////////////////////////////
//下面的rb就是cCA.m_iA
const int&amp; rb = cCA.GetA();

cCA.PrintAddress();
cout&lt;&lt;"Address of rb = "&lt;&lt;&amp;rb&lt;&lt;endl;

/*
error: invalid initialization of reference of type 'int&amp;' from expression of type 'const int'
上面的错误时G++提示的，这么说来其实编译器给我们返回的是const int而不是const int&amp;
*/
// int&amp; rb1 = cCA.GetA();

//下面的的vb和vb1都是是cCA.m_iA的一个副本
const int vb = cCA.GetA();
cout&lt;&lt;"Address of vb = "&lt;&lt;&amp;vb&lt;&lt;endl;

int vb1 = cCA.GetA();
cout&lt;&lt;"Address of vb1 = "&lt;&lt;&amp;vb1&lt;&lt;endl;
vb1 = 10;

cout&lt;&lt;"Now the cCA.m_iA = "&lt;&lt;cCA.GetA()&lt;&lt;endl;

return 0;
}
</pre> 

<p>下面是在MinGW的G++下输出的结果</p>
<p><img src="http://p.blog.csdn.net/images/p_blog_csdn_net/ToCpp/EntryImages/20090825/Result.PNG" alt="返回引用" title="返回引用"></p>
<p>&nbsp;</p>
<blockquote>
<p>&nbsp;</p>
<p><span style="background-color: #ff0000;"><span style="color: #00ff00;"><span style="background-color: #ffffff;"><strong>路路漫漫其修远兮，吾将上下而求索！</strong></span></span></span><br></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/07/21/c设计模式之一-工厂模式（简单工厂、工厂和抽象/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/07/21/c设计模式之一-工厂模式（简单工厂、工厂和抽象/" itemprop="url">C++设计模式之一 工厂模式（简单工厂、工厂和抽象工厂）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-07-21T23:34:00+08:00">
                2009-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/设计模式/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文地址：<a href="http://www.cnblogs.com/Seasky/archive/2009/02/06/1385609.html" target="_blank" rel="noopener">http://www.cnblogs.com/Seasky/archive/2009/02/06/1385609.html</a></p>
<p><a href="http://files.cnblogs.com/Seasky/FactoryPattern.7z" title="工厂模式实例代码" target="_blank" rel="noopener">实例代码下载</a>&nbsp;<br><a href="http://files.cnblogs.com/Seasky/FactoryPatternChart.zip" title="结构图下载" target="_blank" rel="noopener">结构类图下载</a>&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp; 今天开始这个系列之前，心里有些恐慌，毕竟园子里的高手关于设计模式的经典文章很多很多，特别是大侠<a href="http://terrylee.cnblogs.com/" target="_blank" rel="noopener">李会军</a>、<a href="http://zhenyulu.cnblogs.com/" target="_blank" rel="noopener">吕震宇</a> 老师的文章更是堪称经典。他们的文笔如行云流水，例子活泼生动，讲解深入浅出。好在他们都是用C#描述，也没有提供必要的源码下载，所以我这里用C++实现。首先我想声明的是我的文笔绝对不如他们的好，例子也没有他们的形象，不过我打算把C++的代码实现和类图提供给大家，就算作为一种补充吧。</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp; 开始设计模式自然而然到提到几个原则：I、开闭法则（OCP）；II、里氏代换法则（LSP）；III、依赖倒置法则(DIP)；IV、接口隔离法则（ISP）；V、合成/聚合复用原则（CARP）；VI、迪米特法则（LoD），这几个法则在<a href="http://zhenyulu.cnblogs.com/" target="_blank" rel="noopener">吕震宇</a> 老师的<a href="http://www.cnblogs.com/zhenyulu/articles/36061.html" target="_blank" rel="noopener">设计模式（二）</a>和<a href="http://www.cnblogs.com/zhenyulu/articles/36068.html" target="_blank" rel="noopener">设计模式（三）</a>中有非常详尽的阐述和深入浅出的举例分析。有兴趣的朋友打开链接看一下就可以了。</p>
<p>&nbsp; &nbsp; &nbsp; 补充说明：</p>
<ul>
<li>我这里所以代码都是用VS2005的C++编译器实现。所以不能保证在其他IDE中能顺利编译，但是我想如果你使用其他编译器，也应该不会有太大问题，主要也应该是stdafx.h文件中包含的头文件问题。<em>   里面出行的结构图都是用微软的Visio2003 绘制，大家下载后可以直接用Visio打开。</em>   在以后所有的模式例子中都有客户程序，客户程序这个角色不是模式本身的内容，它是模式之外的部分，但是正是这个客户程序完成了对模式的使用，模式本身的结构是讲解的重点，但是客户程序如何使用模式也是理解模式的一个重要方面，因此在我后续的介绍中都有客户程序这个角色，并会说明究竟调用模式中的哪些角色完成对模式的使用。</li>
</ul>
<h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><h5 id="生活例子"><a href="#生活例子" class="headerlink" title="生活例子"></a>生活例子</h5><p>&nbsp; &nbsp; &nbsp; 吃饭是人的基本需求，如果人类不需要吃饭，可能我们就能活得清闲许多，也就不需要像现在一样没日没夜的工作，学习。我们学习是为了找到更好的工作，好工作为了赚更多的钱，最终为了吃饱饭，吃好饭。因此可以说吃饭是与人息息相关，下面就从吃饭的例子来引入工厂模式的学习。</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 如果你想吃饭了，怎么办自己做吗？自己做就相当于程序中直接使用new。当然是自己下个指令，别人来做更爽。那就把做饭的任务交给你的老婆吧，那么她就是一个做饭的工厂了，你告诉她要要吃红烧肉，等会她就从厨房给你端出来一盘香喷喷的红烧肉了，再来个清蒸鱼吧，大鱼大肉不能太多，那就再来个爆炒空心菜，最后再来个西红柿鸡蛋汤。下图 1) 就是这个问题的模型。<br><img src="http://images.cnblogs.com/cnblogs_com/Seasky/167561/r_1-2.JPG" alt="">&nbsp;<br>（图1）<br>&nbsp; &nbsp; &nbsp; &nbsp;显然到了这里，你是Client，你老婆就是工厂，她拥有做红烧肉的方法，做清蒸鱼的方法，做爆炒空心菜、西红柿鸡蛋汤的方法，这些方法返回值就是食物抽象。红烧肉、清蒸鱼、爆炒空心菜、西红柿鸡蛋汤就是食物的继承类，到这里你就可以大吃二喝了。简单工厂模式也成型了。哈哈，娶一个手艺不错的老婆还真好，吃的好，吃的爽，又清闲。</p>
<p>&nbsp; &nbsp; &nbsp;&nbsp; 下面来看标准的简单工厂模式的分析。&nbsp;</p>
<h5 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h5><p>把一系列拥有共同特征的产品的创建封装 </p>
<h5 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h5><p><img src="http://images.cnblogs.com/cnblogs_com/Seasky/167561/r_1-3.JPG" alt="">&nbsp;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; （图2）</p>
<h5 id="角色分析"><a href="#角色分析" class="headerlink" title="角色分析"></a>角色分析</h5><div style="padding-right: 20px; padding-left: 30px; padding-bottom: 10px; padding-top: 0px;"><strong>产品基类</strong>： 工厂创建的所有产品的基类, 它负责描述所有实例所共有的公共接口。它用来作为工厂方法的返回参数。<br>代码实现：<br><pre class="programlisting">        //—这时一个系列的产品基类<br>class Product<br>{<br>protected:<br>Product(void);<br>public:<br>virtual ~Product(void);<br>public:<br>virtual void Function() = 0;<br>};<br>//cpp<br>Product::Product(void)<br>{<br>}<br>Product::~Product(void)<br>{<br>}<br></pre><br><strong>具体产品类</strong>：产品1和产品2，这个角色实现了抽象产品角色所定义的接口。<br>代码实现：<br><pre class="programlisting">        //产品A<br>class ConcreteProductA:public Product<br>{<br>public:<br>ConcreteProductA(void);<br>public:<br>virtual ~ConcreteProductA(void);<br>public:<br>virtual void Function();<br>};<br>//cpp<br>ConcreteProductA::ConcreteProductA()<br>{<br>cout&lt;&lt;”创建 A 产品”&lt;&lt;endl;<br>}<br>ConcreteProductA::~ConcreteProductA()<br>{<br>cout&lt;&lt;”释放 A 产品”&lt;&lt;endl;<br>}<br>void ConcreteProductA::Function()<br>{<br>cout&lt;&lt;”这是产品 A 具有的基本功能”&lt;&lt;endl;<br>}<br>//产品B与A类似不这里不再给出，大家可以下载源码<br></pre><br><br><strong>工厂类</strong>：负责具体产品的创建，有两种方式实现产品的创建，I、创建不同的产品用不同的方法；II、创建不同产品用相同的方法，然后通过传递参数实现不同产品的创建。本实例中两种模式都给出了，大家自行分析。<br><br><pre class="programlisting">//简单工厂，此类不需要继承，直接硬编码实现生成的产品<br>class SimpleFactory<br>{<br>public:<br>SimpleFactory(){}<br>public:<br>~SimpleFactory(){}<br>public:<br>Product <em>CreateProduct(int ProuctType);<br>Product </em>CreateProductA();<br>Product <em>CreateProductB();<br>};<br>//CPP<br>Product </em> SimpleFactory::CreateProduct(int ProductType=0)<br>{<br>Product <em>p = 0;<br>switch(ProductType)<br>{<br>case 0:<br>p= new ConcreteProductA();<br>break;<br>case 1:<br>p= new ConcreteProductB();<br>break;<br>default:<br>p= new ConcreteProductA();<br>break;<br>}<br>return p;<br>}<br>Product </em>SimpleFactory::CreateProductA()<br>{<br>return new ConcreteProductA();<br>}<br>Product <em>SimpleFactory::CreateProductB()<br>{<br>return new ConcreteProductB();<br>}<br></em></pre><br><strong>客户端程序</strong>：访问的角色包括产品基类、工厂类。不直接访问具体产品类。通过基类指针的多态实现产品功能的调用。<br><strong>访问描述</strong>：客户程序通过调用工厂的方法返回抽象产品，然后执行产品的方法。<br><pre class="programlisting">//调用代码<br>SimpleFactory sf;<br>Product p = sf.CreateProductA();<br>p-&gt;Function();<br>delete p;<br>p = sf.CreateProductB();<br>p-&gt;Function();<br>delete p;<br></pre><br></div>

<h5 id="优缺点说明"><a href="#优缺点说明" class="headerlink" title="优缺点说明"></a>优缺点说明</h5><p><strong>优点</strong>：1) 首先解决了代码中大量New的问题。为何要解决这个问题，好处的说明我想放到结尾总结中。<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;2) 用工厂方法在一个类的内部创建对象通常比直接创建对象更灵活。<br><strong>缺点</strong>：对修改不封闭，新增加产品您要修改工厂。违法了鼎鼎大名的开闭法则（OCP）。</p>
<h5 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h5><ul>
<li>大家可以参看 吕震宇 老师的<a href="http://www.cnblogs.com/zhenyulu/articles/36462.html" target="_blank" rel="noopener">C#设计模式（四）</a>参看这个模式的分析，里面还给出了这个模式的两个变体，实现比较简单，有兴趣的朋友可以自行用C++实现一下。*   产品基类的代码中构造函数我用了Protected，而没有使用Public，主要是为了体现编码中的一个最小权限原则。说明此类不许用户直接实例化。虽然这里使用了virtual void Function() = 0;编译器也会控制不让用户直接实例化，不过我依然认为使用私有化构造函数来保护类不直接实例化是一个良好的编程风格。</li>
</ul>
<h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><h5 id="生活例子-1"><a href="#生活例子-1" class="headerlink" title="生活例子:"></a>生活例子:</h5><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp; 人是最贪得无厌的动物，老婆手艺再好，总有不会做的菜，你想吃回锅肉，怎么办，让老婆学呗，于是就给她就新增了做回锅肉的方法，以后你再想吃一个新菜，就要给你老婆新加一个方法，显然用老婆做菜的缺点也就暴露出来了，用程序设计的描述就是对修改永远不能封闭。当然优点也是有的，你有了老婆这个工厂，这些菜不用你自己做了，只要直接调用老婆这个工厂的方法就可以了。 </p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;面对上面对修改不能封闭的问题，有没有好的解决方案吗，如果你有钱，问题就迎刃而解了，把老婆抽象变成一个基类，你多娶几个具体的老婆，分别有做鱼的，做青菜的，炖汤的老婆，如果你想吃一个新菜，就再新找个女人，从你的老婆基类继承一下，让她来做这个新菜。显然多多的老婆这是所有男人的梦想，没有办法，法律不允许，那么咱们只是为了做饭，老婆这个抽象类咱们不叫老婆了，叫做厨师吧，她的子类也自然而然的该叫做鱼的厨师、炖汤的厨师了。现在来看这个模式发生了变化，结构中多了一个厨师的抽象，抽象并不具体的加工产品了，至于是炖汤还是炖鱼，是由这个抽象工厂的继承子类来实现，现在的模式也就变成工厂方法模式了，这个上面的结构图1)就变成了下面的图3的结构了。<br><img src="http://images.cnblogs.com/cnblogs_com/Seasky/167561/r_1-4.JPG" alt=""><br>&nbsp; &nbsp; &nbsp;&nbsp; （图3）</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;现在再来分析现在的模式，显然简单工厂的缺陷解决了，新增加一个菜只需要新增加一个厨师就行了，原来的厨师还在做原来的工作，这样你的设计就对修改封闭了。你看把老婆解放出来，招聘大量的厨师到你家里这个方案多么的完美，你老婆也会爱死你了。当然前提就是你要有多多的钱噢，当然这里的钱的多少在软件领域应该看你的客户软件投资方的要求。<br>下面来一下标准的工厂模式的实现 </p>
<h5 id="意图-1"><a href="#意图-1" class="headerlink" title="意图"></a>意图</h5><ul>
<li>定义一个用户创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。*   上面是GOF关于此模式的意图描述，我想补充的是您可以这样理解：为了改善简单工厂对修改不能关闭的问题。</li>
</ul>
<h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p>&nbsp; <img src="http://images.cnblogs.com/cnblogs_com/Seasky/167561/r_1-5.JPG" alt=""><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;图4</p>
<h5 id="角色分析-1"><a href="#角色分析-1" class="headerlink" title="角色分析"></a>角色分析</h5><div style="padding-right: 20px; padding-left: 30px; padding-bottom: 10px; padding-top: 0px;"><strong>产品基类</strong>：同简单工厂的产品基类，其实就是用和简单工厂中的是同一个类，这里并没有重写。<br><strong>具体产品类</strong>：也是用的简单工厂的具体产品类，为了体现对修改的关闭这里为系统新添加了一个具体产品类，就是&ldquo;新产品&rdquo;，代码中叫做&ldquo;ConcreteProductANew&rdquo;<br><strong>工厂基类</strong>：定义了工厂创建产品的接口，但是没有实现，具体创建工作由其继承类实现。<br>代码实例<br><br><pre class="programlisting">//工厂模式，此模式的工厂只定义加工产品的接口，具体生成交予其继承类实现<br>//只有具体的继承类才确定要加工何种产品<br>class Factory<br>{<br>public:<br>Factory(void);<br>public:<br>virtual ~Factory(void);<br>public:<br>virtual Product<em> CreateProduct(int ProductType = 0) =0;<br>};<br>//CPP<br>Factory::Factory(void)<br>{<br>}<br>Factory::~Factory(void)<br>{<br>}<br></em></pre><br><strong>具体工厂类</strong>：工厂基类的具体实现，由此类决定创建具体产品，这里 <strong>ConcreteFactory1</strong> 对于与图中的 <strong>工厂实现</strong>，<strong>ConcreteFactory2</strong> 对于与图中的<strong>新工厂</strong>。<br>下面给出实现代码<br><br><pre class="programlisting">//工厂实现<br>class ConcreteFactory1:public Factory<br>{<br>public:<br>ConcreteFactory1();<br>public:<br>virtual ~ConcreteFactory1();<br>public :<br>Product CreateProduct(int ProductType);<br>};<br>//新工厂，当要创建新类是实现此新工厂<br>class ConcreteFactory2:public Factory<br>{<br>public:<br>ConcreteFactory2();<br>public:<br>virtual ~ConcreteFactory2();<br>public :<br>Product<em> CreateProduct(int ProductType);<br>};<br>//CPP<br>ConcreteFactory1::ConcreteFactory1()<br>{<br>}<br>ConcreteFactory1::~ConcreteFactory1()<br>{<br>}<br>Product </em> ConcreteFactory1::CreateProduct(int ProductType = 0)<br>{<br>Product <em>p = 0;<br>switch(ProductType)<br>{<br>case 0:<br>p= new ConcreteProductA();<br>break;<br>case 1:<br>p= new ConcreteProductB();<br>break;<br>default:<br>p= new ConcreteProductA();<br>break;<br>}<br>return p;<br>}<br>ConcreteFactory2::ConcreteFactory2()<br>{<br>}<br>ConcreteFactory2::~ConcreteFactory2()<br>{<br>}<br>Product </em> ConcreteFactory2::CreateProduct(int ProductType = 0)<br>{<br>return new ConcreteProductANew();<br>}<br></pre><br><strong>客户端调用</strong>：访问角色（产品基类、工厂基类、工厂实现类）<br><strong>调用描述</strong>：客户程序通过工厂基类的方法调用工厂实现类用来创建所需要的具体产品。从而实现产品功能的访问。<br>代码实现<br><br><pre class="programlisting">Factory<em>fct = new ConcreteFactory1();<br>Product </em>p = fct-&gt;CreateProduct(0);<br>p-&gt;Function();<br>delete p;<br>p = fct-&gt;CreateProduct(1);<br>p-&gt;Function();<br>delete p;<br>delete fct;<br>fct = new ConcreteFactory2();<br>p=fct-&gt;CreateProduct();<br>delete p;<br>delete fct;<br></pre><br></div>

<h5 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h5><p><strong>优点 </strong></p>
<ul>
<li>简单工厂具有的优点*   解决了简单工厂的修改不能关闭的问题。系统新增产品，新增一个产品工厂即可，对抽象工厂不受影响。</li>
</ul>
<p><strong>缺点</strong>：对于创建不同系列的产品无能为力 </p>
<h5 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h5><ul>
<li>当一个类不知道它所必须创建的对象的类的时候。<em>   当一个类希望由它的子类来指定它所创建的对象的时候。</em>   当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化的时候。</li>
</ul>
<h5 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h5><ul>
<li>吕震宇的<a href="http://www.cnblogs.com/zhenyulu/articles/36590.html" target="_blank" rel="noopener">C#设计模式（5）－Factory Method Pattern </a></li>
<li>TerryLee 的<a href="http://terrylee.cnblogs.com/archive/2006/01/04/310716.html" target="_blank" rel="noopener">.NET设计模式（5）：工厂方法模式（Factory Method） </a></li>
</ul>
<p>&nbsp;</p>
<h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><h5 id="生活例子-2"><a href="#生活例子-2" class="headerlink" title="生活例子"></a>生活例子</h5><p>&nbsp; &nbsp;&nbsp;&nbsp; 世事多变，随着时间的推移，走过的地方越来越多，你天南海北的朋友也越来越多。你发现菜原来还分了许多菜系，鲁菜、粤菜、湘菜等等，它们各有各的风味，同样是红烧肉由不同菜系出来的味道也各不相同， 你招待不同的朋友要用不同的菜系，这下难办了，你的厨师都是鲁菜风味，怎么办，广东的朋友来了吃不惯。现在我们再回到简单工厂模式（就是老婆做菜的模式），我们把红烧肉再向下继承，生成鲁菜红烧肉、粤菜红烧肉、湘菜红烧肉；清蒸鱼向下继承为鲁菜清蒸鱼、粤菜清蒸鱼、湘菜清蒸鱼，其它也以此类推。我们也修改一下老婆的这个类，不让其返回食物基类，而是返回红烧肉、清蒸鱼、爆炒空心菜、西红柿鸡蛋汤这一层次，并把这些方法抽象化，作为菜系工厂基类，然后再从此基类继承出，鲁菜工厂、粤菜工厂、湘菜工厂等等，再由这些具体工厂实现创建具体菜的工作，哈哈你如果招待广东朋友就用粤菜工厂，返回的就是一桌粤菜菜系的红烧肉、清蒸鱼、空心菜和西红柿鸡蛋汤了，你的广东朋友一定会吃的非常合乎胃口了。噢，非常好，你已经实现了抽象工厂模式了。结构模型图也变成了下图 6)的样子了。<br><img src="http://images.cnblogs.com/cnblogs_com/Seasky/167561/r_1-6.JPG" alt=""><br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; （图6）<br>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 现在可以看到，想新来做一个菜系，只需新聘请一个厨师就可以了，多么完美，但是你先别高兴太早，如果你想新增加一个菜就变得非常困难了。</p>
<h5 id="意图-2"><a href="#意图-2" class="headerlink" title="意图"></a>意图</h5><p>&nbsp; &nbsp; &nbsp; &nbsp;提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。<br><strong>结构</strong><br><img src="http://images.cnblogs.com/cnblogs_com/Seasky/167561/r_1-7.JPG" alt=""></p>
<h5 id="角色分析-2"><a href="#角色分析-2" class="headerlink" title="角色分析"></a>角色分析</h5><div style="padding-right: 20px; padding-left: 30px; padding-bottom: 10px; padding-top: 0px;"><strong>产品基类</strong>：这里包含产品基类A和产品基类B，实际上在我的示例代码中，这两个产品都从共同的基类继承而来，但是这个继承关系却是在这个模式之外的部分，而本身这个模式关心的是这两个产品基类的差异部分。<br>代码实现：这里的代码就是借用的简单工厂模式中具体产品类的代码实现部分，为了大家阅读方便，下面重新给出一下。<br><br><pre class="programlisting">        //产品A<br>class ConcreteProductA:public Product<br>{<br>public:<br>ConcreteProductA(void);<br>public:<br>virtual ~ConcreteProductA(void);<br>public:<br>virtual void Function();<br>};<br>//cpp<br>ConcreteProductA::ConcreteProductA()<br>{<br>cout&lt;&lt;”创建 A 产品”&lt;&lt;endl;<br>}<br>ConcreteProductA::~ConcreteProductA()<br>{<br>cout&lt;&lt;”释放 A 产品”&lt;&lt;endl;<br>}<br>void ConcreteProductA::Function()<br>{<br>cout&lt;&lt;”这是产品 A 具有的基本功能”&lt;&lt;endl;<br>}<br>//产品B与A类似不这里不再给出，大家可以下载源码<br></pre><br><br><strong><br>具体产品</strong>类：这里的具体产品类是产品A1，A2，B1、B2等，<br>代码实现：A1对应的实现就是&ldquo;&rdquo;<br><br><pre class="programlisting">class ConcreteProductA1:public ConcreteProductA<br>{<br>public:<br>ConcreteProductA1(void);<br>public:<br>virtual ~ConcreteProductA1(void);<br>public:<br>virtual void Function();<br>};<br>//CPP<br>ConcreteProductA1::ConcreteProductA1()<br>{<br>cout&lt;&lt;”创建 A1 产品”&lt;&lt;endl;<br>}<br>ConcreteProductA1::~ConcreteProductA1()<br>{<br>cout&lt;&lt;”释放 A1 产品”&lt;&lt;endl;<br>}<br>void ConcreteProductA1::Function()<br>{<br>cout&lt;&lt;”这时产品 A1 具有的基本功能”&lt;&lt;endl;<br>}<br></pre><br><br><strong>工厂抽象</strong>接口：定义了创建产品的接口，这里返回参数是返回的产品A，产品B，而本身产品A和B的共同基类，小弟认为正是这个特征构成了抽象工厂和工厂模式的区别。<br>代码实现<br><br><pre class="programlisting">//抽象工厂模式<br>class AbstractFactory<br>{<br>public:<br>AbstractFactory();<br>public:<br>virtual ~AbstractFactory();<br>public:<br>virtual ConcreteProductA<em> CreateA() = 0;<br>virtual ConcreteProductB</em> CreateB() = 0;<br>};<br>//CPP<br>AbstractFactory::AbstractFactory()<br>{<br>}<br>AbstractFactory::~AbstractFactory()<br>{<br>}<br></pre><br><br>具体工厂实现类：工厂1和工厂2。新增加系列，只需新实现一个工厂。<br>代码实现: 工厂1的就是ConcreteAbsFactory1，工厂2的代码类似，这里没有给出，可以在下载代码中看到<br><br><pre class="programlisting">////工厂1—–<br>class ConcreteAbsFactory1:public AbstractFactory<br>{<br>public:<br>ConcreteAbsFactory1();<br>public:<br>virtual ~ConcreteAbsFactory1();<br>public:<br>virtual ConcreteProductA<em> CreateA();<br>virtual ConcreteProductB</em> CreateB();<br>};<br>//CPP<br>ConcreteAbsFactory1::ConcreteAbsFactory1()<br>{<br>}<br>ConcreteAbsFactory1::~ConcreteAbsFactory1()<br>{<br>}<br>ConcreteProductA<em> ConcreteAbsFactory1::CreateA()<br>{<br>return new ConcreteProductA1();<br>}<br>ConcreteProductB </em> ConcreteAbsFactory1::CreateB()<br>{<br>return new ConcreteProductB1();<br>}<br></pre><br><br>客户端访问： 访问角色（产品基类、抽象工厂、具体工厂实现类）<br>访问描述： 通过抽象工厂的指针访问具体工厂实现来创建对应系列的产品，然后通过产品基类指针访问产品功能。<br>调用代码：<br><br><pre class="programlisting">          AbstractFactory <em>absfct = new ConcreteAbsFactory1();<br>ConcreteProductA </em>cpa = absfct-&gt;CreateA();<br>cpa-&gt;Function();<br>delete cpa;<br>ConcreteProductB *cpb = absfct-&gt;CreateB();<br>cpb-&gt;Function();<br>delete cpb;<br>delete absfct;<br>absfct = new ConcreteAbsFactory2();<br>cpa = absfct-&gt;CreateA();<br>cpa-&gt;Function();<br>delete cpa;<br>cpb = absfct-&gt;CreateB();<br>cpb-&gt;Function();<br>delete cpb;<br></pre><br></div>

<p>&nbsp;</p>
<h5 id="和工厂模式的分析比较"><a href="#和工厂模式的分析比较" class="headerlink" title="和工厂模式的分析比较"></a>和工厂模式的分析比较</h5><p>&nbsp; &nbsp; &nbsp;&nbsp; 现在可以和工厂模式对比一下，抽象工厂返回的接口不再是产品A和产品B的共同基类Product了，而是产品A、产品B基类（在工厂模式中它们为具体实现类，这里变成了基类）了。此时工厂的抽象和简单工厂中的工厂方法也很类似，就是这些特征区使其别于工厂模式而变成抽象工厂模式了，因此抽象工厂解决的是创建一系列有共同风格的产品（鲁菜还是粤菜），而工厂方法模式解决的创建有共同特征的一系列产品（红烧肉、清蒸鱼它们都是食物）。当然简单工厂的缺陷在抽象工厂中又再次出现了，我要新增加一个产品，工厂抽象接口就要改变了。因此抽象工厂并不比工厂模式完美，只不过是各自的适用领域不同而已。其实，这里如果把抽象工厂模式的接口返回产品A和产品B的共同基类（工厂模式返回的参数），你会发现，奇怪这个模式怎么这么眼熟，它不是恰恰退化成工厂模式了。<br>&nbsp; &nbsp; &nbsp; &nbsp;类模式与对象模式的区别讨论：先看定义类&ldquo;模式使用继承关系，把对象的创建延迟的子类，对象模式把对象的创建延迟到另一个对象中&rdquo;。 分析：首先它们创建对象都不是在基类中完成，都是在子类中实现，因此都符合类模式的概念；但是工厂模式的创建产品对象是在编译期决定的，要调用某个工厂固定的，而抽象工厂模式对产品的创建是在运行时动态决定的，只有到运行时才确定要调用那个工厂，调用工厂随运行环境而改变。（这里我一直很混乱，欢迎大家讨论）</p>
<h5 id="适用性-1"><a href="#适用性-1" class="headerlink" title="适用性"></a>适用性</h5><ul>
<li>一个系统要独立于它的产品的创建、组合和表示时<em>   一个系统要由多个 产品系列中的一个来配置时</em>   当你要强调一个系列相关的产品对象的设计以便进行联合使用时*   当你提供一个产品类库，而只想显示它们的接口而不是实现时。</li>
</ul>
<h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><ul>
<li>吕震宇的<a href="http://www.cnblogs.com/zhenyulu/articles/36885.html" target="_blank" rel="noopener">C#设计模式（6）</a>*   TerryLee 的<a href="http://terrylee.cnblogs.com/archive/2005/12/13/295965.html" target="_blank" rel="noopener">.NET设计模式（3）：抽象工厂模式（Abstract Factory）</a></li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;工厂本质就是用工厂方法替代直接New来创建对象。这里不是指的让用户重载一个新操作符号来进行创建对象的操作，而是说把New 操作封装在一个方法中，等用户需要创建对象时调用此方法而避免直接使用New而已。这样做的目的就是之一就是封装，避免代码中大量New的运算符，这当然不是主要目的，因为这样虽然New少了，CreateObject方法却多了，但是如果产品类的构造函数变了，我想常用工厂模式的修改源代码的工作应该简便许多吧，当然这算不上这个模式的好处，它的真正强大的功能其实在于适应变化，这也是整个设计模式最根本的目的；还有一点就是体现了抽象于实现的分离，当然创建型模式都具有这个特点，工厂模式非常明显吧了，把具体创建工作放置到工厂中，使客户端程序更专注与业务逻辑的，这样的代码结构也更进行合理。</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/07/14/c中回调callback的使用方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/07/14/c中回调callback的使用方法/" itemprop="url">C++中回调(CallBack)的使用方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-07-14T23:55:00+08:00">
                2009-07-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>回调函数是一个很有用，也很重要的概念。当发生某种事件时，系统或其他函数将会自动调用你定义的一段函数。回调函数在windows编程使用的场合很多，比如Hook回调函数：MouseProc,GetMsgProc以及EnumWindows,DrawState的回调函数等等，还有很多系统级的回调过程。 一般情况下, 我们使用的回调函数基本都是采用C语言风格. 这里介绍一种C++风格的回调对象方法. 采用template实现.</p>
<p>template &lt; class Class, typename ReturnType, typename Parameter &gt;&nbsp;&nbsp;<br>class SingularCallBack&nbsp;&nbsp;<br>{&nbsp;&nbsp;&nbsp;<br>public:&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; typedef ReturnType (Class::<em>Method)(Parameter);&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; SingularCallBack(Class</em> _class_instance, Method _method)&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //取得对象实例地址,及调用方法地址&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class_instance = _class_instance;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; method&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = _method;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; ReturnType operator()(Parameter parameter)&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 调用对象方法&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return (class_instance-&gt;<em>method)(parameter);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; ReturnType execute(Parameter parameter)&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 调用对象方法&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return operator()(parameter);&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;<br>&nbsp;&nbsp; private:&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; Class</em>&nbsp; class_instance;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; Method&nbsp; method;&nbsp;&nbsp;<br>&nbsp;<br>};&nbsp;<br>示例:</p>
<p>以下是两个类实现.<br>class A&nbsp;&nbsp;<br>{&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp; public:&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; void output()&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; “I am class A :D” &lt;&lt; std::endl;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;<br>&nbsp;<br>};&nbsp;&nbsp;<br>&nbsp;<br>class B&nbsp;&nbsp;<br>{&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp; public:&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; bool methodB(A a)&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a.output();&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; }&nbsp;&nbsp;<br>&nbsp;<br>};&nbsp;&nbsp;<br>&nbsp;</p>
<p>SingularCallBack的各种调用示例:<br>A a;<br>B b;</p>
<p>SingularCallBack&lt; B,bool,A &gt;* cb;<br>cb = new SingularCallBack&lt; B,bool,A &gt;(&amp;b,&amp;B::methodB);</p>
<p>if(cb-&gt;execute(a))<br>{<br>&nbsp;&nbsp; std::cout &lt;&lt; “CallBack Fired Successfully!” &lt;&lt; std::endl;<br>}<br>else<br>{<br>&nbsp;&nbsp; std::cout &lt;&lt; “CallBack Fired Unsuccessfully!” &lt;&lt; std::endl;<br>}<br>&nbsp;&nbsp;<br>class AClass&nbsp;&nbsp;<br>{&nbsp;&nbsp;<br>&nbsp;&nbsp; public:&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; AClass(unsigned int _id): id(_id){};&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; ~AClass(){};&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; bool AMethod(std::string str)&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; {&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; std::cout &lt;&lt; “AClass[“ &lt;&lt; id &lt;&lt; “]: “ &lt;&lt; str &lt;&lt; std::endl;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return true;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp; };&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp; private:&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp;&nbsp; unsigned int id;&nbsp;&nbsp;<br>&nbsp;<br>};&nbsp;&nbsp;&nbsp;</p>
<p>typedef SingularCallBack &lt; AClass, bool, std::string &gt; ACallBack;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;</p>
<p>int main()&nbsp;&nbsp;<br>{&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp; std::vector &lt; ACallBack &gt; callback_list;&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp; AClass a1(1);&nbsp;&nbsp;<br>&nbsp;&nbsp; AClass a2(2);&nbsp;&nbsp;<br>&nbsp;&nbsp; AClass a3(3);&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp; callback_list.push_back(ACallBack(&amp;a1, &amp;AClass::AMethod));&nbsp;&nbsp;<br>&nbsp;&nbsp; callback_list.push_back(ACallBack(&amp;a2, &amp;AClass::AMethod));&nbsp;&nbsp;<br>&nbsp;&nbsp; callback_list.push_back(ACallBack(&amp;a3, &amp;AClass::AMethod));&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp; for (unsigned int i = 0; i &lt; callback_list.size(); i++)&nbsp;&nbsp;<br>&nbsp;&nbsp; {&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callback_list<a href="&quot;abc&quot;">i</a>;&nbsp;&nbsp;<br>&nbsp;&nbsp; }&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp; for (unsigned int i = 0; i &lt; callback_list.size(); i++)&nbsp;&nbsp;<br>&nbsp;&nbsp; {&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callback_list[i].execute(“abc”);&nbsp;&nbsp;<br>&nbsp;&nbsp; }&nbsp;&nbsp;<br>&nbsp;<br>&nbsp;&nbsp; return true;&nbsp;&nbsp;<br>&nbsp;<br>}&nbsp;&nbsp;<br>&nbsp;</p>
<p>引用:</p>
<p>C++ Callback Solution </p>
<p>本文来自CSDN博客，转载请标明出处：<a href="http://blog.csdn.net/force_eagle/archive/2009/07/14/4347329.aspx" target="_blank" rel="noopener">http://blog.csdn.net/force_eagle/archive/2009/07/14/4347329.aspx</a></p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/07/09/im的技术原理与发展/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/07/09/im的技术原理与发展/" itemprop="url">IM的技术原理与发展</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-07-09T01:19:00+08:00">
                2009-07-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/未分类/" itemprop="url" rel="index">
                    <span itemprop="name">未分类</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一、IM技术概念</p>
<p>IM技术全称Instant Messaging，中文翻译&ldquo;即时通讯&rdquo;，它是一种使人们能在网上识别在线用户并与他们实时交换消息的技术，是电子邮件发明以来迅速崛起的在线通讯方式。</p>
<p>IM的出现和互联网有着密不可分的关系，IM完全基于TCP/IP网络协议族实现，而TCP/IP协议族则是整个互联网得以实现的技术基础。 最早出现即时通讯协议是IRC（Internet Relay Chat），但是可惜的是它仅能单纯的使用文字、符号的方式通过互联网进行交谈和沟通。随着互连网变得高度发达，即时通讯也变得远不止聊天这么简单，自1996年第一个IM产品ICQ发明后，IM的技术和功能也开始基本成型，语音、视频、文件共享、短信发送等高级信息交换功能都可以在IM工具上实现，于是功能强大的IM软件便足以搭建一个完整的通信交流平台。目前最具代表性的几款的IM通讯软件有MSN、Google Talk、Yahoo、Messenger 、腾讯QQ等。</p>
<p>二、IM技术原理和工作方式</p>
<p>典型的IM工作方式如下：登陆IM通讯中心（IM通讯服务器），获取一个自建立的历史的交流对象列表（好友列表），然后自身标志为在线状态，当好友列表中的某人在任何时候登录上线并试图通过你的计算机联系你时，IM系统会发一个消息提醒你，然后你能与他建立一个聊天会话通道进行各种消息如键入文字、通过语音等的交流，<br>从技术上来说，IM的基本技术原理如下：</p>
<p>IM服务器<br>登陆或注销<br>用户A通过列表找到B，用户B获得的消息并与之交谈<br>通过IM服务器指引建立与B单独的通讯通道</p>
<p>第一步，用户A输入自己的用户名和密码登录IM服务器，服务器通过读取用户数据库来验证用户身份，如果验证通过，登记用户A的IP地址、IM客户端软件的版本号及使用的TCP/UDP端口号，然后返回用户A登录成功的标志，此时用户A在IM系统中的状态为在线（Online Presence）。</p>
<p>第二步，根据用户A存储在IM服务器上的好友列表（Buddy List），服务器将用户A在线的相关信息发送给也同时在线的IM好友的PC机，这些信息包括在线状态、IP地址、IM客户端使用的TCP端口（Port）号等，IM好友的客户端收到此信息后将在予以提示。</p>
<p>第三步是IM服务器把用户A存储在服务器上的好友列表及相关信息回送到他的客户端机，这些信息包括也在线状态、IP地址、IM客户端使用的TCP端口（Port）号等信息，用户A的IM客户端收到后将显示这些好友列表及其在线状态。</p>
<p>三、IM通讯方式</p>
<p>1.在线直接通讯<br>如果用户A想与他的在线好友用户B聊天，他将直接通过服务器发送过来的用户B的IP地址、TCP端口号等信息，直接向用户B的PC机发出聊天信息，用户B的IM客户端软件收到后显示在屏幕上，然后用户B再直接回复到用户A的PC机，这样双方的即时文字消息就不再IM服务器中转，而是直接通过网络进行点对点的通讯，即对等通讯方式（Peer To Peer）。</p>
<p>2.在线代理通讯<br>用户A与用户B的点对点通讯由于防火墙、网络速度等原因难以建立或者速度很慢，IM服务器将会主动提供消息中转服务，即用户A和用户B的即时消息全部先发送到IM服务器，再由服务器转发给对方。</p>
<p>3.离线代理通讯<br>用户A与用户B由于各种原因不能同时在线的时候，如此时A向B发送消息，IM服务器可以主动寄存A用户的消息，到B用户下一次登陆的时候，自动将消息转发给B。</p>
<p>4.扩展方式通讯<br>用户A可以通过IM服务器将信息以扩展的方式传递给B，如短信发送方式发送到B的手机，传真发送方式传递给B的电话机，以email的方式传递给B的电子邮箱等。<br>早期的IM系统，在IM客户端和IM服务器之间通讯采用UDP协议，UDP协议是不可靠的传输协议，而在IM客户端之间的直接通讯中，采用具备可靠传输能力的TCP协议。随着用户需求和技术环境的发展，目前主流的IM系统倾向于在IM客户端之间、IM客户端和IM服务器之间都采用TCP协议。<br>即时通讯相对于其他通讯方式如电话、传真、email等的最大优势就是消息传达的即时性和精确性，只要消息传递双方均在网络上可以互通，使用即时通讯软件传递消息，传递延时仅为1秒种</p>
<p>四、兴起的嵌入式IM工具。</p>
<p>传统的IM在统治了互联网即时通讯领域长达十年之久，以其日趋稳定的定能，与较强的用户黏着度，至今仍统治着这个巨大的市场。然而，软件行业的技术精英们，并不满足于此。他们厚积薄发，一直致力于开发出性能更为优越的即时通讯工具。当然，在功能上的不断完善，自然是一个必然的发展方向，在Web2.0时代，如何大力增强用户对网站的黏着度，而不仅仅是对于IM的拥附，已经成为他们的主攻方向了。于是，嵌入式IM工具，应运而生了。</p>
<p>相对以往的传统的即使沟通工具，它们需要用户下载软件包，需要用户进行安装。对于拥有IM产品的网站而言，用户在登陆网站后，不能直接使用其IM工具，对于流量与用户的黏着度，都是有一定影响的。因此在IM与网站相互依存的今天，没有哪家网络公司，愿意将IM工具孤立开来。</p>
<p>于是，目前，一种新型的嵌入式IM工具就应运而生了。这种IM工具，不需要下载安装，当用户登陆网页后，该IM直接嵌套在网页中，可以直接使用。</p>
<p>而在功能上，则一点也不输于传统的IM，无论是传统的文字沟通的速度与效率，还是近年来越来越成为IM工具必备的音频/视频功能，这种嵌入式IM都能提供非常稳定的传输。更值得一提的是，因为嵌入式IM是嵌套在网页上的，软件供应商，可以根据网站需求，设计出适合网站风格的IM产品。而不是像传统的IM工具，千篇一律，毫无个性可言。</p>
<p>目前，这类嵌入式IM在社区、交友、社团及协作等类型的网站上，应用已经较为广泛。在Web2.0时代，将发挥越来越重要的作用。 </p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2009/07/06/vs2005内存泄漏检测方法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2009/07/06/vs2005内存泄漏检测方法/" itemprop="url">VS2005内存泄漏检测方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2009-07-06T00:55:00+08:00">
                2009-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;div&gt;
</code></pre><p>原文地址：&nbsp;<a href="http://ufownl.blog.163.com/blog/static/1250122200861912757566/" target="_blank" rel="noopener">http://ufownl.blog.163.com/blog/static/1250122200861912757566/</a></p>
<p>非MFC程序可以用以下方法检测内存泄露：</p>
<p>&nbsp;</p>
<p>1.程序开始包含如下定义：</p>
<p>#define _CRTDBG_MAP_ALLOC</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;crtdbg.h&gt;</p>
<p>&nbsp;</p>
<p>2.程序退出前添加下面的函数：</p>
<p>_CrtDumpMemoryLeaks();</p>
<p>&nbsp;</p>
<p>Debug版本程序运行结束后如有内存泄漏，输出窗口中会显示类似信息：<br>Detected memory leaks!<br>Dumping objects -&gt;<br>e:/microsoft visual studio 8/vc/include/crtdbg.h(1150) : {48} normal block at 0x00382F50, 12 bytes long.<br>&nbsp;Data: &lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt; 01 00 00 00 02 00 00 00 03 00 00 00<br>Object dump complete.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>MFC程序内存泄漏检测方法：</p>
<p>&nbsp;</p>
<p>1.在 CMyApp 中添加如下三个 CMemoryState 类的成员变量：</p>
<p>#ifdef _DEBUG<br>protected:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMemoryState m_msOld, m_msNew, m_msDiff;</p>
<p>#endif&nbsp; // _DEBUG</p>
<p>&nbsp;</p>
<p>2.在 CMyApp::InitInstance() 中添加如下代码：</p>
<p>#ifdef _DEBUG<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_msOld.Checkpoint();</p>
<p>#endif&nbsp; // _DEBUG</p>
<p>&nbsp;</p>
<p>3.在 CMyApp::ExitInstance() 中添加如下代码：</p>
<p>#ifdef _DEBUG<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_msNew.Checkpoint();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (m_msDiff.Difference(m_msOld, m_msNew))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; afxDump&lt;&lt;”/nMemory Leaked :/n”;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_msDiff.DumpStatistics();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; afxDump&lt;&lt;”Dump Complete !/n/n”;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>#endif&nbsp; // _DEBUG</p>
<p>&nbsp;</p>
<p>Debug版本程序运行结束后如有内存泄漏，输出窗口中会显示类似信息：</p>
<p>Memory Leaked :<br>0 bytes in 0 Free Blocks.<br>8 bytes in 1 Normal Blocks.<br>0 bytes in 0 CRT Blocks.<br>0 bytes in 0 Ignore Blocks.<br>0 bytes in 0 Client Blocks.<br>Largest number used: 8825 bytes.<br>Total allocations: 47506 bytes.<br>Dump Complete !</p>
<p>Detected memory leaks!<br>Dumping objects -&gt;<br>g:/programs/chat/chatdlg.cpp(120) : {118} normal block at 0x00D98150, 8 bytes long.<br>&nbsp;Data: &lt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &gt; A8 7F D9 00 01 00 00 00<br>Object dump complete.</p>
<p><br></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/8/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/10/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">billowqiu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">152</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/billowqiu" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:billowqiu@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">billowqiu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
