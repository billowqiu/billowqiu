<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="taocoding">
<meta property="og:url" content="http://yoursite.com/page/15/index.html">
<meta property="og:site_name" content="taocoding">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="taocoding">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/15/">





  <title>taocoding</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d13234060d812cb98a47e937139083a9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">taocoding</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/09/05/key-concept-polymorphism-in-c/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/09/05/key-concept-polymorphism-in-c/" itemprop="url">Key Concept: Polymorphism in C++</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-09-05T18:22:00+08:00">
                2007-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;TABLE style=&quot;TABLE-LAYOUT: fixed&quot;&gt;
</code></pre><p><tbody></tbody></p>
<p><tr></tr></p>
<p><td></td></p>
<div class="cnt" id="blog_text">

<font size="3">The crucial point about references and pointers to base-class types is that the <strong><a name="ch15term21"></a><a href="mk:@MSITStore:E:%20学习资料%20C++学习资料%20C++Primer4E.chm::/0201721481/ch15lev1sec11.html#gloss15_21" target="_blank" rel="noopener"><u><font color="#0000ff">static type</font></u></a></strong>the type of the reference or pointer, which is knowable at compile timeand the <strong><a name="ch15term7"></a><a href="mk:@MSITStore:E:%20学习资料%20C++学习资料%20C++Primer4E.chm::/0201721481/ch15lev1sec11.html#gloss15_07" target="_blank" rel="noopener"><u><font color="#0000ff">dynamic type</font></u></a></strong>the type of the object to which the pointer or reference is bound, which is knowable only at run timemay differ.</font>

<p><a name="idd1e114290"></a><a name="idd1e114297"></a><a name="idd1e114302"></a><a name="idd1e114307"></a><a name="idd1e114315"></a><a name="idd1e114320"></a><a name="idd1e114325"></a><a name="idd1e114328"></a><a name="idd1e114333"></a><a name="idd1e114338"></a><a name="idd1e114343"></a><a name="idd1e114348"></a><span class="docEmphStrong"><font size="3">The fact that the static and dynamic types of references and pointers can differ is the cornerstone of how C++ supports polymorphism.</font></span></p>
<span class="docEmphStrong"><font size="3">When we call a function defined in the base class through a base-class reference or pointer, we do not know the precise type of the object on which the function is executed. The object on which the function executes might be of the base type or it might be an object of a derived type.</font></span>

<span class="docEmphStrong"><font size="3">If the function called is nonvirtual, then regardless of the actual object type, the function that is executed is the one defined by the base type. If the function is virtual, then the decision as to which function to run is delayed until run time. The version of the virtual function that is run is the one defined by the type of the object to which the reference is bound or to which the pointer points.</font></span>

<span class="docEmphStrong"><font size="3">From the perspective of the code that we write, we need not care. As long as the classes are designed and implemented correctly, the operations will do the right thing whether the actual object is of base or derived type.</font></span>

<p><span class="docEmphStrong"><font size="3">On the other hand, an object is not polymorphicits type is known and unchanging. The dynamic type of an object (as opposed to a reference or pointer) is always the same as the static type of the object. The function that is run, virtual or nonvirtual, is the one defined by the type of the object.</font></span></p>
<p><a name="ch15note07"></a></p>
<div class="docNote">

<p><table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="1" width="90%" border="0"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td valign="top" width="60"><img src="mk:@MSITStore:E:%20学习资料%20C++学习资料%20C++Primer4E.chm::/0201721481/images/0201721481/graphics/note.jpg;400478" alt=""></td></p>
<p><td valign="top"></td></p>
<p></p><p class="docText"><span class="docEmphStrong">Virtuals are resolved at run time <span class="docEmphasis">only</span> if the call is made through a reference or pointer. Only in these cases is it possible for an object’s dynamic type to be unknown until run time.</span><br></p></div></div><br><p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/09/01/float-toolbar-and-dock-toolbar/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/09/01/float-toolbar-and-dock-toolbar/" itemprop="url">Float ToolBar and dock ToolBar</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-09-01T18:37:00+08:00">
                2007-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;TABLE style=&quot;TABLE-LAYOUT: fixed&quot;&gt;
</code></pre><p><tbody></tbody></p>
<p><tr></tr></p>
<p><td></td></p>
<p><div class="cnt" id="blog_text"></div></p>
<p><div><font face="黑体" size="4">A docked toolbar is a child of the frame window it’s docked to, but a floating toolbar is a child of the mini frame window that surrounds it. The mini frame window is a popup window owned by the frame window, but it’s not a child of the frame window. (A popup window is a window with the style WS_POPUP; a child window has the WS_CHILD style instead.) The distinction is important because popup windows owned by a frame window are destroyed before the frame window is destroyed. Child windows, on the other hand, are destroyed <em>after</em> their parents are destroyed. A floating toolbar no longer exists when the frame window’s <em>OnDestroy</em> function is called.</font></div><br></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/09/01/消息传递过程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/09/01/消息传递过程/" itemprop="url">消息传递过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-09-01T18:36:00+08:00">
                2007-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;DIV class=cnt id=blog_text&gt;
</code></pre><font size="3"><span><img src="http://blog.programfan.com/upfile/200709/200709010105037.gif" alt=""><br></span></font>

<font size="3"><span>据说是在</span><span>Run</span><span>中调用</span><span>AfxWndProc</span><span>（侯捷说的我在源码中找了会没找到，也不晓得是哪个间接调用的），在该函数里面接着调用</span><span>AfxCallWndProc</span><span>，然后</span><span>AfxCallWndProc</span><span>中有这么一段</span></font>

<span><font size="3">// special case for WM_INITDIALOG</font></span>

<span><font size="3">CRect rectOld;</font></span>

<span><font size="3">DWORD dwStyle = 0;</font></span>

<span><font size="3">if (nMsg == WM_INITDIALOG)</font></span>

<span><font size="3">_AfxPreInitDialog(pWnd, &amp;rectOld, &amp;dwStyle);</font></span>

<span><font size="3"></font></span>

<span><font size="3">// delegate to object’s WindowProc</font></span>

<span><font size="3">lResult = pWnd-&gt;WindowProc(nMsg, wParam, lParam);</font></span>

<span><font size="3"></font></span>

<span><font size="3">// more special case for WM_INITDIALOG</font></span>

<span><font size="3">if (nMsg == WM_INITDIALOG)</font></span>

<span><font size="3">_AfxPostInitDialog(pWnd, rectOld, dwStyle);</font></span>

<font size="3"><span>如果不是</span><span>WM_INITDIALOG</span><span>消息则调用</span><span>CWnd</span><span>的</span><span>WindowProc</span><span>，这时就有点迷惑了，应该说</span><span>CCmdTarget</span><span>是处理消息的基类其中的</span><span>OnCmdMsg</span><span>为什么不先调用呢，其实我也不清楚，查看了源代码后发现在</span><span>WindowProc</span><span>中会判断消息的类型里面有这么段：</span></font>

<p><strong><span style="FONT-SIZE: 15pt">CWnd::WindowProc</span></strong></p>
<span><font size="3">if (message == WM_COMMAND)</font></span>

<span><font size="3">{</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if (OnCommand(wParam, lParam))</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{</font></span>

<span><font size="3"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>lResult = 1;</font></span>

<span><font size="3"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>goto LReturnTrue;</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return FALSE;</font></span>

<span><font size="3">}</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>CWnd::OnCommand</strong></font></span>

<font size="3"><span>如果是命令消息加速键等用户接口对象的</span><span>WM_COMMAND</span><span>通知消息（有些控件也会发送此消息比如按钮的单击），则调用</span><span>OnCommand</span><span>处理，而在</span><span>OnCommand</span><span>中会判断是一般命令消息还是控件消息，其中如果不是控件消息的话会调用</span><span>OnCmdMsg(nID, CN_UPDATE_COMMAND_UI, &amp;state, NULL);</span><span>看到了吧这里就调用了从</span><span>CCmdTarget</span><span>继承来的虚函数（我只找到了</span><span>CWnd</span><span>的这个地方调用了改消息）。</span></font>

<span><font size="3">接着是控件消息</font></span>

<span><font size="3">// special case for notifies</font></span>

<span><font size="3">if (message == WM_NOTIFY)</font></span>

<span><font size="3">{</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>NMHDR<em> pNMHDR = (NMHDR</em>)lParam;</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if (pNMHDR-&gt;hwndFrom != NULL &amp;&amp; OnNotify(wParam, lParam, &amp;lResult))</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>goto LReturnTrue;</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return FALSE;</font></span>

<span><font size="3">}</font></span>

<font size="3"><span>关于</span><span>WM_NOTIFY</span><span>的一点说明</span><span>: Win32</span><span>使用新的</span><span>WM_NOFITY</span><span>来处理复杂的通知消息。</span><span>WM_COMMAND</span><span>类型的通知消息仅仅能传递一个控制窗口句柄</span><span>(lparam)</span><span>、控制窗</span><span>ID</span><span>和通知代码</span><span>(wparam)</span><span>。</span><span>WM_NOTIFY</span><span>能传递任意复杂的信息。</span></font>

<font size="3"><span>因此控件消息也得以处理，</span><span>WindowProc</span><span>后面的消息处理可想而知了即其他</span><span>WM</span><span>开头的</span><span>Windows</span><span>标准消息。</span></font>

<font size="3"><span>CFrameWnd</span><span>中改写了</span><span>OnCmdMsg</span></font>

<span><font size="3">BOOL CFrameWnd::OnCmdMsg(UINT nID, int nCode, void* pExtra,</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>AFX_CMDHANDLERINFO* pHandlerInfo)</font></span>

<span><font size="3">{</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CPushRoutingFrame push(this);</font></span>

<span><font size="3"></font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// pump through current view FIRST</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CView* pView = GetActiveView();</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if (pView != NULL &amp;&amp; pView-&gt;OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))</font></span>

<span><font size="3"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return TRUE;</font></span>

<span><font size="3"></font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// then pump through frame</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if (CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))</font></span>

<span><font size="3"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return TRUE;</font></span>

<span><font size="3"></font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// last but not least, pump through app</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CWinApp* pApp = AfxGetApp();</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if (pApp != NULL &amp;&amp; pApp-&gt;OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))</font></span>

<span><font size="3"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return TRUE;</font></span>

<span><font size="3"></font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return FALSE;</font></span>

<span><font size="3">}</font></span>

<font size="3"><span>由于在</span><span>CFrameWnd</span><span>中产生的消息一般都是</span><span>WM_COMMAND</span><span>消息，因此当</span><span>CWnd::WindowProc</span><span>被调用时会转到</span><span>OnCommand</span><span>而</span><span>CFrameWnd</span><span>又改写了</span><span>CWnd</span><span>的</span><span>OnCommand</span><span>那么</span><span>CFrameWnd</span><span>的</span><span>OnCmdMsg</span><span>是如何被调用的呢，原来在</span><span>CFrameWnd::OnCommand</span><span>中调用了</span><span>CWnd</span><span>的</span><span>OnCommand</span><span>，显然</span><span>CFrameWnd::OnCmdMsg</span><span>就被调用了，由上面的</span><span>CFrameWnd::OnCmdMsg</span><span>可以清楚的看到</span><span>CFrameWnd</span><span>对标准消息传递的过程的改写首先让当前的活动视图处理，通过查看视图的源代码可以发现视图的</span><span>OnCmdMsg</span><span>先让</span><span>CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo)</span><span>处理（最终就是调用</span><span>CCmdTarget::OnCmdMsg</span><span>，通过查看源代码可以发现</span><span>// look through message map to see if it applies to us</span><span>，其实就是查找此视图及相关基类的消息映射表进行相应的处理），接着是让</span><span>m_pDocument-&gt;OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);</span><span>处理，不用查看文档的代码也可以猜到文档模板的</span><span>OnCmdMsg</span><span>会调用，当视图的</span><span>OnCmdMsg</span><span>返回后如果没有处理的话又会调用</span><span>CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo)</span><span>（此时是</span><span>CFrameWnd</span><span>处理），最后如果还没有处理的话又给</span><span>App</span><span>对象处理，一直到让</span><span>DefWindowProc</span><span>处理。</span></font>

<span><font size="3">对话框的消息处理与此不同，具体可以根据源代码追踪</font></span>

<p><font size="3"><span>呵呵，第一次跟踪查找</span><span>MFC</span><span>源代码，不知道以上结论正确与否，不过对我理解消息传递的过程还是有点帮助，写下来以免忘了。</span></font><br><br></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/08/31/mdisdi创建过程中的一点不同/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/08/31/mdisdi创建过程中的一点不同/" itemprop="url">MDI,SDI创建过程中的一点不同</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-08-31T18:35:00+08:00">
                2007-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CMultiDocTemplate* pDocTemplate;<br>pDocTemplate = new CMultiDocTemplate(<br>&nbsp;&nbsp; IDR_MDISQUTYPE,<br>&nbsp;&nbsp; RUNTIME_CLASS(CSquaresDoc),<br>&nbsp;&nbsp; RUNTIME_CLASS(CChildFrame), // custom MDI child frame<br>&nbsp;&nbsp; RUNTIME_CLASS(CSquaresView));<br>AddDocTemplate(pDocTemplate);</p>
<p>// create main MDI Frame window<br>CMainFrame* pMainFrame = new CMainFrame;<br>if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))<br>&nbsp;&nbsp; return FALSE;<br>m_pMainWnd = pMainFrame;</p>
<p>。。。。。。。。</p>
<p>&nbsp;&nbsp; // Dispatch commands specified on the command line<br>if (!ProcessShellCommand(cmdInfo))<br>&nbsp;&nbsp; return FALSE;</p>
<p>// The main window has been initialized, so show and update it.<br>pMainFrame-&gt;ShowWindow(m_nCmdShow);<br>pMainFrame-&gt;UpdateWindow();</p>
<p>上面为MDI，下面为SDI</p>
<p>CSingleDocTemplate* pDocTemplate;<br>pDocTemplate = new CSingleDocTemplate(<br>&nbsp;&nbsp; IDR_MAINFRAME,<br>&nbsp;&nbsp; RUNTIME_CLASS(CSquaresDoc),<br>&nbsp;&nbsp; RUNTIME_CLASS(CMainFrame),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // main SDI frame window<br>&nbsp;&nbsp; RUNTIME_CLASS(CSquaresView));<br>AddDocTemplate(pDocTemplate);</p>
<p>。。。。。。。。。。</p>
<p>// Dispatch commands specified on the command line<br>if (!ProcessShellCommand(cmdInfo))<br>&nbsp;&nbsp; return FALSE;</p>
<p>// The main window has been initialized, so show and update it.<br>pMainFrame-&gt;ShowWindow(m_nCmdShow);<br>pMainFrame-&gt;UpdateWindow();</p>
<p>主要是在生产文档模板对象时RUNTIME_CLASS(CChildFrame), // custom MDI child frame<br>VS RUNTIME_CLASS(CMainFrame),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // main SDI frame window<br>MDI传递的是childframe,而SDI传递的mainframe，因此MDI的ProcessShellCommand创建的是ChildFrame而SDI创建的MainFrame，所以MDI中就多出了</p>
<p>// create main MDI Frame window<br>CMainFrame* pMainFrame = new CMainFrame;<br>if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))<br>&nbsp;&nbsp; return FALSE;<br>m_pMainWnd = pMainFrame;</p>
<p>必须自己创建MainFrame.</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/08/26/回调函数在mfc中的使用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/08/26/回调函数在mfc中的使用/" itemprop="url">回调函数在MFC中的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-08-26T18:34:00+08:00">
                2007-08-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <font size="3"><span>回调函数的简单定义就是你定义的由</span><span>Windows</span><span>来调用。以下两个函数摘自《</span><span>Programming Windows with MFC</span><span>》，这里暂且不管函数的具体作用，在</span><span>FillListBox</span><span>中有一个</span><span>API</span><span>函数，它调用的回调函数是</span><span>EnumFontFamProc</span><span>，回调函数的声明形式一般都是相对固定的，具体可以参考</span><span>MSDN</span><span>。</span></font>

<span><font size="3">static int CALLBACK EnumFontFamProc (ENUMLOGFONT* lpelf,</font></span>

<span><font size="3"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>NEWTEXTMETRIC* lpntm, int nFontType, LPARAM lParam);</font></span>

<span><font size="3">void CMainWindow::FillListBox ()</font></span>

<span><font size="3">{</font></span>

<span><font size="3"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>m_wndListBox.ResetContent ();</font></span>

<span><font size="3"></font></span>

<span><font size="3"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>CClientDC dc (this);</font></span>

<span><font size="3"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>::EnumFontFamilies ((HDC) dc, NULL, (FONTENUMPROC) EnumFontFamProc,</font></span>

<span><font size="3"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(LPARAM) this);</font></span>

<span><font size="3">}</font></span>

<span><font size="3">int CALLBACK CMainWindow::EnumFontFamProc (ENUMLOGFONT* lpelf,</font></span>

<span><font size="3"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>NEWTEXTMETRIC* lpntm, int nFontType, LPARAM lParam)</font></span>

<span><font size="3">{</font></span>

<span><font size="3"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>CMainWindow<em> pWnd = (CMainWindow</em>) lParam;</font></span>

<span><font size="3"></font></span>

<span><font size="3"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>if ((pWnd-&gt;m_wndCheckBox.GetCheck () == BST_UNCHECKED) ||</font></span>

<span><font size="3"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>(nFontType &amp; TRUETYPE_FONTTYPE))</font></span>

<span><font size="3"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>pWnd-&gt;m_wndListBox.AddString (lpelf-&gt;elfLogFont.lfFaceName);</font></span>

<span><font size="3"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span>return 1;</font></span>

<span><font size="3">}</font></span>

<font size="3"><span>请注意这里的函数</span><span>EnumFontFamilies</span><span>中的最后一个参数传递的是</span><span>this</span><span>即该</span><span>CMainWindow</span><span>对象的指针，为什么要这样呢，可以看到</span><span>EnumFontFamProc</span><span>的声明是</span><span>static</span><span>，在</span><span>C++</span><span>中</span><span>static</span><span>函数是不能调用非</span><span>static</span><span>成员的，所以这里传递一个</span><span>this</span><span>就不是很奇怪了。但是为什么要将该函数声明为</span><span>static</span><span>呢，这就要归咎于</span><span>C++</span><span>的特殊性了，众所周知</span><span>C++</span><span>编译器在编译的时候都会在对象中添加一个</span><span>this</span><span>指针，在成员函数调用中又会附加一个参数保存</span><span>this</span><span>指针，但是</span><span>Windows</span><span>的回调函数有严格的定义就是必须按照参数列表传递的参数，加了</span><span>this</span><span>指针后参数列表就会与</span><span>Windows</span><span>期望的参数列表不一致了，因此这里将其声明为</span><span>static</span><span>（</span><span>static</span><span>成员函数不会传递</span><span>this</span><span>指针，这点说起来总是知道，但是真正用时总是忘了，唉）。</span></font>

<font size="3"><span><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span>另外在</span><span>Windows</span><span>中使用</span><span>callback</span><span>函数很常见，恰好许多支持回调函数的</span><span>API</span><span>函数都像这里的</span><span>EnumFontFamilies</span><span>一样支持自定义的</span><span>LPARAM</span><span>参数，刚好可以传递</span><span>this</span><span>，如果使用的</span><span>API</span><span>函数不支持这样的自定义的</span><span>LPARAM</span><span>参数，就需要其他的方法了，一种比较简单的方法是将</span><span>this</span><span>复制为</span><span>global</span><span>变量使得回调函数可以使用。</span></font>

<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/08/25/cwnd及窗口产生和销毁过程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/08/25/cwnd及窗口产生和销毁过程/" itemprop="url">CWnd及窗口产生和销毁过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-08-25T18:33:00+08:00">
                2007-08-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;TABLE style=&quot;TABLE-LAYOUT: fixed&quot;&gt;
</code></pre><p><tbody></tbody></p>
<p><tr></tr></p>
<p><td></td></p>
<p><div class="cnt" id="blog_text"></div></p>
<div>

<p>昨天去新华书店看的今天趁还记得就写下了.</p>
<p>窗口创建：首先定义一个CWnd对象，然后调用CWnd::Create，其实Create又会调用CreateEx，与之对应的API函数也是这样，在CreateEx调用AfxCtxCreateWindowEx之前会调用PreCreateWindow，这个时候偶CWnd对应的窗口的句柄还未被Windows分配，之后调用AfxCtxCreateWindowEx，在调用这个函数的过程中会发送WM_CREATE消息从而引发OnCreate函数调用注意调用OnCreate时CWnd中的m_hWnd已经有值了，在OnCreate中可以进行一些初始化以及创建字窗口之类的事情。至此窗口创建完毕。</p>
<p>窗口销毁：可以发送一个WM_CLOSE消息给指定窗口使其调用OnClose函数，此函数中会发送WM_DESTROY从而引发OnDestroy的调用，该函数又会引发最后一个消息WM_NCDESTROY的发送，OnNcDestroy即被调用，在OnNcDestroy的最后会调用PostNcDestroy，CWnd的PostNcDestroy为</p>
<p>void CWnd::PostNcDestroy()<br>{<br>// default to nothing<br>}，什么也不做，但是CFrameWnd重载了此函数</p>
<p>void CFrameWnd::PostNcDestroy()<br>{<br>// default for frame windows is to allocate them on the heap<br>// the default post-cleanup is to ‘delete this’.<br>// never explicitly call ‘delete’ on a CFrameWnd, use DestroyWindow instead<br>delete this;<br>}即我们看到的在App中new的Frame没有删除就是这个原因，但是我们自己从CWnd派生的窗口就不同了，如果你new了就要delete，而且最好就是在这个函数里delete<br></p></div><br><p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/08/18/vc截取屏幕/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/08/18/vc截取屏幕/" itemprop="url">VC截取屏幕</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-08-18T18:33:00+08:00">
                2007-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>一直对GID 不是很懂，今天狠下心来看了一天的GDI，主要是参照着MSDN看，感觉还是有点收获的。根据MSDN写了一个小小的程序，仅仅就是截取屏幕，另外可以将其保存到剪贴板里。 
</code></pre><p>以下为源代码：</p>
<p>// Capturing_Image.cpp : 定义应用程序的入口点。<br>//</p>
<p>#include “stdafx.h”</p>
<p>#include “Capturing_Image.h”</p>
<p>#define MAX_LOADSTRING 100</p>
<p>// 全局变量:<br>HINSTANCE hInst;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 当前实例<br>TCHAR szTitle[MAX_LOADSTRING];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // 标题栏文本<br>TCHAR szWindowClass[MAX_LOADSTRING];&nbsp;&nbsp;&nbsp; // 主窗口类名</p>
<p>// 此代码模块中包含的函数的前向声明:<br>ATOM&nbsp;&nbsp;&nbsp;&nbsp; MyRegisterClass(HINSTANCE hInstance);<br>BOOL&nbsp;&nbsp;&nbsp;&nbsp; InitInstance(HINSTANCE, int);<br>LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);<br>INT_PTR CALLBACK About(HWND, UINT, WPARAM, LPARAM);</p>
<p>void CaptureScreen(HWND,HDC);</p>
<p>int APIENTRY _tWinMain(HINSTANCE hInstance,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HINSTANCE hPrevInstance,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LPTSTR&nbsp;&nbsp;&nbsp; lpCmdLine,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nCmdShow)<br>{<br>UNREFERENCED_PARAMETER(hPrevInstance);<br>UNREFERENCED_PARAMETER(lpCmdLine);</p>
<p>&nbsp;&nbsp; // TODO: 在此放置代码。<br>MSG msg;<br>HACCEL hAccelTable;</p>
<p>// 初始化全局字符串<br>LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);<br>LoadString(hInstance, IDC_CAPTURING_IMAGE, szWindowClass, MAX_LOADSTRING);<br>MyRegisterClass(hInstance);</p>
<p>// 执行应用程序初始化:<br>if (!InitInstance (hInstance, nCmdShow))<br>{<br>&nbsp;&nbsp; return FALSE;<br>}</p>
<p>hAccelTable = LoadAccelerators(hInstance, MAKEINTRESOURCE(IDC_CAPTURING_IMAGE));</p>
<p>// 主消息循环:<br>while (GetMessage(&amp;msg, NULL, 0, 0))<br>{<br>&nbsp;&nbsp; if (!TranslateAccelerator(msg.hwnd, hAccelTable, &amp;msg))<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; TranslateMessage(&amp;msg);<br>&nbsp;&nbsp;&nbsp; DispatchMessage(&amp;msg);<br>&nbsp;&nbsp; }<br>}</p>
<p>return (int) msg.wParam;<br>}</p>
<p>//<br>// 函数: MyRegisterClass()<br>//<br>// 目的: 注册窗口类。<br>//<br>// 注释:<br>//<br>//&nbsp;&nbsp;&nbsp; 仅当希望<br>//&nbsp;&nbsp;&nbsp; 此代码与添加到 Windows 95 中的“RegisterClassEx”<br>//&nbsp;&nbsp;&nbsp; 函数之前的 Win32 系统兼容时，才需要此函数及其用法。调用此函数十分重要，<br>//&nbsp;&nbsp;&nbsp; 这样应用程序就可以获得关联的<br>//&nbsp;&nbsp;&nbsp; “格式正确的”小图标。<br>//<br>ATOM MyRegisterClass(HINSTANCE hInstance)<br>{<br>WNDCLASSEX wcex;</p>
<p>wcex.cbSize = sizeof(WNDCLASSEX);</p>
<p>wcex.style&nbsp;&nbsp;&nbsp; = CS_HREDRAW | CS_VREDRAW|CS_OWNDC;<br>wcex.lpfnWndProc = WndProc;<br>wcex.cbClsExtra&nbsp;&nbsp; = 0;<br>wcex.cbWndExtra&nbsp;&nbsp; = 0;<br>wcex.hInstance&nbsp;&nbsp; = hInstance;<br>wcex.hIcon&nbsp;&nbsp;&nbsp; = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_CAPTURING_IMAGE));<br>wcex.hCursor&nbsp;&nbsp; = LoadCursor(NULL, IDC_ARROW);<br>wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);<br>wcex.lpszMenuName = MAKEINTRESOURCE(IDC_CAPTURING_IMAGE);<br>wcex.lpszClassName = szWindowClass;<br>wcex.hIconSm&nbsp;&nbsp; = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_SMALL));</p>
<p>return RegisterClassEx(&amp;wcex);<br>}</p>
<p>//<br>//&nbsp;&nbsp; 函数: InitInstance(HINSTANCE, int)<br>//<br>//&nbsp;&nbsp; 目的: 保存实例句柄并创建主窗口<br>//<br>//&nbsp;&nbsp; 注释:<br>//<br>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在此函数中，我们在全局变量中保存实例句柄并<br>//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 创建和显示主程序窗口。<br>//<br>BOOL InitInstance(HINSTANCE hInstance, int nCmdShow)<br>{<br>&nbsp;&nbsp; HWND hWnd;</p>
<p>&nbsp;&nbsp; hInst = hInstance; // 将实例句柄存储在全局变量中</p>
<p>&nbsp;&nbsp; hWnd = CreateWindow(szWindowClass, szTitle, WS_OVERLAPPEDWINDOW,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);</p>
<p>&nbsp;&nbsp; if (!hWnd)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return FALSE;<br>&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp; ShowWindow(hWnd, nCmdShow);<br>&nbsp;&nbsp; UpdateWindow(hWnd);</p>
<p>&nbsp;&nbsp; return TRUE;<br>}</p>
<p>//<br>// 函数: WndProc(HWND, UINT, WPARAM, LPARAM)<br>//<br>// 目的: 处理主窗口的消息。<br>//<br>// WM_COMMAND - 处理应用程序菜单<br>// WM_PAINT - 绘制主窗口<br>// WM_DESTROY - 发送退出消息并返回<br>//<br>//<br>LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)<br>{<br>int wmId, wmEvent;<br>PAINTSTRUCT ps;<br>HDC hdc=NULL;<br>switch (message)<br>{<br>case WM_COMMAND:<br>&nbsp;&nbsp; wmId&nbsp;&nbsp;&nbsp; = LOWORD(wParam);<br>&nbsp;&nbsp; wmEvent = HIWORD(wParam);<br>&nbsp;&nbsp; // 分析菜单选择:<br>&nbsp;&nbsp; switch (wmId)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp; case IDM_CAPTUR:<br>&nbsp;&nbsp;&nbsp;&nbsp; CaptureScreen(hWnd,hdc);<br>&nbsp;&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp; case IDM_ABOUT:<br>&nbsp;&nbsp;&nbsp; DialogBox(hInst, MAKEINTRESOURCE(IDD_ABOUTBOX), hWnd, About);<br>&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp; case IDM_EXIT:<br>&nbsp;&nbsp;&nbsp; DestroyWindow(hWnd);<br>&nbsp;&nbsp;&nbsp; break;<br>&nbsp;&nbsp; default:<br>&nbsp;&nbsp;&nbsp; return DefWindowProc(hWnd, message, wParam, lParam);<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; break;<br>case WM_PAINT:<br>&nbsp;&nbsp; hdc = BeginPaint(hWnd, &amp;ps);<br>&nbsp;&nbsp; // TODO: 在此添加任意绘图代码…<br>&nbsp;&nbsp; CaptureScreen(hWnd,hdc);<br>&nbsp;&nbsp; EndPaint(hWnd, &amp;ps);<br>&nbsp;&nbsp; break;<br>case WM_DESTROY:<br>&nbsp;&nbsp; PostQuitMessage(0);<br>&nbsp;&nbsp; break;<br>default:<br>&nbsp;&nbsp; return DefWindowProc(hWnd, message, wParam, lParam);<br>}<br>return 0;<br>}</p>
<p>// “关于”框的消息处理程序。<br>INT_PTR CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)<br>{<br>UNREFERENCED_PARAMETER(lParam);<br>switch (message)<br>{<br>case WM_INITDIALOG:<br>&nbsp;&nbsp; return (INT_PTR)TRUE;</p>
<p>case WM_COMMAND:<br>&nbsp;&nbsp; if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL)<br>&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp; EndDialog(hDlg, LOWORD(wParam));<br>&nbsp;&nbsp;&nbsp; return (INT_PTR)TRUE;<br>&nbsp;&nbsp; }<br>&nbsp;&nbsp; break;<br>}<br>return (INT_PTR)FALSE;<br>}</p>
<p>void CaptureScreen(HWND hWnd,HDC hdc)<br>{<br>hdc=GetDC(hWnd);<br>RECT clientRect;<br>GetClientRect(hWnd,&amp;clientRect);</p>
<p>HDC hdcScreen;<br>HDC hdcCompatible;<br>HBITMAP hbmScreen;<br>// 创建一个普通的包含整个显示器屏幕的设备描述表和一个与之兼容<br>// 的内存设备描述表，普通的设备描述表提供一个屏幕内容的快照<br>// 内存设备描述表将该快照的一份拷贝与一个bitmap相连，但是该bitmap<br>//的表面显示的是一个单色的一个像素的bitmap，因此应该选入一个何时的<br>//bitmap到该内存设备描述表<br>//以下摘自MSDN<br>//A memory DC exists only in memory. When the memory DC is created,its display<br>//surface is exactly one monochrome pixel wide and one monochrome pixel high.<br>//Before an application can use a memory DC for drawing operations, it must select a<br>//bitmap of the correct width and height into the DC.</p>
<p>hdcScreen = CreateDC(“DISPLAY”, NULL, NULL, NULL);<br>hdcCompatible = CreateCompatibleDC(hdcScreen);</p>
<p>// 创建一个与屏幕设备描述表相兼容的bitmap，然后将其选入先前创建的<br>// 内存设备描述表<br>&nbsp;&nbsp;&nbsp;&nbsp;<br>hbmScreen = CreateCompatibleBitmap(hdcScreen,<br>&nbsp;&nbsp;&nbsp; GetDeviceCaps(hdcScreen, HORZRES),<br>&nbsp;&nbsp;&nbsp; GetDeviceCaps(hdcScreen, VERTRES)); </p>
<p>if (hbmScreen == 0)<br>MessageBox(hWnd,”hbmScreen”,”错误”,MB_OK); </p>
<p>if (!SelectObject(hdcCompatible, hbmScreen))<br>MessageBox(hWnd,”Compatible Bitmap Selection”, “错误”,MB_OK); </p>
<p>//将与屏幕设备描述表相关的颜色信息拷贝到内存设备描述表相关<br>if (!BitBlt(hdcCompatible,<br>0,0,<br>GetDeviceCaps(hdcScreen, HORZRES),GetDeviceCaps(hdcScreen, VERTRES),<br>hdcScreen,<br>0,0,<br>SRCCOPY))<br>MessageBox(hWnd,”Screen to Compat Blt Failed”,”错误”,MB_OK);</p>
<p>StretchBlt(hdc,<br>&nbsp;&nbsp;&nbsp; 0, 0,<br>&nbsp;&nbsp;&nbsp; clientRect.right-clientRect.left, clientRect.bottom-clientRect.top,<br>&nbsp;&nbsp;&nbsp; hdcCompatible,<br>&nbsp;&nbsp;&nbsp; 0, 0,<br>&nbsp;&nbsp;&nbsp; GetDeviceCaps(hdcScreen, HORZRES), GetDeviceCaps(hdcScreen, VERTRES),<br>&nbsp;&nbsp;&nbsp; SRCCOPY); </p>
<p>if (OpenClipboard(hWnd))<br>&nbsp;&nbsp;&nbsp;&nbsp; //hWnd为程序窗口句柄<br>&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //清空剪贴板<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EmptyClipboard();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //把屏幕内容粘贴到剪贴板上,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SetClipboardData(CF_BITMAP, hbmScreen);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //关闭剪贴板<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CloseClipboard();<br>&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>DeleteObject(hbmScreen);<br>DeleteDC(hdcCompatible);<br>DeleteDC(hdcScreen);<br>ReleaseDC(hWnd,hdc);<br>}</p>
<p>附上一个截图：</p>
<p><img src="http://blog.programfan.com/upfile/200708/20070818012327.gif" alt=""></p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/07/26/关于虚函数表的一点内容/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/07/26/关于虚函数表的一点内容/" itemprop="url">关于虚函数表的一点内容</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-07-26T18:21:00+08:00">
                2007-07-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;TABLE style=&quot;TABLE-LAYOUT: fixed&quot;&gt;
</code></pre><p><tbody></tbody></p>
<p><tr></tr></p>
<p><td></td></p>
<p><div class="cnt" id="blog_text">还是用图表和代码能说明内容： </div></p>
<p>#include &lt;iostream&gt;<br>using std::cout;<br>using std::endl;</p>
<p>class Base<br>{<br>public: //为了便于取地址<br>&nbsp;&nbsp;&nbsp; int m_data1;<br>&nbsp;&nbsp;&nbsp; int m_data2;<br>&nbsp;&nbsp;&nbsp; int m_data3;<br>public:<br>&nbsp;&nbsp;&nbsp; void mem_fun1();<br>&nbsp;&nbsp;&nbsp; void mem_fun2();<br>&nbsp;&nbsp;&nbsp; //注意虽然后面没用到这些虚函数 ，但是要使程序可以编译通过<br>&nbsp;&nbsp;&nbsp; //需要实现他们，因为建立vtable会出错<br>&nbsp;&nbsp;&nbsp; virtual void vir_fun1(){}<br>&nbsp;&nbsp;&nbsp; virtual void vir_fun2(){}<br>};&nbsp;&nbsp;&nbsp;</p>
<p>class Derive:public Base<br>{<br>public://为了便于取地址<br>&nbsp;&nbsp;&nbsp; int m_data1;<br>&nbsp;&nbsp;&nbsp; int m_data3;<br>&nbsp;&nbsp;&nbsp; int m_data4;<br>public:<br>&nbsp;&nbsp; void mem_fun1();<br>&nbsp;&nbsp;&nbsp; virtual void vir_fun2(){}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>};</p>
<p>int main()<br>{<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;”sizeof(Base)=&gt; “&lt;&lt;sizeof(Base)&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;”sizeof(Derive)=&gt; “&lt;&lt;sizeof(Derive)&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; Base b;<br>&nbsp;&nbsp;&nbsp; Derive d;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;”Address of b=&gt; “&lt;&lt;&amp;b&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;”Address of b.m_data1=&gt; “&lt;&lt;&amp;(b.m_data1)&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;”Address of b.m_data2=&gt; “&lt;&lt;&amp;(b.m_data2)&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;”Address of b.m_data3=&gt; “&lt;&lt;&amp;(b.m_data3)&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;”Address of d=&gt; “&lt;&lt;&amp;d&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;”Address of d.m_data1=&gt; “&lt;&lt;&amp;(d.m_data1)&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;”Address of d.Base::m_data2=&gt; “&lt;&lt;&amp;(d.Base::m_data2)&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;”Address of d.Base::m_data3=&gt; “&lt;&lt;&amp;(d.Base::m_data3)&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;”Address of d.m_data3=&gt;”&lt;&lt;&amp;(d.m_data3)&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp; cout&lt;&lt;”Address of d.m_data4=&gt;”&lt;&lt;&amp;(d.m_data4)&lt;&lt;endl;<br>&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp; system(“pause”);<br>&nbsp;&nbsp;&nbsp; return 0;<br>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p>运行结果如图：</p>
<p><img src="http://blog.programfan.com/upfile/200707/2007072600344.gif" alt=""></p>
<p>基类的大小为16是因为，三个int变量加上一个vptr，对应的Derive的大小就是在此基础上加三个int的大小，各数据成员的地址很清晰，也可以反映对象在内存中的存放情况。</p>
<p>下面两幅图是对象的内存模拟表示，看图应该就很清楚了：</p>
<p><img src="http://blog.programfan.com/upfile/200707/20070726003415.gif" alt=""></p>
<p><img src="http://blog.programfan.com/upfile/200707/2007072600349.gif" alt=""><br><br></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/07/24/mfc的一点感悟/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/07/24/mfc的一点感悟/" itemprop="url">MFC的一点感悟</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-07-24T18:32:00+08:00">
                2007-07-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><font size="2">学习MFC的时间不长，但是感觉开始学习的方法不对，只知道随便摆摆几个控件然后想怎么把个控件弄漂亮点（不停的在网上下别人写的控件，但是看不懂），而忽视了基础的重要性，比如说MFC和API之间的关系，消息映射机制的实现，Windows窗口对象和CWnd的C++对象之间的联系等等。</font></strong></p>
<p><strong><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这样学习的结果可想而知，只懂皮毛，只会用ClassWizard弄点简单的小程序，遇到稍微需要自己写代码的地方就不知从何写起了。因此曾一度决定放弃MFC的，觉得这种编程方式太麻烦了，尤其是写UI时，自我觉得还是对JAVA，QT那种写界面的方式好接受点，知道自己写了哪些东西以及怎么写的。</font></strong></p>
<p><strong><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 前几天在网上发现一在线教程，感觉写得还蛮好的，比起那些各式各样的VC的书讲得好多了，尤其是当我看完消息映射后，发现这个对我真是受益匪浅，再结合源码看看，有些以前难以理解的东西现在觉得有点眉目了，还开始感叹写MFC那些人的技术之精，能写出如此庞大（看到网上有些人觉得MFC太臃肿，我暂时可能还没有发现这个的能力），效率又高的库真是不简单，觉得学习C++面向对象的思想，MFC源码是个不错的东东。</font></strong></p>
<p><strong><font size="2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 想把自己现在对MFC的一些基础部分整理一个小的系列文章，:-)，当然绝大部分内容都是网上的，我可能只是修改一些错误的地方，可惜现在时间不是很多，尽力了，也算是对自己学习MFC的一点点初级的总结吧！</font></strong></p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/01/21/最简单的mfc程序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/01/21/最简单的mfc程序/" itemprop="url">最简单的MFC程序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-01-21T18:31:00+08:00">
                2007-01-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;TABLE style=&quot;TABLE-LAYOUT: fixed&quot;&gt;
</code></pre><p><tbody></tbody></p>
<p><tr></tr></p>
<p><td></td></p>
<p><div class="cnt" id="blog_text"></div></p>
<div>

<p>#include &lt;afxwin.h&gt;</p>
<p>//定义一个CWinApp的派生类<br>class CMinApp:public CWinApp<br>{<br>public:<br>virtual BOOL InitInstance();<br>};<br>//重载CWinApp成员函数InitInstance()<br>BOOL CMinApp::InitInstance()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //应用程序初始化<br>{<br>CFrameWnd* pFrame=new CFrameWnd;&nbsp;&nbsp;&nbsp;&nbsp; //动态生成主窗口类对象<br>pFrame-&gt;Create(0,_T(“A Minimal MFC Program”)); //创建主窗口<br>pFrame-&gt;ShowWindow(SW_SHOWMAXIMIZED); //显示主窗口<br>pFrame-&gt;UpdateWindow();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //刷新主窗口<br>AfxGetApp()-&gt;m_pMainWnd=pFrame;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //指定应用程序主窗口<br>return TRUE;<br>}</p>
<p>//定义一个全局CMinApp对象<br>CMinApp HelloApp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; //生成应用程序对象并执行应用程序</p>
<p>在程序的一开始由CWinApp派生的一个自己的类CMinApp。这个类利用CWinApp中的虚拟初始化函数，改写成自己的初始化函数。在这个初始化函数中动态地建立了CFrameWnd类实例，用来定义窗口和显示窗口。而CWinApp自身去完成建立消息循环的工作，在这个小例子中没有处理消息。上述工作实际上还停留在定义上，程序的运行只有最后一句话，派生类CMinApp的实例化。</p>
<p>在MFC变成结构中CWinApp相当于WinMain()函数，其中的InitInstance函数是MFC应用程序的入口点，且它是可以重载的，可以应用它编写自己应用程序的初始化。InitInstance函数完成以下工作：</p>
<p>1：定义框架窗口对CFrameWnd作为应用程序的主窗口</p>
<p>2：显示主窗口</p>
<p>3：建立局部窗口与应用程序对象的关系</p>
<p>声明应用程序对象时，应用程序自动运行，因为类的构造器调用了run()函数，在run()中建立消息循环</p>
<p>CFrameWnd类负责窗口的创建和显示</p>
<p>从上面的例子中可以看出MFC程序至少要有两个对象，应用对象和主框架对象，在MFC应用程序中需要定义一个单独的全局应用程序对象。类CFrameWnd的对象代表中应用程序的主框架窗口。主框架窗口的创建和显示工作由CMinApp的成员函数InitInstance完成，在应用程序中必须重载该函数，因为CWinApp基类根本无法知道具体应用程序需要什么样的主框架窗口。应用程序运行开始时，Windows会自动调用应用程序框架内部的WinMain函数（在MFC应用程序中仍然存在WinMain函数作为程序的入口，只不过它被隐藏在应用程序内部了）WinMain函数会去查找应用程序的全局构造对象，然后调用InitInstance函数以进行必要的初始化，接着调用隐藏在CWinApp基类中的函数Run(),应用程序进入运行状态。用户可以通过关闭主窗口来终止应用程序，这一操作会引起一系列事件的发生，首先CFrameWnd对象将被删除，然后退出WinMain,最后删除CMinApp对象。<br></p></div><br><p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/14/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/16/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">billowqiu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">156</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/billowqiu" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:billowqiu@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">billowqiu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
