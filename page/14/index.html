<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="taocoding">
<meta property="og:url" content="http://yoursite.com/page/14/index.html">
<meta property="og:site_name" content="taocoding">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="taocoding">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/14/">





  <title>taocoding</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d13234060d812cb98a47e937139083a9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">taocoding</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/05/07/内存设备环境/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2008/05/07/内存设备环境/" itemprop="url">内存设备环境</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-05-07T16:12:00+08:00">
                2008-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">通过使用一个特别为位图操作的设备环境，可以使得应用程序将输出操作在内存中而不是将其发送到实际的设备中。内存设备环境使得系统将一部分内存当作虚拟设备。它就是一个在内存中的位数组，使得应用程序可以使用它为在一个标准的绘图表面创建位图临时存储颜色数据。由于位图是和设备兼容的，因此内存设备环境在某些时候也就当作兼容设备环境。</font> </span><span style="FONT-SIZE: 12pt; mso-spacerun: yes"></span>

<span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">内存设备环境作为一个特殊的环境存储位图图像。应用程序可以调用</font> </span><span><a href="ms-help://MS.MSDNQTR.v80.chs/MS.MSDN.v80/MS.WIN32COM.v10.en/gdi/devcons_499f.htm" target="_blank" rel="noopener"><font color="#0000ff"><span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt; TEXT-DECORATION: underline; mso-spacerun: yes">CreateCompatibleDC</span><u> </u></font></a></span><span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">创建一个内存设备环境。</font> </span>

<span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">内存设备环境中初始的位图只是一个简单的占位符。它的尺寸为1*1像素。在应用程序进行绘制之前，必须通过调用</font> </span><span><a href="ms-help://MS.MSDNQTR.v80.chs/MS.MSDN.v80/MS.WIN32COM.v10.en/gdi/devcons_9v3o.htm" target="_blank" rel="noopener"><font color="#0000ff"><span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt; TEXT-DECORATION: underline; mso-spacerun: yes">SelectObject</span><u> </u></font></a></span><span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">选择一个恰当宽度和高度的位图到该内存环境中。要创建一个恰当尺寸的位图，可以使用</font> </span><span><a href="ms-help://MS.MSDNQTR.v80.chs/MS.MSDN.v80/MS.WIN32COM.v10.en/gdi/bitmaps_3ak0.htm" target="_blank" rel="noopener"><font color="#0000ff"><span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt; TEXT-DECORATION: underline; mso-spacerun: yes">CreateBitmap</span><u> </u></font></a></span><span style="FONT-SIZE: 12pt; mso-spacerun: yes">, </span><span><a href="ms-help://MS.MSDNQTR.v80.chs/MS.MSDN.v80/MS.WIN32COM.v10.en/gdi/bitmaps_6r04.htm" target="_blank" rel="noopener"><font color="#0000ff"><span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt; TEXT-DECORATION: underline; mso-spacerun: yes">CreateBitmapIndirect</span><u> </u></font></a></span><span style="FONT-SIZE: 12pt; mso-spacerun: yes">, or </span><span><a href="ms-help://MS.MSDNQTR.v80.chs/MS.MSDN.v80/MS.WIN32COM.v10.en/gdi/bitmaps_1cxc.htm" target="_blank" rel="noopener"><font color="#0000ff"><span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt; TEXT-DECORATION: underline; mso-spacerun: yes">CreateCompatibleBitmap</span><u> </u></font></a></span><span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">三个函数。当位图被选进内存设备环境后，系统用一个足够大的数组取代单位数组来存储指定的矩形像素的颜色信息。</font> </span><span style="FONT-SIZE: 12pt; mso-spacerun: yes"></span>

<span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">当应用程序传递一个由</font> </span><span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt; mso-spacerun: yes">CreateCompatibleDC</span> <span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">返回的句柄到绘制函数时，被要求的输出并不会在设备的绘制表面显示。相反，系统会存储线段，曲线，文字或者区域的颜色信息到位数组中。应用程序可以复制存储在内存中的图像到绘制表面通过调用</font> </span><span><a href="ms-help://MS.MSDNQTR.v80.chs/MS.MSDN.v80/MS.WIN32COM.v10.en/gdi/bitmaps_0fzo.htm" target="_blank" rel="noopener"><font color="#0000ff"><span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt; TEXT-DECORATION: underline; mso-spacerun: yes">BitBlt</span><u> </u></font></a></span><span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">函数，并将内存设备环境作为源设备环境，窗口或者屏幕设备环境作为目标设备环境。</font> </span>

<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/04/24/模板代替虚函数实现多态/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2008/04/24/模板代替虚函数实现多态/" itemprop="url">模板代替虚函数实现多态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-04-24T13:05:00+08:00">
                2008-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;TABLE style=&quot;TABLE-LAYOUT: fixed&quot;&gt;
</code></pre><p><tbody></tbody></p>
<p><tr></tr></p>
<p><td></td></p>
<div class="cnt" id="blog_text">

<p>虚函数和继承的实现：</p>
<p>class File {<br>&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void Open() = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void Save() = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void SaveAS(String&amp;) = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void Close() = 0;<br>};<br>class TextFile:public File{<br>&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Open();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Save();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void SaveAS(String&amp;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Close();<br>};<br>class ImageFile:public File{<br>&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Open();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Save();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void SaveAS(String&amp;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Close();<br>};</p>
<p>// user menu selection to open the file<br>void menu_open_file(File<em> f_ptr){<br>&nbsp;&nbsp; f_ptr-&gt;Open();<br>&nbsp;&nbsp; ….<br>&nbsp;&nbsp; …<br>}<br>By using the above code, you would have the following:<br>File </em>file_ptr = new TextFile();<br>menu_open_file(file_ptr);//open the text file<br>.<br>.<br>file_ptr = new ImageFile();<br>menu_open_file(file_ptr);//open the image file</p>
<p>模板的实现：</p>
<p>class TextFile{<br>public:<br>&nbsp;&nbsp; void Open();<br>};</p>
<p>class ImageFile{<br>public:<br>void Open();<br>};</p>
<p>//user menu selection to open the file</p>
<p>template&lt;typename T&gt; void menu_open_file(T file){<br>&nbsp;&nbsp; file.Open();<br>}<br>Using the code:<br>TextFile txt_file;<br>ImageFile img_file;<br>menu_open_file(txt_file);&nbsp;&nbsp;&nbsp; //open the text file<br>menu_open_file(img_file);&nbsp;&nbsp;&nbsp; //open the image file<br></p></div><br><p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/04/13/stl介绍/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2008/04/13/stl介绍/" itemprop="url">STL介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-04-13T15:36:00+08:00">
                2008-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>翻译的一篇SGI STL文档还要好多不太会翻译，以后在慢慢领悟吧！</p>
<h1 id="Introduction-to-the-Standard-Template-Library"><a href="#Introduction-to-the-Standard-Template-Library" class="headerlink" title="Introduction to the Standard Template Library"></a><span><font face="宋体">Introduction to the Standard Template Library</font></span></h1><h1 id="标准模板库简介"><a href="#标准模板库简介" class="headerlink" title="标准模板库简介"></a><font face="宋体">标准模板库简介</font></h1><span><font face="宋体" size="3">The Standard Template Library, or <em>STL</em>, is a C++ library of container classes, algorithms, and iterators; it provides many of the basic algorithms and data structures of computer science. The STL is a <em>generic</em> library, meaning that its components are heavily parameterized: almost every component in the STL is a template. You should make sure that you understand how templates work in C++ before you use the STL.</font></span>

<font face="宋体" size="3">标准模板库，或<span>STL</span>，是一个包括容器类，算法和迭代器的<span>C++</span>库；它提供了许多计算机的基本算法和数据结构。<span>STL</span>是一个泛型库，这意味这它是由很深的参数机制实现的：几乎每一个<span>STL</span>的组件都是模板。你在使用<span>STL</span>之前应该确信你已经懂得了<span>C++</span>的模板。</font>

<h2 id="Containers-and-algorithms"><a href="#Containers-and-algorithms" class="headerlink" title="Containers and algorithms"></a><span><font face="宋体">Containers and algorithms</font></span></h2><h2 id="容器和算法"><a href="#容器和算法" class="headerlink" title="容器和算法"></a><font face="宋体">容器和算法</font></h2><span><font face="宋体" size="3">Like many class libraries, the STL includes <em>container</em> classes: classes whose purpose is to contain other objects. The STL includes the classes <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Vector.html" target="_blank" rel="noopener"><font color="#0000ee"><u>vector</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/List.html" target="_blank" rel="noopener"><font color="#0000ee"><u>list</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Deque.html" target="_blank" rel="noopener"><font color="#0000ee"><u>deque</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/set.html" target="_blank" rel="noopener"><font color="#0000ee"><u>set</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/multiset.html" target="_blank" rel="noopener"><font color="#0000ee"><u>multiset</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Map.html" target="_blank" rel="noopener"><font color="#0000ee"><u>map</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Multimap.html" target="_blank" rel="noopener"><font color="#0000ee"><u>multimap</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_set.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_set</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_multiset.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_multiset</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_map.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_map</u></font></a></tt>, and <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_multimap.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_multimap</u></font></a></tt>. Each of these classes is a template, and can be instantiated to contain any type of object. You can, for example, use a <tt>vector&lt;int&gt;</tt> in much the same way as you would use an ordinary C array, except that <tt>vector</tt> eliminates the chore of managing dynamic memory allocation by hand.</font></span>

<font face="宋体" size="3">像许多类库，<span>STL</span>包括容器类：用于包含其他类对象的类。<span>STL</span>包括的容器类有<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Vector.html" target="_blank" rel="noopener"><font color="#0000ee"><u>vector</u></font></a></span></tt><span>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/List.html" target="_blank" rel="noopener"><font color="#0000ee"><u>list</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Deque.html" target="_blank" rel="noopener"><font color="#0000ee"><u>deque</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/set.html" target="_blank" rel="noopener"><font color="#0000ee"><u>set</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/multiset.html" target="_blank" rel="noopener"><font color="#0000ee"><u>multiset</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Map.html" target="_blank" rel="noopener"><font color="#0000ee"><u>map</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Multimap.html" target="_blank" rel="noopener"><font color="#0000ee"><u>multimap</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_set.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_set</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_multiset.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_multiset</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_map.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_map</u></font></a></tt>,</span>和<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_multimap.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_multimap</u></font></a></span></tt>。每一个容器类都是模板，而且可以被实例化去包含任何类型的对象。例如你可以使用<span>vector&lt;int&gt;</span>像使用一个原生的<span>C</span>数组，出此之外<span>vector</span>还消除了一些手动动态内存管理的琐碎事情。</font><br><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>vector&lt;int&gt; v(3);<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>// Declare a vector of 3 elements.</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>v[0] = 7;</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>v[1] = v[0] + 3;</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>v[2] = v[0] + v[1];<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>// v[0] == 7, v[1] == 10, v[2] == 17<span style="mso-spacerun: yes">  </span></font></font></span></pre><pre><font size="3"><font face="宋体"><span><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>vector&lt;int&gt; v(3);<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>// </span>声明一个包含三个元素的<span>vector.</span></font></font></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>v[0] = 7;</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>v[1] = v[0] + 3;</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>v[2] = v[0] + v[1];<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>// v[0] == 7, v[1] == 10, v[2] == 17<span style="mso-spacerun: yes">  </span></font></font></span></pre><pre><span><font face="宋体" size="3"> </font></span></pre><br><br><span><font face="宋体" size="3">The STL also includes a large collection of <em>algorithms</em> that manipulate the data stored in containers. You can reverse the order of elements in a <tt>vector</tt>, for example, by using the <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></tt> algorithm. </font></span><br><br><font size="3"><font face="宋体"><span>STL</span>也包括一个很大的算法集合用于处理存储在容器的数据。例如你可以通过使用<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>算法</tt>倒序保存在<span>vector</span>中的元素。</font></font><br><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>reverse(v.begin(), v.end()); // v[0] == 17, v[1] == 10, v[2] == 7</font></font></span></pre><br><br><span><font size="3"><font face="宋体">There are two important points to notice about this call to <tt>reverse</tt>. First, it is a global function, not a member function. Second, it takes two arguments rather than one: it operates on a <em>range</em> of elements, rather than on a container. In this particular case the range happens to be the entire container <tt>v.</tt></font></font></span><br><br><font face="宋体" size="3">在使用<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>时</tt>有两个重要点值得注意<span>,</span>第一点是它是一个全局函数，而不是一个成员函数；第二点是它包括两个参数而不是一个参数，容器元素的边界而不是容器。在我们这个例子中，边界即为整个容器。</font>

<span><font face="宋体" size="3">The reason for both of these facts is the same: <tt>reverse</tt>, like other STL algorithms, is decoupled from the STL container classes. This means that <tt>reverse</tt> can be used not only to reverse elements in vectors, but also to reverse elements in lists, and even elements in C arrays. The following program is also valid.</font></span>

<font size="3"><font face="宋体">这两点其实是一样的：<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>，像其他的<span>STL</span>算法，是与<span>STL</span>容器类，这意味这<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>不仅可以用于倒序<span>vectors</span>中的元素，还可以用于<span>lists</span>，甚至用于<span>C</span>数组。下面的程序是合法的。</tt></font></font><br><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>double A[6] = { 1.2, 1.3, 1.4, 1.5, 1.6, 1.7 };</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>reverse(A, A + 6);</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>for (int i = 0; i &lt; 6; ++i)</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>cout &lt;&lt; “A[“ &lt;&lt; i &lt;&lt; “] = “ &lt;&lt; A[i];</font></font></span></pre><br><br><span><font face="宋体" size="3">This example uses a <em>range</em>, just like the example of reversing a <tt>vector</tt>: the first argument to reverse is a pointer to the beginning of the range, and the second argument points one element past the end of the range. This range is denoted <tt>[A, A + 6)</tt>; the asymmetrical notation is a reminder that the two endpoints are different, that the first is the beginning of the range and the second is <em>one past</em> the end of the range. </font></span><br><br><font face="宋体" size="3">这个例子中使用的区间，就像在倒序<span>vector</span>中使用的：第一个参数是指向倒序的区间的开始，第二个参数是指向超过区间的第一个元素。这个区间表示的是<span>[A</span>，<span>A+6],</span>非对称的符号提示两点区间端点是不同的，第一个端点是区间的起始点，第二个是超过区间的第一个点。</font>

<h2 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a><span><font face="宋体">Iterators</font></span></h2><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a><font face="宋体">迭代器</font></h2><span><font face="宋体" size="3">In the example of reversing a C array, the arguments to <tt>reverse</tt> are clearly of type <tt>double*</tt>. What are the arguments to reverse if you are reversing a <tt>vector</tt>, though, or a <tt>list</tt>? That is, what exactly does <tt>reverse</tt> declare its arguments to be, and what exactly do <tt>v.begin()</tt> and <tt>v.end()</tt> return? </font></span>

<font size="3"><font face="宋体">在倒序<span>C</span>数组的例子中，传递给<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>的参数比较清晰就是<span>double*</span>。那么当你倒序一个<span>vector</span>或者<span>list</span>时传递给<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>的参数是什么呢？也就是，<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>声明的参数类型到底是什么，<span>v.begin()</span>和<span>v.end()</span>返回的是什么呢？</tt></font></font>

<span><font face="宋体" size="3">The answer is that the arguments to <tt>reverse</tt> are <em>iterators</em>, which are a generalization of pointers. Pointers themselves are iterators, which is why it is possible to reverse the elements of a C array. Similarly, <tt>vector</tt> declares the nested types <tt>iterator</tt> and <tt>const_iterator</tt>. In the example above, the type returned by <tt>v.begin()</tt> and <tt>v.end()</tt> is <tt>vector&lt;int&gt;::iterator</tt>. There are also some iterators, such as <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/istream_iterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>istream_iterator</u></font></a></tt> and <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/ostream_iterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>ostream_iterator</u></font></a></tt>, that aren’t associated with containers at all. </font></span>

<font size="3"><font face="宋体">答案是传递给<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>的参数是迭代器，一个泛型指针。指向它们自己的是迭代器，为什么可以倒序<span>C</span>数组中的元素呢。类似地，<span>vector</span>声明了内嵌类型的<span>iterator</span></tt><span> and <tt>const_iterator</tt></span>。在上面的例子中，<tt><span>v.begin()</span></tt>和<tt><span>v.end()</span>返回的类型是<span>vector&lt;int&gt;::iterator</span>。还有一些其他的迭代器，比如<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/istream_iterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>istream_iterator</u></font></a></span></tt>和<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/ostream_iterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>ostream_iterator</u></font></a></span>，它们并没有和容器相关联。</tt></font></font>

<span><font face="宋体" size="3">Iterators are the mechanism that makes it possible to decouple algorithms from containers: algorithms are templates, and are parameterized by the type of iterator, so they are not restricted to a single type of container. Consider, for example, how to write an algorithm that performs linear search through a range. This is the STL’s <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></tt> algorithm. </font></span>

<font size="3"><font face="宋体">迭代器是一种使得算法与容器分离的机制：算法是模板，被迭代器的类型参数化，所以他们没有限制非要在一个单独类型的容器上。考虑这样一个例子，怎么写一个算法实现在一个区间上线性查找。<span>STL</span>的<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></span>即是这样的算法：<span></span></tt></font></font>

<span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>template &lt;class InputIterator, class T&gt;</font></font></span><br><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>InputIterator find(InputIterator first, InputIterator last, const T&amp; value) {</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>while (first != last &amp;&amp; <em>first != value) ++first;</em></font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>return first;</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>}</font></font></span></pre><pre><tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font face="宋体" color="#0000ee" size="3"><u>find</u></font></a></span><font face="宋体" size="3">要求三个参数：两个迭代器定义了一个区间，一个<span>value</span>用于在区间中查找。它在区间<span>[first,last)</span>中检查每一个迭代器，从开始到结束，在找到一个指向<span>value</span>的迭代器或者到达区间尾时停止。</font></tt></pre><br><br><font size="3"><font face="宋体"><tt><span>Find</span></tt><span> takes three arguments: two iterators that define a range, and a value to search for in that range. It examines each iterator in the range <tt>[first, last)</tt>, proceeding from the beginning to the end, and stops either when it finds an iterator that points to <tt>value</tt> or when it reaches the end of the range. </span></font></font><br><br><font size="3"><font face="宋体"><tt><span>First</span></tt><span> and <tt>last</tt> are declared to be of type <tt>InputIterator</tt>, and <tt>InputIterator</tt> is a template parameter. That is, there isn’t actually any type called <tt>InputIterator</tt>: when you call <tt>find</tt>, the compiler substitutes the actual type of the arguments for the formal type parameters <tt>InputIterator</tt> and <tt>T</tt>. If the first two arguments to <tt>find</tt> are of type <tt>int</tt> and the third is of type <tt>int</tt>, then it is as if you had called the following function.</span></font></font><br><br><font size="3"><font face="宋体"><span>First</span>和<span>last</span>被声明为<span>InputIterator</span>类型，是一个模板参数类型。实际上并没有叫做<span>InputItearot</span>的类型：当你调用<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></span>时，编译器会用实参类型替换型参<span>InputIteartor</span>和<span>T</span>。假如传递给<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></span>的前面两个参数是<span>int<em></em></span>，第三个参数是<span>int</span>的话，实际上你调用的函数是下面这样的：</tt></font></font><br><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>int find(int<em> first, int</em> last, const int&amp; value) {</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>while (first != last &amp;&amp; *first != value) ++first;</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>return first;</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>}</font></font></span></pre><br><br>## <span><font face="宋体">Concepts and Modeling</font></span>

<h2 id="概念和模型"><a href="#概念和模型" class="headerlink" title="概念和模型"></a><font face="宋体">概念和模型</font></h2><span><font face="宋体" size="3">One very important question to ask about any template function, not just about STL algorithms, is what the set of types is that may correctly be substituted for the formal template parameters. Clearly, for example, <tt>int<em></em></tt> or <tt>double</tt> may be substituted for <tt>find</tt>‘s formal template parameter <tt>InputIterator</tt>. Equally clearly, <tt>int</tt> or <tt>double</tt> may not: <tt>find</tt> uses the expression <tt>*first</tt>, and the dereference operator makes no sense for an object of type <tt>int</tt> or of type <tt>double</tt>. The basic answer, then, is that <tt>find</tt> implicitly defines a set of requirements on types, and that it may be instantiated with any type that satisfies those requirements. Whatever type is substituted for <tt>InputIterator</tt> must provide certain operations: it must be possible to compare two objects of that type for equality, it must be possible to increment an object of that type, it must be possible to dereference an object of that type to obtain the object that it points to, and so on. </font></span>

<font size="3"><font face="宋体">一个关于模板函数的非常重要的问题，不仅仅是<span>STL</span>算法，是正确的替换形式模板参。明显地，例如，<span>int<em></em></span>和<span>double</span>也许会替换<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></span>的形式模板参数<span>Input-</span></tt></font></font>

<tt><font size="3"><font face="宋体"><span>Iterato</span>。同样地，<span>int</span>或者<span>double</span>也许不会：<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></span>使用表达式<span>*first</span>，解引用运算符对一个<span>int</span>或者<span>double</span>类型没有任何意义。一个简单的答案是，<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></span>也许显示定义了一个需求类型集合，它会这些参数能满足需求的时候被实例化（也就是不满足要求的会报错了）。能够替换<span>InputIterator</span>的参数必须提供能够以下操作：它必须可以比较两个类型是否相等，它必须可以自增，而且还可以解引用获得它指向的元素，等等。</font></font></tt>

<font size="3"><font face="宋体"><tt><span>Find</span></tt><span> isn’t the only STL algorithm that has such a set of requirements; the arguments to <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/for_each.html" target="_blank" rel="noopener"><font color="#0000ee"><u>for_each</u></font></a></tt> and <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/count.html" target="_blank" rel="noopener"><font color="#0000ee"><u>count</u></font></a></tt>, and other algorithms, must satisfy the same requirements. These requirements are sufficiently important that we give them a name: we call such a set of type requirements a <em>concept</em>, and we call this particular concept <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/InputIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Input Iterator</u></font></a></strong>. We say that a type <em>conforms to a concept</em>, or that it <em>is a model of a concept</em>, if it satisfies all of those requirements. We say that <tt>int<em></em></tt> is a model of <strong>Input Iterator</strong> because <tt>int</tt> provides all of the operations that are specified by the <strong>Input Iterator</strong> requirements. </span></font></font>

<font size="3"><font face="宋体"><span>STL</span>算法中并不是只要<span>Find</span>有这样的一个需求集合，<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/for_each.html" target="_blank" rel="noopener"><font color="#0000ee"><u>for_each</u></font></a></span></tt>和<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/count.html" target="_blank" rel="noopener"><font color="#0000ee"><u>count</u></font></a></span>的参数，还要其他的算法同样需要满足同样的要求。这些需求是足够重要的，我们给他们起个名字：我们称这样的类型需求集合为概念，这样一个特殊的概念叫做输入迭代器。我们称满足这样要求的概念为一个模型。<span>Int<em></em></span>是一个</tt><strong><span>Input Iterator</span></strong>因为<span>int</span>提供了所有<strong><span>Input Iterator</span></strong>要求的的操作。</font></font>

<span><font face="宋体" size="3">Concepts are not a part of the C++ language; there is no way to declare a concept in a program, or to declare that a particular type is a model of a concept. Nevertheless, concepts are an extremely important part of the STL. Using concepts makes it possible to write programs that cleanly separate interface from implementation: the author of <tt>find</tt> only has to consider the interface specified by the concept <strong>Input Iterator</strong>, rather than the implementation of every possible type that conforms to that concept. Similarly, if you want to use <tt>find</tt>, you need only to ensure that the arguments you pass to it are models of <strong>Input Iterator. </strong>This is the reason why <tt>find</tt> and <tt>reverse</tt> can be used with <tt>list</tt>s, <tt>vector</tt>s, C arrays, and many other types: programming in terms of concepts, rather than in terms of specific types, makes it possible to reuse software components and to combine components together. </font></span>

<h2 id="Refinement"><a href="#Refinement" class="headerlink" title="Refinement"></a><span><font face="宋体">Refinement</font></span></h2><h2 id="精巧"><a href="#精巧" class="headerlink" title="精巧"></a><font face="宋体">精巧</font></h2><font size="3"><font face="宋体"><strong><span>Input Iterator</span></strong><span> is, in fact, a rather weak concept: that is, it imposes very few requirements. An <strong>Input Iterator</strong> must support a subset of pointer arithmetic (it must be possible to increment an <strong>Input Iterator</strong> using prefix and postfix <tt>operator++</tt>), but need not support all operations of pointer arithmetic. This is sufficient for <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></tt>, but some other algorithms require that their arguments satisfy additional requirements. <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Reverse</u></font></a></tt>, for example, must be able to decrement its arguments as well as increment them; it uses the expression <tt>–last</tt>. In terms of concepts, we say that <tt>reverse</tt>‘s arguments must be models of <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/BidirectionalIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Bidirectional Iterator</u></font></a></strong> rather than <strong>Input Iterator</strong>. </span></font></font>

<font size="3"><font face="宋体"><strong><span>Input Iterator</span></strong>事实上是一个非常弱的概念：它强加了很少的要求。一个<strong><span>Input Iterator</span></strong>必须提供一个指针算术的子集（它必须可以去通过前缀或者后缀的<span>++</span>递增一个<strong><span>Input Iterator</span></strong>），但是不需要提供所以的指针运算。这些对于<span>find</span>来说已经足够了，但是其他的一些算法需要一些额外的要求。例如<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Reverse</u></font></a></span>必须可以通过<span>–</span>实现递减。按照概念的说法，我们说<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Reverse</u></font></a></span>的参数为</tt><strong><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/BidirectionalIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Bidirectional Iterator</u></font></a></span></strong>模型而非<strong><span>Input Iterator</span></strong>。</font></font>

<span><font face="宋体" size="3">The <strong>Bidirectional Iterator</strong> concept is very similar to the <strong>Input Iterator</strong> concept: it simply imposes some additional requirements. The types that are models of <strong>Bidirectional Iterator</strong> are a subset of the types that are models of<strong> Input Iterator</strong>: every type that is a model of <strong>Bidirectional Iterator</strong> is also a model of <strong>Input Iterator</strong>. <tt>Int*</tt>, for example, is both a model of <strong>Bidirectional Iterator</strong> and a model of <strong>Input Iterator</strong>, but <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/istream_iterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>istream_iterator</u></font></a></tt>, is only a model of <strong>Input Iterator</strong>: it does not conform to the more stringent <strong>Bidirectional Iterator</strong> requirements. </font></span>

<font size="3"><font face="宋体"><strong><span>Bidirectional Iterator</span></strong>的概念和<strong><span>Input Iterator</span></strong>非常相似<span>: </span>它仅仅加了一些额外的要求。<strong><span>Bidirectional Iterator</span></strong>的模型也是一个<strong><span>Input Iterator</span></strong>的子集<span>: </span></font></font>

<font face="宋体" size="3">任何<strong><span>Bidirectional Iterator</span></strong><span> </span>的模型同时也是一个<strong><span>Input Iterator</span></strong><span> </span>的模型。 例如<span>,<tt> Int*</tt>,</span>既是 <strong><span>Bidirectional Iterator</span></strong><span> </span>的模型也是一个<strong><span>Input Iterator </span></strong>的模型<span>, </span>但是<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/istream_iterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>istream_iterator</u></font></a></span></tt>仅仅是一个的模型<strong><span>Input Iterator</span></strong><span>: </span>它并没有符合<strong><span>Bidirectional Iterator</span></strong>更严格的要求。</font>

<span><font face="宋体" size="3">We describe the relationship between <strong>Input Iterator</strong> and <strong>Bidirectional Iterator</strong> by saying that <strong>Bidirectional Iterator</strong> is a <em>refinement</em> of <strong>Input Iterator</strong>. Refinement of concepts is very much like inheritance of C++ classes; the main reason we use a different word, instead of just calling it “inheritance”, is to emphasize that refinement applies to concepts rather than to actual types.</font></span>

<font face="宋体" size="3">我们描述<strong><span>Input Iterator</span></strong>和<strong><span>Bidirectional Iterator</span></strong>的关系时说<strong><span>Bidirectional Iterator</span></strong>是一个更精巧的<strong><span>InputIterator</span></strong>。精巧概念非常像<span>C++</span>类的派生，我们用一个不同的词的主要原因是强调精巧是应用与概念而不是实际的类型。</font>

<span><font face="宋体" size="3">There are actually three more iterator concepts in addition to the two that we have already discussed: the five iterator concepts are <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/OutputIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Output Iterator</u></font></a></strong>, <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/InputIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Input Iterator</u></font></a></strong>, <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/ForwardIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Forward Iterator</u></font></a></strong>, <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/BidirectionalIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Bidirectional Iterator</u></font></a></strong>, and <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/RandomAccessIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Random Access Iterator</u></font></a>;</strong> <strong>Forward Iterator</strong> is a refinement of <strong>Input Iterator</strong>, <strong>Bidirectional Iterator</strong> is a refinement of <strong>Forward Iterator</strong>, and <strong>Random Access Iterator</strong> is a refinement of <strong>Bidirectional Iterator</strong>. (<strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/OutputIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Output Iterator</u></font></a></strong> is related to the other four concepts, but it is not part of the hierarchy of refinement: it is not a refinement of any of the other iterator concepts, and none of the other iterator concepts are refinements of it.) The <em><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Iterators.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Iterator Overview</u></font></a></em> has more information about iterators in general. </font></span>

<font size="3"><font face="宋体">除了我们已经讨论的两个外实际上还要更多的迭代器类型：五种迭代器类型分别为<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/OutputIterator.html" target="_blank" rel="noopener"><strong><font color="#0000ee"><u>Output Iterator</u></font></strong></a>, <a href="http://hi.baidu.com/fc/桌面/SGI-STL/InputIterator.html" target="_blank" rel="noopener"><strong><font color="#0000ee"><u>Input Iterator</u></font></strong></a>, <a href="http://hi.baidu.com/fc/桌面/SGI-STL/ForwardIterator.html" target="_blank" rel="noopener"><strong><font color="#0000ee"><u>Forward Iterator</u></font></strong></a>, <a href="http://hi.baidu.com/fc/桌面/SGI-STL/BidirectionalIterator.html" target="_blank" rel="noopener"><strong><font color="#0000ee"><u>Bidirectional Iterator</u></font></strong></a></span>和<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/RandomAccessIterator.html" target="_blank" rel="noopener"><strong><font color="#0000ee"><u>Random Access Iterator</u></font></strong></a>; <strong>Forward Iterator</strong> </span>是一个精巧的<strong><span>Input Itearot</span></strong><span>,<strong> Bidirectional Iterator</strong></span>是一个更精巧的 <strong><span>Forward Iterator</span></strong><span>, <strong>Random Access Iterator</strong> </span>是一个更精巧的<strong><span>Bidirectional Iterator</span></strong><span>. (<strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/OutputIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Output Iterator</u></font></a></strong> </span>和其他四中迭代器相关，但不是派生和精巧关系<span>) <em><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Iterators.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Iterator Overview</u></font></a></em> </span>有更多的关于<span>iterators</span>的一般信息<span>. </span></font></font>

<span><font face="Times New Roman"></font></span>

<span><font face="宋体" size="3">Container classes, like iterators, are organized into a hierarchy of concepts. All containers are models of the concept <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Container.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Container</u></font></a></strong>; more refined concepts, such as <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Sequence.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Sequence</u></font></a></strong> and <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/AssociativeContainer.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Associative Container</u></font></a></strong>, describe specific types of containers. </font></span>

<p><font face="宋体" size="3">容器类，像迭代器一样被组织进一个概念中。所以的容器都是概念<strong><span><a href="file:///E:/System_Document/桌面/SGI-STL/Container.html" target="_blank" rel="noopener"><font color="#800080"><u>Container</u></font></a></span></strong>的模型；更加精巧的概念，比如说<strong><span><a href="file:///E:/System_Document/桌面/SGI-STL/Sequence.html" target="_blank" rel="noopener"><font color="#800080"><u>Sequence</u></font></a></span></strong><span> and <strong><a href="file:///E:/System_Document/桌面/SGI-STL/AssociativeContainer.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Associative Container</u></font></a></strong>, </span>描述了更特别的容器。</font></p>
<font size="3">

<p>## </p>
<h2 id="下面这部分暂时不翻译，以后看需要时在看。"><a href="#下面这部分暂时不翻译，以后看需要时在看。" class="headerlink" title="下面这部分暂时不翻译，以后看需要时在看。"></a><span><font face="宋体">下面这部分暂时不翻译，以后看需要时在看。</font></span></h2><h2 id="Other-parts-of-the-STL"><a href="#Other-parts-of-the-STL" class="headerlink" title="Other parts of the STL"></a><span><font face="宋体">Other parts of the STL</font></span></h2><span><font face="宋体">If you understand algorithms, iterators, and containers, then you understand almost everything there is to know about the STL. The STL does, however, include several other types of components. </font></span>

<span><font face="宋体">First, the STL includes several <em>utilities</em>: very basic concepts and functions that are used in many different parts of the library. The concept<strong> <a href="http://hi.baidu.com/fc/桌面/SGI-STL/Assignable.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Assignable</u></font></a></strong>, for example, describes types that have assignment operators and copy constructors; almost all STL classes are models of <strong>Assignable</strong>, and almost all STL algorithms require their arguments to be models of <strong>Assignable</strong>. </font></span>

<span><font face="宋体">Second, the STL includes some low-level mechanisms for allocating and deallocating memory. <em><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Allocators.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Allocators</u></font></a></em> are very specialized, and you can safely ignore them for almost all purposes. </font></span>

<p><span><font face="宋体">Finally, the STL includes a large collection of <em><a href="http://hi.baidu.com/fc/桌面/SGI-STL/functors.html" target="_blank" rel="noopener"><font color="#0000ee"><u>function objects</u></font></a></em>, also known as <em>functors</em>. Just as iterators are a generalization of pointers, function objects are a generalization of functions: a function object is anything that you can call using the ordinary function call syntax. There are several different concepts relating to function objects, including <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/UnaryFunction.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Unary Function</u></font></a></strong> (a function object that takes a single argument, <em>i.e.</em> one that is called as <tt>f(x)</tt>) and <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/BinaryFunction.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Binary Function</u></font></a></strong> (a function object that takes two arguments, <em>i.e.</em> one that is called as <tt>f(x, y)</tt>). Function objects are an important part of generic programming because they allow abstraction not only over the types of objects, but also over the operations that are being performed.</font></span><br></p></font><br><p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/04/13/循环不变式-发表日期2008-04-13-0151/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2008/04/13/循环不变式-发表日期2008-04-13-0151/" itemprop="url">循环不变式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-04-13T01:51:00+08:00">
                2008-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="blog_text" class="cnt"><br><pre class="brush:cpp">//invariant:we have written r rows so far.<br>int r=0;<br>//setting r to 0 makes the invariant true<br>while(r!=rows)<br>{<br>//we can assume that the invariant is true here<br>//writting a row of output makes the invariant false<br>std::cout&lt;&lt;std::endl;<br>//incrementing i makes the invarian true again<br>++r;<br>}</pre><br>上面这个循环很简单，就是要使循环体执行n次，但是从中我们可以发现一个循环不变式，那就是“we have written r rows so far”，循环不变式要成立只需当1while开始之前循环不变式成立，2当我们执行到循环体尾部时循环不变式成立。当我们将i设为0时，此时我们一次都没有循环显然循环不变式成立，因为我们此时还没有输出一行，当我们输出一行后，此时循环不变式即为假了，但是++r使得循环不变式又为真了，因此我们可以得出此循环不变式是成立的，当最后跳出循环体时，r==rows了，即我们已经输出了rows行了！<br><br>PS:从Accelerated C++上面看到一个概念，真的是一本不错的书。<br><br></div>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/03/02/又是指针和数组/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2008/03/02/又是指针和数组/" itemprop="url">又是指针和数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-03-02T18:23:00+08:00">
                2008-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;TABLE style=&quot;TABLE-LAYOUT: fixed&quot;&gt;
</code></pre><p><tbody></tbody></p>
<p><tr></tr></p>
<p><td></td></p>
<p><div class="cnt" id="blog_text"></div></p>
<div>

<p>#include &lt;stdio.h&gt;<br>int main()<br>{<br>int a[5]={1,2,3,4,5};<br>int i;<br>int <em>ptr=(int</em>)(&amp;a+1);<br>printf(“ptr=%p/n”,ptr);<br>for(i=0;i&lt;5;i++)<br>&nbsp;&nbsp; printf(“%p/n”,a+i);<br>printf(“%d,%d/n”,<em>(a+1),</em>(ptr-1));<br>}</p>
<p>以下是输出</p>
<p>ptr=0013FF64<br>0013FF50<br>0013FF54<br>0013FF58<br>0013FF5C<br>0013FF60<br>2,5</p>
<p>哎，想了半天才发现是&amp;a+1而不是a+1真是粗心啊！<br></p></div><br><p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/11/21/mfc-is-back-发布日期：2007-11-21/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/11/21/mfc-is-back-发布日期：2007-11-21/" itemprop="url">MFC is back</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-11-21T18:38:00+08:00">
                2007-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;TABLE style=&quot;TABLE-LAYOUT: fixed&quot;&gt;
</code></pre><p><tbody></tbody></p>
<p><tr></tr></p>
<p><td></td></p>
<div class="cnt" id="blog_text">

<span style="FONT-SIZE: 11pt"><font face="Tahoma">Hello again. My name is Ale Contenti, and I’m the Dev Lead for the VC++ Libraries. I’m writing this blog entry from my hotel room in Barcelona. Steve Teixeira and I are here for TechEd Developers Europe. Let me tell you that the atmosphere here is just great! Lots of people and a lot of Visual Studio and C++ users. Lots of interest in Visual Studio 2008 and all the new features and functionality we’ve added to the product.</font></span>

<span style="FONT-SIZE: 11pt; COLOR: #1f497d"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt; COLOR: #1f497d"><a href="http://www.gregcons.com/KateBlog/" target="_blank" rel="noopener"><font face="Tahoma" color="#0000ff"><u>Kate Gregory</u></font></a><font face="Tahoma">, </font><a href="http://blogs.msdn.com/texblog/" target="_blank" rel="noopener"><font face="Tahoma" color="#800080"><u>Steve</u></font></a><font face="Tahoma"> </font></span><span style="FONT-SIZE: 11pt"><font face="Tahoma">and I covered more than 7 talks about different C++ topics, ranging from debugging to interop to MFC. My main talk was about “MFC Updates for Visual Studio 2008 and Beyond”. &nbsp;&nbsp; In this session I introduced the major new features we’re implementing for MFC. With these features, developers will be able to create modern applications that leverage the “look and feel” of Microsoft Office, Internet Explorer and Visual Studio.</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">My MFC talk was in a pretty big room, and the audience was extremely interested! It was great to show the demos and look at the code together! I had a lot of fun and the Q&amp;A session was just perfect, with a lot of great questions and (hopefully) satisfying answers from me </font></span><span style="FONT-SIZE: 11pt">J</span><span style="FONT-SIZE: 11pt"><font face="Tahoma">.</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">Let me share with you some of the comments from the attendees:</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><span style="mso-list: Ignore">·<span style="FONT: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="FONT-SIZE: 11pt"><font face="Tahoma">“Great session! At last, MFC is back!”</font></span>

<span style="FONT-SIZE: 11pt"><span style="mso-list: Ignore">·<span style="FONT: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="FONT-SIZE: 11pt"><font face="Tahoma">“Good demo, great job with all these new control”</font></span>

<span style="FONT-SIZE: 11pt"><span style="mso-list: Ignore">·<span style="FONT: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="FONT-SIZE: 11pt"><font face="Tahoma">“I am really glad to see the future of MFC/VC++ and the commitment to the native programmer. This was a great session and a nice glimpse of the things to come. Keep up the good work. Also, nice to see so many C++ topics this year with really great presenters.”</font></span>

<span style="FONT-SIZE: 11pt"><span style="mso-list: Ignore">·<span style="FONT: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="FONT-SIZE: 11pt"><font face="Tahoma">“Very surprised on all the work that has been done to MFC, having been in the situation where MFC seemed to have been left behind (visually at least)”</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">I was really happy to have the opportunity to present these updates to the MFC Libraries! Special thanks to the VC++ Libraries Team!</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">Kate and I also talked about C++0x and TR1 during a couple of “interactive sessions” or “chalk talk”. Again, great interest on the new TR1 extensions and on what will come from the C++ Standard.</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">During the talks, I had time to meet with a lot of customers and MVPs in the VS2008 Ask The Expert (ATE) booth. I really like to listen to our customers scenarios: It really forces me to think outside the box and to realize how many different “field” problems our customers need to face every day!</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">Last but not least, Charles from Channel9 found some time to interview Kate, Steve and I about C++, customers and what’s next for VC.</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">Heading to Germany, now, for more customer visits!</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">Adios!</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">Ale Contenti</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">VC++ Libraries Dev Lead</font></span>

<p><span style="FONT-SIZE: 11pt"><font face="Tahoma">以上摘自<a href="http://blogs.msdn.com/vcblog/default.aspx" target="_blank" rel="noopener"><u><font color="#0000ff">Visual C++ Team Blog</font></u></a>上的一篇文章，终于看到MS更新MFC了，:-)。</font></span><br></p></div><br><p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/09/05/key-concept-polymorphism-in-c/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/09/05/key-concept-polymorphism-in-c/" itemprop="url">Key Concept: Polymorphism in C++</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-09-05T18:22:00+08:00">
                2007-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;TABLE style=&quot;TABLE-LAYOUT: fixed&quot;&gt;
</code></pre><p><tbody></tbody></p>
<p><tr></tr></p>
<p><td></td></p>
<div class="cnt" id="blog_text">

<font size="3">The crucial point about references and pointers to base-class types is that the <strong><a name="ch15term21"></a><a href="mk:@MSITStore:E:%20学习资料%20C++学习资料%20C++Primer4E.chm::/0201721481/ch15lev1sec11.html#gloss15_21" target="_blank" rel="noopener"><u><font color="#0000ff">static type</font></u></a></strong>the type of the reference or pointer, which is knowable at compile timeand the <strong><a name="ch15term7"></a><a href="mk:@MSITStore:E:%20学习资料%20C++学习资料%20C++Primer4E.chm::/0201721481/ch15lev1sec11.html#gloss15_07" target="_blank" rel="noopener"><u><font color="#0000ff">dynamic type</font></u></a></strong>the type of the object to which the pointer or reference is bound, which is knowable only at run timemay differ.</font>

<p><a name="idd1e114290"></a><a name="idd1e114297"></a><a name="idd1e114302"></a><a name="idd1e114307"></a><a name="idd1e114315"></a><a name="idd1e114320"></a><a name="idd1e114325"></a><a name="idd1e114328"></a><a name="idd1e114333"></a><a name="idd1e114338"></a><a name="idd1e114343"></a><a name="idd1e114348"></a><span class="docEmphStrong"><font size="3">The fact that the static and dynamic types of references and pointers can differ is the cornerstone of how C++ supports polymorphism.</font></span></p>
<span class="docEmphStrong"><font size="3">When we call a function defined in the base class through a base-class reference or pointer, we do not know the precise type of the object on which the function is executed. The object on which the function executes might be of the base type or it might be an object of a derived type.</font></span>

<span class="docEmphStrong"><font size="3">If the function called is nonvirtual, then regardless of the actual object type, the function that is executed is the one defined by the base type. If the function is virtual, then the decision as to which function to run is delayed until run time. The version of the virtual function that is run is the one defined by the type of the object to which the reference is bound or to which the pointer points.</font></span>

<span class="docEmphStrong"><font size="3">From the perspective of the code that we write, we need not care. As long as the classes are designed and implemented correctly, the operations will do the right thing whether the actual object is of base or derived type.</font></span>

<p><span class="docEmphStrong"><font size="3">On the other hand, an object is not polymorphicits type is known and unchanging. The dynamic type of an object (as opposed to a reference or pointer) is always the same as the static type of the object. The function that is run, virtual or nonvirtual, is the one defined by the type of the object.</font></span></p>
<p><a name="ch15note07"></a></p>
<div class="docNote">

<p><table class="FCK__ShowTableBorders" cellspacing="0" cellpadding="1" width="90%" border="0"></table></p>
<p><tbody></tbody></p>
<p><tr></tr></p>
<p><td valign="top" width="60"><img src="mk:@MSITStore:E:%20学习资料%20C++学习资料%20C++Primer4E.chm::/0201721481/images/0201721481/graphics/note.jpg;400478" alt=""></td></p>
<p><td valign="top"></td></p>
<p></p><p class="docText"><span class="docEmphStrong">Virtuals are resolved at run time <span class="docEmphasis">only</span> if the call is made through a reference or pointer. Only in these cases is it possible for an object’s dynamic type to be unknown until run time.</span><br></p></div></div><br><p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/09/01/float-toolbar-and-dock-toolbar/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/09/01/float-toolbar-and-dock-toolbar/" itemprop="url">Float ToolBar and dock ToolBar</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-09-01T18:37:00+08:00">
                2007-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;TABLE style=&quot;TABLE-LAYOUT: fixed&quot;&gt;
</code></pre><p><tbody></tbody></p>
<p><tr></tr></p>
<p><td></td></p>
<p><div class="cnt" id="blog_text"></div></p>
<p><div><font face="黑体" size="4">A docked toolbar is a child of the frame window it’s docked to, but a floating toolbar is a child of the mini frame window that surrounds it. The mini frame window is a popup window owned by the frame window, but it’s not a child of the frame window. (A popup window is a window with the style WS_POPUP; a child window has the WS_CHILD style instead.) The distinction is important because popup windows owned by a frame window are destroyed before the frame window is destroyed. Child windows, on the other hand, are destroyed <em>after</em> their parents are destroyed. A floating toolbar no longer exists when the frame window’s <em>OnDestroy</em> function is called.</font></div><br></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/09/01/消息传递过程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/09/01/消息传递过程/" itemprop="url">消息传递过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-09-01T18:36:00+08:00">
                2007-09-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;DIV class=cnt id=blog_text&gt;
</code></pre><font size="3"><span><img src="http://blog.programfan.com/upfile/200709/200709010105037.gif" alt=""><br></span></font>

<font size="3"><span>据说是在</span><span>Run</span><span>中调用</span><span>AfxWndProc</span><span>（侯捷说的我在源码中找了会没找到，也不晓得是哪个间接调用的），在该函数里面接着调用</span><span>AfxCallWndProc</span><span>，然后</span><span>AfxCallWndProc</span><span>中有这么一段</span></font>

<span><font size="3">// special case for WM_INITDIALOG</font></span>

<span><font size="3">CRect rectOld;</font></span>

<span><font size="3">DWORD dwStyle = 0;</font></span>

<span><font size="3">if (nMsg == WM_INITDIALOG)</font></span>

<span><font size="3">_AfxPreInitDialog(pWnd, &amp;rectOld, &amp;dwStyle);</font></span>

<span><font size="3"></font></span>

<span><font size="3">// delegate to object’s WindowProc</font></span>

<span><font size="3">lResult = pWnd-&gt;WindowProc(nMsg, wParam, lParam);</font></span>

<span><font size="3"></font></span>

<span><font size="3">// more special case for WM_INITDIALOG</font></span>

<span><font size="3">if (nMsg == WM_INITDIALOG)</font></span>

<span><font size="3">_AfxPostInitDialog(pWnd, rectOld, dwStyle);</font></span>

<font size="3"><span>如果不是</span><span>WM_INITDIALOG</span><span>消息则调用</span><span>CWnd</span><span>的</span><span>WindowProc</span><span>，这时就有点迷惑了，应该说</span><span>CCmdTarget</span><span>是处理消息的基类其中的</span><span>OnCmdMsg</span><span>为什么不先调用呢，其实我也不清楚，查看了源代码后发现在</span><span>WindowProc</span><span>中会判断消息的类型里面有这么段：</span></font>

<p><strong><span style="FONT-SIZE: 15pt">CWnd::WindowProc</span></strong></p>
<span><font size="3">if (message == WM_COMMAND)</font></span>

<span><font size="3">{</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if (OnCommand(wParam, lParam))</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>{</font></span>

<span><font size="3"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>lResult = 1;</font></span>

<span><font size="3"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>goto LReturnTrue;</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>}</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return FALSE;</font></span>

<span><font size="3">}</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><strong>CWnd::OnCommand</strong></font></span>

<font size="3"><span>如果是命令消息加速键等用户接口对象的</span><span>WM_COMMAND</span><span>通知消息（有些控件也会发送此消息比如按钮的单击），则调用</span><span>OnCommand</span><span>处理，而在</span><span>OnCommand</span><span>中会判断是一般命令消息还是控件消息，其中如果不是控件消息的话会调用</span><span>OnCmdMsg(nID, CN_UPDATE_COMMAND_UI, &amp;state, NULL);</span><span>看到了吧这里就调用了从</span><span>CCmdTarget</span><span>继承来的虚函数（我只找到了</span><span>CWnd</span><span>的这个地方调用了改消息）。</span></font>

<span><font size="3">接着是控件消息</font></span>

<span><font size="3">// special case for notifies</font></span>

<span><font size="3">if (message == WM_NOTIFY)</font></span>

<span><font size="3">{</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>NMHDR<em> pNMHDR = (NMHDR</em>)lParam;</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if (pNMHDR-&gt;hwndFrom != NULL &amp;&amp; OnNotify(wParam, lParam, &amp;lResult))</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>goto LReturnTrue;</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return FALSE;</font></span>

<span><font size="3">}</font></span>

<font size="3"><span>关于</span><span>WM_NOTIFY</span><span>的一点说明</span><span>: Win32</span><span>使用新的</span><span>WM_NOFITY</span><span>来处理复杂的通知消息。</span><span>WM_COMMAND</span><span>类型的通知消息仅仅能传递一个控制窗口句柄</span><span>(lparam)</span><span>、控制窗</span><span>ID</span><span>和通知代码</span><span>(wparam)</span><span>。</span><span>WM_NOTIFY</span><span>能传递任意复杂的信息。</span></font>

<font size="3"><span>因此控件消息也得以处理，</span><span>WindowProc</span><span>后面的消息处理可想而知了即其他</span><span>WM</span><span>开头的</span><span>Windows</span><span>标准消息。</span></font>

<font size="3"><span>CFrameWnd</span><span>中改写了</span><span>OnCmdMsg</span></font>

<span><font size="3">BOOL CFrameWnd::OnCmdMsg(UINT nID, int nCode, void* pExtra,</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>AFX_CMDHANDLERINFO* pHandlerInfo)</font></span>

<span><font size="3">{</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CPushRoutingFrame push(this);</font></span>

<span><font size="3"></font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// pump through current view FIRST</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CView* pView = GetActiveView();</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if (pView != NULL &amp;&amp; pView-&gt;OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))</font></span>

<span><font size="3"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return TRUE;</font></span>

<span><font size="3"></font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// then pump through frame</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if (CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))</font></span>

<span><font size="3"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return TRUE;</font></span>

<span><font size="3"></font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>// last but not least, pump through app</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>CWinApp* pApp = AfxGetApp();</font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>if (pApp != NULL &amp;&amp; pApp-&gt;OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))</font></span>

<span><font size="3"><span style="mso-tab-count: 2">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return TRUE;</font></span>

<span><font size="3"></font></span>

<span><font size="3"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>return FALSE;</font></span>

<span><font size="3">}</font></span>

<font size="3"><span>由于在</span><span>CFrameWnd</span><span>中产生的消息一般都是</span><span>WM_COMMAND</span><span>消息，因此当</span><span>CWnd::WindowProc</span><span>被调用时会转到</span><span>OnCommand</span><span>而</span><span>CFrameWnd</span><span>又改写了</span><span>CWnd</span><span>的</span><span>OnCommand</span><span>那么</span><span>CFrameWnd</span><span>的</span><span>OnCmdMsg</span><span>是如何被调用的呢，原来在</span><span>CFrameWnd::OnCommand</span><span>中调用了</span><span>CWnd</span><span>的</span><span>OnCommand</span><span>，显然</span><span>CFrameWnd::OnCmdMsg</span><span>就被调用了，由上面的</span><span>CFrameWnd::OnCmdMsg</span><span>可以清楚的看到</span><span>CFrameWnd</span><span>对标准消息传递的过程的改写首先让当前的活动视图处理，通过查看视图的源代码可以发现视图的</span><span>OnCmdMsg</span><span>先让</span><span>CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo)</span><span>处理（最终就是调用</span><span>CCmdTarget::OnCmdMsg</span><span>，通过查看源代码可以发现</span><span>// look through message map to see if it applies to us</span><span>，其实就是查找此视图及相关基类的消息映射表进行相应的处理），接着是让</span><span>m_pDocument-&gt;OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);</span><span>处理，不用查看文档的代码也可以猜到文档模板的</span><span>OnCmdMsg</span><span>会调用，当视图的</span><span>OnCmdMsg</span><span>返回后如果没有处理的话又会调用</span><span>CWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo)</span><span>（此时是</span><span>CFrameWnd</span><span>处理），最后如果还没有处理的话又给</span><span>App</span><span>对象处理，一直到让</span><span>DefWindowProc</span><span>处理。</span></font>

<span><font size="3">对话框的消息处理与此不同，具体可以根据源代码追踪</font></span>

<p><font size="3"><span>呵呵，第一次跟踪查找</span><span>MFC</span><span>源代码，不知道以上结论正确与否，不过对我理解消息传递的过程还是有点帮助，写下来以免忘了。</span></font><br><br></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/08/31/mdisdi创建过程中的一点不同/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/08/31/mdisdi创建过程中的一点不同/" itemprop="url">MDI,SDI创建过程中的一点不同</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-08-31T18:35:00+08:00">
                2007-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CMultiDocTemplate* pDocTemplate;<br>pDocTemplate = new CMultiDocTemplate(<br>&nbsp;&nbsp; IDR_MDISQUTYPE,<br>&nbsp;&nbsp; RUNTIME_CLASS(CSquaresDoc),<br>&nbsp;&nbsp; RUNTIME_CLASS(CChildFrame), // custom MDI child frame<br>&nbsp;&nbsp; RUNTIME_CLASS(CSquaresView));<br>AddDocTemplate(pDocTemplate);</p>
<p>// create main MDI Frame window<br>CMainFrame* pMainFrame = new CMainFrame;<br>if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))<br>&nbsp;&nbsp; return FALSE;<br>m_pMainWnd = pMainFrame;</p>
<p>。。。。。。。。</p>
<p>&nbsp;&nbsp; // Dispatch commands specified on the command line<br>if (!ProcessShellCommand(cmdInfo))<br>&nbsp;&nbsp; return FALSE;</p>
<p>// The main window has been initialized, so show and update it.<br>pMainFrame-&gt;ShowWindow(m_nCmdShow);<br>pMainFrame-&gt;UpdateWindow();</p>
<p>上面为MDI，下面为SDI</p>
<p>CSingleDocTemplate* pDocTemplate;<br>pDocTemplate = new CSingleDocTemplate(<br>&nbsp;&nbsp; IDR_MAINFRAME,<br>&nbsp;&nbsp; RUNTIME_CLASS(CSquaresDoc),<br>&nbsp;&nbsp; RUNTIME_CLASS(CMainFrame),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // main SDI frame window<br>&nbsp;&nbsp; RUNTIME_CLASS(CSquaresView));<br>AddDocTemplate(pDocTemplate);</p>
<p>。。。。。。。。。。</p>
<p>// Dispatch commands specified on the command line<br>if (!ProcessShellCommand(cmdInfo))<br>&nbsp;&nbsp; return FALSE;</p>
<p>// The main window has been initialized, so show and update it.<br>pMainFrame-&gt;ShowWindow(m_nCmdShow);<br>pMainFrame-&gt;UpdateWindow();</p>
<p>主要是在生产文档模板对象时RUNTIME_CLASS(CChildFrame), // custom MDI child frame<br>VS RUNTIME_CLASS(CMainFrame),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // main SDI frame window<br>MDI传递的是childframe,而SDI传递的mainframe，因此MDI的ProcessShellCommand创建的是ChildFrame而SDI创建的MainFrame，所以MDI中就多出了</p>
<p>// create main MDI Frame window<br>CMainFrame* pMainFrame = new CMainFrame;<br>if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))<br>&nbsp;&nbsp; return FALSE;<br>m_pMainWnd = pMainFrame;</p>
<p>必须自己创建MainFrame.</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">billowqiu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">152</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/billowqiu" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:billowqiu@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">billowqiu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
