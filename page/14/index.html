<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="taocoding">
<meta property="og:url" content="http://yoursite.com/page/14/index.html">
<meta property="og:site_name" content="taocoding">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="taocoding">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/14/">





  <title>taocoding</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d13234060d812cb98a47e937139083a9";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">taocoding</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/06/12/删除ctoolbar浮动时的菜单/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2008/06/12/删除ctoolbar浮动时的菜单/" itemprop="url">删除CToolBar浮动时的菜单</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-06-12T04:06:00+08:00">
                2008-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&amp;nbsp; 你可以通过重写ON_WM_WINDOWPOSCHANGED消息处理函数来删除浮动状态下的工具栏实际是系统菜单。这个函数在CToolBar的大小，位置或者Z轴顺序改变时被调用。我们并没有处理WM_SIZE消息处理函数，因为这个函数仅仅只是在大小改变时被调用，而每次当工具栏浮动时并没有被调用。 
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 我们可以通过CControlBar类的成员m_pDockBar成员而不是通过直接调用GetParent()来得到工具栏的父窗口。从CToolBar派生一个类，我暂且称之为CToolBarEx，当然你可以选择一个你认为适合的名字。我们仅仅是在工具栏浮动是删除实际是系统菜单,所以检查工具栏是否是正在浮动状态，并确保m_pDockBar是一个合法的指针。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在你的新类中添加如下成员变量： BOOL m_bMenuRemoved;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 当我们删除系统菜单时将其设置为TRUE，确保仅仅在需要是删除系统菜单。<br>我们需要得到一个m_pDockBar指针来检查工具栏是否确实是在一个CDockFrameWnd类中，以便可以安全地删除CToolBar的系统菜单。下面是示例代码:</p>
<p>#include &lt;afxpriv.h&gt;</p>
<p>void CXToolBar::OnWindowPosChanged(WINDOWPOS FAR* lpwndpos)</p>
<p>{</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; CToolBar::OnWindowPosChanged(lpwndpos);</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; // should only be called once, when floated.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; if( IsFloating() )</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( m_pDockBar &amp;&amp; !m_bMenuRemoved )</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CWnd* pParent = m_pDockBar-&amp;gt;GetParent();</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if( pParent-&gt;IsKindOf(</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RUNTIME_CLASS(CMiniFrameWnd)))</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pParent-&gt;ModifyStyle( WS_SYSMENU, 0, 0 );</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bMenuRemoved = TRUE;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; else if( m_bMenuRemoved ) {</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m_bMenuRemoved = FALSE;</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp; }</p>
<p>}<br>原文网址:<a href="http://www.codejock.com/support/articles/mfc/general/g_8.asp" target="_blank" rel="noopener"><u><font color="#0000ff">www.codejock.com/support/articles/mfc/general/g_8.asp</font></u></a></p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/05/23/求素数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2008/05/23/求素数/" itemprop="url">求素数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-05-23T23:07:00+08:00">
                2008-05-23
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构-算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构/算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&amp;nbsp;鉴于以前写程序那种不经过仔细思考及分析的不良习惯，觉得画流程翻还是很必要的，而且养成习惯后，对自己的思维锻炼以及高效正确编程有很大的好处。翻开大一时发的《C程序设计》第二章复习了一下，把上面一个很好的例子自己整理了一下，而且发现一个不错的画流程图的工具(Diagram Designer)。以下为全文：
</code></pre><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<span>问题：将</span><span><font face="Times New Roman">1</font></span><span>到</span><span><font face="Times New Roman">1000</font></span><span>之间的素数打印出来。</span>

<span>算法描述：“筛选”法，所谓“筛选法”指的是“</span><span><font face="Times New Roman">Eratosthenes</font></span><span>筛法”。他采取的方法是，在一张纸上写上</span><span><font face="Times New Roman">1</font></span><span>到</span><span><font face="Times New Roman">1000</font></span><span>全部整数，然后逐个判断它们是否是素数，找出一个非素数，就把它挖掉，最后剩下的就是素数。</span>

<span style="mso-ascii-: yes">①</span><span><font face="Times New Roman"> 2 3 </font></span><span style="mso-ascii-: yes">④</span><span><font face="Times New Roman"> 5 </font></span><span style="mso-ascii-: yes">⑥</span><span><font face="Times New Roman"> 7 </font></span><span style="mso-ascii-: yes">⑧</span><span><font face="Times New Roman"> </font></span><span style="mso-ascii-: yes">⑨</span><span><font face="Times New Roman"> </font></span><span style="mso-ascii-: yes">⑩</span><span>……</span><font face="Times New Roman"> </font><br><br><span>具体做法如下：</span>

<span style="mso-ascii-: yes">⑴</span><span>先将</span><span><font face="Times New Roman">1</font></span><span>挖掉（因为</span><span><font face="Times New Roman">1</font></span><span>不是素数）。</span>

<span style="mso-ascii-: yes">⑵</span><span>用</span><span><font face="Times New Roman">2</font></span><span>去除它后面的各个数，把能被</span><span><font face="Times New Roman">2</font></span><span>整除的数挖掉，即把</span><span><font face="Times New Roman">2</font></span><span>的倍数挖掉。</span>

<span style="mso-ascii-: yes">⑶</span><span>用</span><span><font face="Times New Roman">3</font></span><span>去除它后面的各数，把</span><span><font face="Times New Roman">3</font></span><span>的倍数挖掉</span>

<span style="mso-ascii-: yes">⑷</span><span>分别用</span><span><font face="Times New Roman">4</font></span><span>，</span><span><font face="Times New Roman">5</font></span><span>…各数作为除数去除这些数以后的各数。这个过程一直进行到在除数后面的数已经全被挖掉为止。事实上，只需进行到</span>

<span>上面的算法可以表示为：</span>

<span style="mso-ascii-: yes">⑴</span><span>挖去</span><span><font face="Times New Roman">1</font></span>

<span style="mso-ascii-: yes">⑵</span><span>用下一个未被挖去的数</span><span><font face="Times New Roman">p</font></span><span>去除</span><span><font face="Times New Roman">p</font></span><span>后面的各数，把</span><span><font face="Times New Roman">p</font></span><span>的倍数挖掉。</span>

<span style="mso-ascii-: yes">⑶</span><span>检查</span><span><font face="Times New Roman">p</font></span><span>是否小于的整数部分（如果</span><span><font face="Times New Roman">n=1000</font></span><span>，则检查</span><span><font face="Times New Roman">p&lt;31</font></span><span>？），如果是，则返回</span><span style="mso-ascii-: yes">⑵</span><span>继续执行，否则就结束。</span>

<span style="mso-ascii-: yes">⑷</span><span>纸上剩下的就是素数。</span>

<span>解题的基本思路有了，但要变成计算机的操作，还要做进一步的分析，如怎样判断一个数是否已被挖掉，怎样找出一个数</span><span><font face="Times New Roman">p</font></span><span>的倍数，怎样打印出来未被挖掉的数。</span>

<span>用自顶向下逐步细化的方法来处理这个问题，先进行“顶层设计”，见下图。也可以用流程图进行逐步细化。流程图</span><span><font face="Times New Roman">1</font></span><span>表示流程的粗略情况，把要做的三部分工作分别用</span><span><font face="Times New Roman">A</font></span><span>、</span><span><font face="Times New Roman">B</font></span><span>、</span><span><font face="Times New Roman">C</font></span><span>表示。 </span><br><span><br><div forimg="1"><a href="http://hiphotos.baidu.com/qiutao%5F2008/pic/item/50a29d363623c4cea2cc2b28.jpg" target="_blank" rel="noopener"><img src="http://hiphotos.baidu.com/qiutao%5F2008/abpic/item/50a29d363623c4cea2cc2b28.jpg" alt=""></a></div></span>

<span>这三部分还不够具体，要进一步细化。</span><span><font face="Times New Roman">A</font></span><span>部分可以细化为图</span><span><font face="Times New Roman">A</font></span><span>。先输入</span><span><font face="Times New Roman">n</font></span><span>，然后将</span><span><font face="Times New Roman">1</font></span><span>输入给</span><span><font face="Times New Roman">X1</font></span><span>，</span><span><font face="Times New Roman">2</font></span><span>输入</span><span><font face="Times New Roman">X2</font></span><span>，</span><span><font face="Times New Roman">1000</font></span><span>输入给</span><font face="Times New Roman"><span>X</span><span style="FONT-SIZE: 7.5pt">1000</span></font><span style="mso-ascii-: 10.5pt">。</span>

<span style="mso-bidi-font-size: 10.5pt"><a href="http://hiphotos.baidu.com/qiutao%5F2008/pic/item/5bb5041bf679f1c6ac6e7529.jpg" target="_blank" rel="noopener"><img src="http://hiphotos.baidu.com/qiutao%5F2008/abpic/item/5bb5041bf679f1c6ac6e7529.jpg" alt=""></a></span>

<span style="mso-ascii-: 10.5pt">B部分可以细化为图</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">B</font></span><span style="mso-ascii-: 10.5pt">。</span>

<span style="mso-bidi-font-size: 10.5pt"><a href="http://hiphotos.baidu.com/qiutao%5F2008/pic/item/735064fb189887314e4aea2a.jpg" target="_blank" rel="noopener"><img src="http://hiphotos.baidu.com/qiutao%5F2008/abpic/item/735064fb189887314e4aea2a.jpg" alt=""></a></span>

<span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">B</font></span><span style="mso-ascii-: 10.5pt">中的</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">B1</font></span><span style="mso-ascii-: 10.5pt">和</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">B2</font></span><span style="mso-ascii-: 10.5pt">不能再分了。</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">B1</font></span><span style="mso-ascii-: 10.5pt">处理的方法是：使</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">X1=0</font></span><span style="mso-ascii-: 10.5pt">，即哪个数不是素数，就使它等于</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">0</font></span><span style="mso-ascii-: 10.5pt">，以后把不等于</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">0</font></span><span style="mso-ascii-: 10.5pt">的数打印处理就是所求的素鼠表。</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">B3</font></span><span style="mso-ascii-: 10.5pt">中的循环体内以</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">D</font></span><span style="mso-ascii-: 10.5pt">标志的部分还要进一步细化，对</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">D</font></span><span style="mso-ascii-: 10.5pt">细化为图</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">D</font></span><span style="mso-ascii-: 10.5pt">。</span>

<span style="mso-bidi-font-size: 10.5pt"><a href="http://hiphotos.baidu.com/qiutao%5F2008/pic/item/74cd06160bb4410b962b432b.jpg" target="_blank" rel="noopener"><img src="http://hiphotos.baidu.com/qiutao%5F2008/abpic/item/74cd06160bb4410b962b432b.jpg" alt=""></a></span>

<div forimg="1"></div>

<p>图<span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">D</font></span><span style="mso-ascii-: 10.5pt">中的</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">E</font></span><span style="mso-ascii-: 10.5pt">部分还不够具体，再进一步细化为图</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">E</font></span><span style="mso-ascii-: 10.5pt">。</span></p>
<span style="mso-ascii-: 10.5pt"><a href="http://hiphotos.baidu.com/qiutao%5F2008/pic/item/e957c817ac1353124b90a735.jpg" target="_blank" rel="noopener"><img src="http://hiphotos.baidu.com/qiutao%5F2008/abpic/item/e957c817ac1353124b90a735.jpg" alt=""></a></span>

<span style="mso-ascii-: 10.5pt">图</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">E</font></span><span style="mso-ascii-: 10.5pt">中的</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">F</font></span><span style="mso-ascii-: 10.5pt">部分又细化为图</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">F</font></span><span style="mso-ascii-: 10.5pt">，因为首先要判断某一个</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">Xj</font></span><span style="mso-ascii-: 10.5pt">是否已经被挖掉，如已被挖掉则不必考虑被</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">Xi</font></span><span style="mso-ascii-: 10.5pt">除。至此，已不能也不需要再分解了。</span>

<span style="mso-bidi-font-size: 10.5pt"><span style="mso-ascii-: 10.5pt"><a href="http://hiphotos.baidu.com/qiutao%5F2008/pic/item/db517951464f5e9c8d543035.jpg" target="_blank" rel="noopener"><img src="http://hiphotos.baidu.com/qiutao%5F2008/abpic/item/db517951464f5e9c8d543035.jpg" alt=""></a></span></span>

<span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">图1</font></span><span style="mso-ascii-: 10.5pt">中的</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">C</font></span><span style="mso-ascii-: 10.5pt">部分进行细化，得图</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">C1</font></span><span style="mso-ascii-: 10.5pt">。</span>

<span style="mso-bidi-font-size: 10.5pt"><a href="http://hiphotos.baidu.com/qiutao%5F2008/pic/item/2742ef0180aa521d7aec2c31.jpg" target="_blank" rel="noopener"><img src="http://hiphotos.baidu.com/qiutao%5F2008/abpic/item/2742ef0180aa521d7aec2c31.jpg" alt=""></a></span>

<div forimg="1"></div>

<p>再对图<span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">C1</font></span><span style="mso-ascii-: 10.5pt">中的</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">G</font></span><span style="mso-ascii-: 10.5pt">部分进行细化，得图</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">G</font></span><span style="mso-ascii-: 10.5pt">。</span></p>
<span style="mso-bidi-font-size: 10.5pt"><a href="http://hiphotos.baidu.com/qiutao%5F2008/pic/item/2cd0d4083c67e0c263d98637.jpg" target="_blank" rel="noopener"><img src="http://hiphotos.baidu.com/qiutao%5F2008/abpic/item/2cd0d4083c67e0c263d98637.jpg" alt=""></a></span>

<span style="mso-ascii-: 10.5pt">至此，已将图</span><span style="mso-bidi-font-size: 10.5pt"><font face="Times New Roman">1</font></span><span style="mso-ascii-: 10.5pt">分解为能用三种基本结构表示的基本操作了。将以上这些图组合起来就可以得到最终的总流程图了，根据这个细化了的流程图已经可以用任何高级语言编写程序了。</span>

<p>有时间再把整个流程图组合在一起，然后把对应的程序也写一下，慢慢来吧，要走的路还长呢！&nbsp;&nbsp;&nbsp;</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/05/14/mfc透明控件的超级简单实现/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2008/05/14/mfc透明控件的超级简单实现/" itemprop="url">MFC透明控件的超级简单实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-05-14T00:44:00+08:00">
                2008-05-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>今天在翻出以前写的一个程序时，想改下对话框的背景，结果导致Static控件的背景留下灰色的默认背景色，感觉很不爽，想着也学了这么久MFC了，这个问题今天一定要解决了，大致思路还是知道的，但是由于一直都是在学习，看别人的代码所以真真要自己写还是得仔细琢磨下，经过几番测试发现下面的方法最容易，贴上代码和截图吧：</p>
<p>// CQTTransparentStatic</p>
<p>class CQTTransparentStatic : public CStatic<br>{<br>DECLARE_DYNAMIC(CQTTransparentStatic)<br>public:<br>CQTTransparentStatic();<br>virtual ~CQTTransparentStatic();<br>//响应父类的反射消息<br>afx_msg HBRUSH CtlColor(CDC<em> /</em>pDC<em>/, UINT /</em>nCtlColor*/);<br>protected:<br>DECLARE_MESSAGE_MAP()<br>};</p>
<p>IMPLEMENT_DYNAMIC(CQTTransparentStatic, CStatic)</p>
<p>CQTTransparentStatic::CQTTransparentStatic()<br>{</p>
<p>}</p>
<p>CQTTransparentStatic::~CQTTransparentStatic()<br>{<br>}</p>
<p>BEGIN_MESSAGE_MAP(CQTTransparentStatic, CStatic)<br>ON_WM_CTLCOLOR_REFLECT()<br>END_MESSAGE_MAP()</p>
<p>// CQTTransparentStatic 消息处理程序</p>
<p>HBRUSH CQTTransparentStatic::CtlColor(CDC* pDC, UINT nCtlColor)<br>{<br>// TODO: 在此更改 DC 的任何属性<br>// TODO: 如果不应调用父级的处理程序，则返回非空画笔<br>pDC-&gt;SetBkMode(TRANSPARENT);<br>return (HBRUSH)::GetStockObject(HOLLOW_BRUSH);<br>}</p>
<p>代码真的是很简单吧，哈哈，</p>
<div forimg="1"><img src="http://hiphotos.baidu.com/qiutao%5F2008/pic/item/2742ef012d51c71d7aec2c49.jpg" alt=""></div>

<span style="FONT-SIZE: 10.5pt; mso-bidi-font-size: 12.0pt; mso-fareast-: 1.0pt">怎么样效果也还不错呢。</span>

<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/05/12/消息路由/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2008/05/12/消息路由/" itemprop="url">消息路由</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-05-12T14:31:00+08:00">
                2008-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在MSDN上看到的，对理解消息队列很有用。</p>
<p>消息有两种：队列消息和非队列消息。</p>
<p>队列消息的传递方式：系统维护了一个单独的系统消息队列，并为每一个GUI线程维护一个消息队列，当队列消息，比如鼠标，键盘事件引发的消息，将先被放到系统消息队列中，然后按照队列的操作规则，系统一次移除一个消息，并检查该消息，然后发送到产生该目标窗口的线程消息队列中，线程从自己的消息队列中移除消息然后让系统将其发送到窗口过程。</p>
<p>非队列消息：不经过系统消息队列和线程消息队列的迂回，直接发送到目标窗口过程。</p>
<p>在队列消息中<strong>WM_PAINT</strong> message, the <strong>WM_TIMER</strong> message, and the <strong>WM_QUIT</strong> message三种消息是被放在消息队列的队尾的，以确保其他消息的FIFO特性。线程通过<u><font color="#0000ff">GetMessage</font></u> 从线程消息队列中移除消息， 通过&lt;?XML:NAMESPACE PREFIX = MSHELP /&gt;&lt;MSHELP:LINK tabIndex=0 keywords=”_win32_DispatchMessage_cpp”&gt;<u><font color="#0000ff">DispatchMessage</font></u>&lt;/MSHELP:LINK&gt; 驱使系统将消息发送到相应的窗口过程。</p>
<p><a name="routing"></a>Message RoutingThe thread removes messages from its queue and directs the system to send them to the appropriate window procedure for processing.</p>
<p>The system uses two methods to route messages to a window procedure: posting messages to a first-in, first-out queue called a <em>message queue</em>, a system-defined memory object that temporarily stores messages, and sending messages directly to a window procedure.</p>
<p>Messages posted to a message queue are called <em>queued messages</em>. They are primarily the result of user input entered through the mouse or keyboard, such as &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_WM_MOUSEMOVE_cpp”&gt;<u><font color="#0000ff">WM_MOUSEMOVE</font></u>&lt;/MSHELP:LINK&gt;, &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_WM_LBUTTONDOWN_cpp”&gt;<u><font color="#0000ff">WM_LBUTTONDOWN</font></u>&lt;/MSHELP:LINK&gt;, &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_WM_KEYDOWN_cpp”&gt;<u><font color="#0000ff">WM_KEYDOWN</font></u>&lt;/MSHELP:LINK&gt;, and &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_WM_CHAR_cpp”&gt;<u><font color="#0000ff">WM_CHAR</font></u>&lt;/MSHELP:LINK&gt; messages. Other queued messages include the timer, paint, and quit messages: &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_WM_TIMER_cpp”&gt;<u><font color="#0000ff">WM_TIMER</font></u>&lt;/MSHELP:LINK&gt;, <strong>WM_PAINT</strong>, and &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_WM_QUIT_cpp”&gt;<u><font color="#0000ff">WM_QUIT</font></u>&lt;/MSHELP:LINK&gt;. Most other messages, which are sent directly to a window procedure, are called <em>nonqueued messages</em>.</p>
<h3 id="Queued-Messages"><a href="#Queued-Messages" class="headerlink" title="Queued Messages"></a><a name="quequed_messages"></a>Queued Messages</h3><p>The system can display any number of windows at a time. To route mouse and keyboard input to the appropriate window, the system uses message queues.</p>
<p>The system maintains a single system message queue and one thread-specific message queue for each graphical user interface (GUI) thread. To avoid the overhead of creating a message queue for non–GUI threads, all threads are created initially without a message queue. The system creates a thread-specific message queue only when the thread makes its first call to one of the User or Windows Graphics Device Interface (GDI) functions.</p>
<p>Whenever the user moves the mouse, clicks the mouse buttons, or types on the keyboard, the device driver for the mouse or keyboard converts the input into messages and places them in the system message queue. The system removes the messages, one at a time, from the system message queue, examines them to determine the destination window, and then posts them to the message queue of the thread that created the destination window. A thread’s message queue receives all mouse and keyboard messages for the windows created by the thread. The thread removes messages from its queue and directs the system to send them to the appropriate window procedure for processing.</p>
<p>With the exception of the <strong>WM_PAINT</strong> message, the <strong>WM_TIMER</strong> message, and the <strong>WM_QUIT</strong> message, the system always posts messages at the end of a message queue. This ensures that a window receives its input messages in the proper first in, first out (FIFO) sequence. The <strong>WM_PAINT</strong> message, the <strong>WM_TIMER</strong> message, and the <strong>WM_QUIT</strong> message, however, are kept in the queue and are forwarded to the window procedure only when the queue contains no other messages. In addition, multiple <strong>WM_PAINT</strong> messages for the same window are combined into a single <strong>WM_PAINT</strong> message, consolidating all invalid parts of the client area into a single area. Combining <strong>WM_PAINT</strong> messages reduces the number of times a window must redraw the contents of its client area.</p>
<p>The system posts a message to a thread’s message queue by filling an &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_MSG_str_cpp”&gt;<u><font color="#0000ff">MSG</font></u>&lt;/MSHELP:LINK&gt; structure and then copying it to the message queue. Information in <strong>MSG</strong> includes: the handle of the window for which the message is intended, the message identifier, the two message parameters, the time the message was posted, and the mouse cursor position. A thread can post a message to its own message queue or to the queue of another thread by using the &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_PostMessage_cpp”&gt;<u><font color="#0000ff">PostMessage</font></u>&lt;/MSHELP:LINK&gt; or &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_PostThreadMessage_cpp”&gt;<u><font color="#0000ff">PostThreadMessage</font></u>&lt;/MSHELP:LINK&gt; function.</p>
<p>An application can remove a message from its queue by using the &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_GetMessage_cpp”&gt;<u><font color="#0000ff">GetMessage</font></u>&lt;/MSHELP:LINK&gt; function. To examine a message without removing it from its queue, an application can use the &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_PeekMessage_cpp”&gt;<u><font color="#0000ff">PeekMessage</font></u>&lt;/MSHELP:LINK&gt; function. This function fills <strong>MSG</strong> with information about the message.</p>
<p>After removing a message from its queue, an application can use the &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_DispatchMessage_cpp”&gt;<u><font color="#0000ff">DispatchMessage</font></u>&lt;/MSHELP:LINK&gt; function to direct the system to send the message to a window procedure for processing. <strong>DispatchMessage</strong> takes a pointer to <strong>MSG</strong> that was filled by a previous call to the <strong>GetMessage</strong> or <strong>PeekMessage</strong> function. <strong>DispatchMessage</strong> passes the window handle, the message identifier, and the two message parameters to the window procedure, but it does not pass the time the message was posted or mouse cursor position. An application can retrieve this information by calling the &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_GetMessageTime_cpp”&gt;<u><font color="#0000ff">GetMessageTime</font></u>&lt;/MSHELP:LINK&gt; and &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_GetMessagePos_cpp”&gt;<u><font color="#0000ff">GetMessagePos</font></u>&lt;/MSHELP:LINK&gt; functions while processing a message.</p>
<p>A thread can use the &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_WaitMessage_cpp”&gt;<u><font color="#0000ff">WaitMessage</font></u>&lt;/MSHELP:LINK&gt; function to yield control to other threads when it has no messages in its message queue. The function suspends the thread and does not return until a new message is placed in the thread’s message queue.</p>
<p>You can call the &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_SetMessageExtraInfo_cpp”&gt;<u><font color="#0000ff">SetMessageExtraInfo</font></u>&lt;/MSHELP:LINK&gt; function to associate a value with the current thread’s message queue. Then call the &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_GetMessageExtraInfo_cpp”&gt;<u><font color="#0000ff">GetMessageExtraInfo</font></u>&lt;/MSHELP:LINK&gt; function to get the value associated with the last message retrieved by the <strong>GetMessage</strong> or <strong>PeekMessage</strong> function.</p>
<h3 id="Nonqueued-Messages"><a href="#Nonqueued-Messages" class="headerlink" title="Nonqueued Messages"></a><a name="nonqueued_messages"></a>Nonqueued Messages</h3><p>Nonqueued messages are sent immediately to the destination window procedure, bypassing the system message queue and thread message queue. The system typically sends nonqueued messages to notify a window of events that affect it. For example, when the user activates a new application window, the system sends the window a series of messages, including &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_WM_ACTIVATE_cpp”&gt;<u><font color="#0000ff">WM_ACTIVATE</font></u>&lt;/MSHELP:LINK&gt;, &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_WM_SETFOCUS_cpp”&gt;<u><font color="#0000ff">WM_SETFOCUS</font></u>&lt;/MSHELP:LINK&gt;, and &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_WM_SETCURSOR_cpp”&gt;<u><font color="#0000ff">WM_SETCURSOR</font></u>&lt;/MSHELP:LINK&gt;. These messages notify the window that it has been activated, that keyboard input is being directed to the window, and that the mouse cursor has been moved within the borders of the window. Nonqueued messages can also result when an application calls certain system functions. For example, the system sends the &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_WM_WINDOWPOSCHANGED_cpp”&gt;<u><font color="#0000ff">WM_WINDOWPOSCHANGED</font></u>&lt;/MSHELP:LINK&gt; message after an application uses the &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_SetWindowPos_cpp”&gt;<u><font color="#0000ff">SetWindowPos</font></u>&lt;/MSHELP:LINK&gt; function to move a window.</p>
<p>Some functions that send nonqueued messages are &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_BroadcastSystemMessage_cpp”&gt;<u><font color="#0000ff">BroadcastSystemMessage</font></u>&lt;/MSHELP:LINK&gt;, &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_BroadcastSystemMessageEx_cpp”&gt;<u><font color="#0000ff">BroadcastSystemMessageEx</font></u>&lt;/MSHELP:LINK&gt;, &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_SendMessage_cpp”&gt;<u><font color="#0000ff">SendMessage</font></u>&lt;/MSHELP:LINK&gt;, &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_SendMessageTimeout_cpp”&gt;<u><font color="#0000ff">SendMessageTimeout</font></u>&lt;/MSHELP:LINK&gt;, and &lt;MSHELP:LINK tabIndex=0 keywords=”_win32_SendNotifyMessage_cpp”&gt;<u><font color="#0000ff">SendNotifyMessage</font></u>&lt;/MSHELP:LINK&gt;.</p>
<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/05/07/内存设备环境/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2008/05/07/内存设备环境/" itemprop="url">内存设备环境</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-05-07T16:12:00+08:00">
                2008-05-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">通过使用一个特别为位图操作的设备环境，可以使得应用程序将输出操作在内存中而不是将其发送到实际的设备中。内存设备环境使得系统将一部分内存当作虚拟设备。它就是一个在内存中的位数组，使得应用程序可以使用它为在一个标准的绘图表面创建位图临时存储颜色数据。由于位图是和设备兼容的，因此内存设备环境在某些时候也就当作兼容设备环境。</font> </span><span style="FONT-SIZE: 12pt; mso-spacerun: yes"></span>

<span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">内存设备环境作为一个特殊的环境存储位图图像。应用程序可以调用</font> </span><span><a href="ms-help://MS.MSDNQTR.v80.chs/MS.MSDN.v80/MS.WIN32COM.v10.en/gdi/devcons_499f.htm" target="_blank" rel="noopener"><font color="#0000ff"><span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt; TEXT-DECORATION: underline; mso-spacerun: yes">CreateCompatibleDC</span><u> </u></font></a></span><span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">创建一个内存设备环境。</font> </span>

<span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">内存设备环境中初始的位图只是一个简单的占位符。它的尺寸为1*1像素。在应用程序进行绘制之前，必须通过调用</font> </span><span><a href="ms-help://MS.MSDNQTR.v80.chs/MS.MSDN.v80/MS.WIN32COM.v10.en/gdi/devcons_9v3o.htm" target="_blank" rel="noopener"><font color="#0000ff"><span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt; TEXT-DECORATION: underline; mso-spacerun: yes">SelectObject</span><u> </u></font></a></span><span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">选择一个恰当宽度和高度的位图到该内存环境中。要创建一个恰当尺寸的位图，可以使用</font> </span><span><a href="ms-help://MS.MSDNQTR.v80.chs/MS.MSDN.v80/MS.WIN32COM.v10.en/gdi/bitmaps_3ak0.htm" target="_blank" rel="noopener"><font color="#0000ff"><span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt; TEXT-DECORATION: underline; mso-spacerun: yes">CreateBitmap</span><u> </u></font></a></span><span style="FONT-SIZE: 12pt; mso-spacerun: yes">, </span><span><a href="ms-help://MS.MSDNQTR.v80.chs/MS.MSDN.v80/MS.WIN32COM.v10.en/gdi/bitmaps_6r04.htm" target="_blank" rel="noopener"><font color="#0000ff"><span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt; TEXT-DECORATION: underline; mso-spacerun: yes">CreateBitmapIndirect</span><u> </u></font></a></span><span style="FONT-SIZE: 12pt; mso-spacerun: yes">, or </span><span><a href="ms-help://MS.MSDNQTR.v80.chs/MS.MSDN.v80/MS.WIN32COM.v10.en/gdi/bitmaps_1cxc.htm" target="_blank" rel="noopener"><font color="#0000ff"><span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt; TEXT-DECORATION: underline; mso-spacerun: yes">CreateCompatibleBitmap</span><u> </u></font></a></span><span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">三个函数。当位图被选进内存设备环境后，系统用一个足够大的数组取代单位数组来存储指定的矩形像素的颜色信息。</font> </span><span style="FONT-SIZE: 12pt; mso-spacerun: yes"></span>

<span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">当应用程序传递一个由</font> </span><span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt; mso-spacerun: yes">CreateCompatibleDC</span> <span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">返回的句柄到绘制函数时，被要求的输出并不会在设备的绘制表面显示。相反，系统会存储线段，曲线，文字或者区域的颜色信息到位数组中。应用程序可以复制存储在内存中的图像到绘制表面通过调用</font> </span><span><a href="ms-help://MS.MSDNQTR.v80.chs/MS.MSDN.v80/MS.WIN32COM.v10.en/gdi/bitmaps_0fzo.htm" target="_blank" rel="noopener"><font color="#0000ff"><span style="FONT-WEIGHT: bold; FONT-SIZE: 12pt; TEXT-DECORATION: underline; mso-spacerun: yes">BitBlt</span><u> </u></font></a></span><span style="FONT-SIZE: 12pt; mso-spacerun: yes"><font face="宋体">函数，并将内存设备环境作为源设备环境，窗口或者屏幕设备环境作为目标设备环境。</font> </span>

<p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/04/24/模板代替虚函数实现多态/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2008/04/24/模板代替虚函数实现多态/" itemprop="url">模板代替虚函数实现多态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-04-24T13:05:00+08:00">
                2008-04-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;TABLE style=&quot;TABLE-LAYOUT: fixed&quot;&gt;
</code></pre><p><tbody></tbody></p>
<p><tr></tr></p>
<p><td></td></p>
<div class="cnt" id="blog_text">

<p>虚函数和继承的实现：</p>
<p>class File {<br>&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void Open() = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void Save() = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void SaveAS(String&amp;) = 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; virtual void Close() = 0;<br>};<br>class TextFile:public File{<br>&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Open();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Save();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void SaveAS(String&amp;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Close();<br>};<br>class ImageFile:public File{<br>&nbsp;&nbsp; public:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Open();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Save();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void SaveAS(String&amp;);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; void Close();<br>};</p>
<p>// user menu selection to open the file<br>void menu_open_file(File<em> f_ptr){<br>&nbsp;&nbsp; f_ptr-&gt;Open();<br>&nbsp;&nbsp; ….<br>&nbsp;&nbsp; …<br>}<br>By using the above code, you would have the following:<br>File </em>file_ptr = new TextFile();<br>menu_open_file(file_ptr);//open the text file<br>.<br>.<br>file_ptr = new ImageFile();<br>menu_open_file(file_ptr);//open the image file</p>
<p>模板的实现：</p>
<p>class TextFile{<br>public:<br>&nbsp;&nbsp; void Open();<br>};</p>
<p>class ImageFile{<br>public:<br>void Open();<br>};</p>
<p>//user menu selection to open the file</p>
<p>template&lt;typename T&gt; void menu_open_file(T file){<br>&nbsp;&nbsp; file.Open();<br>}<br>Using the code:<br>TextFile txt_file;<br>ImageFile img_file;<br>menu_open_file(txt_file);&nbsp;&nbsp;&nbsp; //open the text file<br>menu_open_file(img_file);&nbsp;&nbsp;&nbsp; //open the image file<br></p></div><br><p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/04/13/stl介绍/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2008/04/13/stl介绍/" itemprop="url">STL介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-04-13T15:36:00+08:00">
                2008-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>翻译的一篇SGI STL文档还要好多不太会翻译，以后在慢慢领悟吧！</p>
<h1 id="Introduction-to-the-Standard-Template-Library"><a href="#Introduction-to-the-Standard-Template-Library" class="headerlink" title="Introduction to the Standard Template Library"></a><span><font face="宋体">Introduction to the Standard Template Library</font></span></h1><h1 id="标准模板库简介"><a href="#标准模板库简介" class="headerlink" title="标准模板库简介"></a><font face="宋体">标准模板库简介</font></h1><span><font face="宋体" size="3">The Standard Template Library, or <em>STL</em>, is a C++ library of container classes, algorithms, and iterators; it provides many of the basic algorithms and data structures of computer science. The STL is a <em>generic</em> library, meaning that its components are heavily parameterized: almost every component in the STL is a template. You should make sure that you understand how templates work in C++ before you use the STL.</font></span>

<font face="宋体" size="3">标准模板库，或<span>STL</span>，是一个包括容器类，算法和迭代器的<span>C++</span>库；它提供了许多计算机的基本算法和数据结构。<span>STL</span>是一个泛型库，这意味这它是由很深的参数机制实现的：几乎每一个<span>STL</span>的组件都是模板。你在使用<span>STL</span>之前应该确信你已经懂得了<span>C++</span>的模板。</font>

<h2 id="Containers-and-algorithms"><a href="#Containers-and-algorithms" class="headerlink" title="Containers and algorithms"></a><span><font face="宋体">Containers and algorithms</font></span></h2><h2 id="容器和算法"><a href="#容器和算法" class="headerlink" title="容器和算法"></a><font face="宋体">容器和算法</font></h2><span><font face="宋体" size="3">Like many class libraries, the STL includes <em>container</em> classes: classes whose purpose is to contain other objects. The STL includes the classes <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Vector.html" target="_blank" rel="noopener"><font color="#0000ee"><u>vector</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/List.html" target="_blank" rel="noopener"><font color="#0000ee"><u>list</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Deque.html" target="_blank" rel="noopener"><font color="#0000ee"><u>deque</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/set.html" target="_blank" rel="noopener"><font color="#0000ee"><u>set</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/multiset.html" target="_blank" rel="noopener"><font color="#0000ee"><u>multiset</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Map.html" target="_blank" rel="noopener"><font color="#0000ee"><u>map</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Multimap.html" target="_blank" rel="noopener"><font color="#0000ee"><u>multimap</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_set.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_set</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_multiset.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_multiset</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_map.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_map</u></font></a></tt>, and <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_multimap.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_multimap</u></font></a></tt>. Each of these classes is a template, and can be instantiated to contain any type of object. You can, for example, use a <tt>vector&lt;int&gt;</tt> in much the same way as you would use an ordinary C array, except that <tt>vector</tt> eliminates the chore of managing dynamic memory allocation by hand.</font></span>

<font face="宋体" size="3">像许多类库，<span>STL</span>包括容器类：用于包含其他类对象的类。<span>STL</span>包括的容器类有<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Vector.html" target="_blank" rel="noopener"><font color="#0000ee"><u>vector</u></font></a></span></tt><span>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/List.html" target="_blank" rel="noopener"><font color="#0000ee"><u>list</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Deque.html" target="_blank" rel="noopener"><font color="#0000ee"><u>deque</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/set.html" target="_blank" rel="noopener"><font color="#0000ee"><u>set</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/multiset.html" target="_blank" rel="noopener"><font color="#0000ee"><u>multiset</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Map.html" target="_blank" rel="noopener"><font color="#0000ee"><u>map</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Multimap.html" target="_blank" rel="noopener"><font color="#0000ee"><u>multimap</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_set.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_set</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_multiset.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_multiset</u></font></a></tt>, <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_map.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_map</u></font></a></tt>,</span>和<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/hash_multimap.html" target="_blank" rel="noopener"><font color="#0000ee"><u>hash_multimap</u></font></a></span></tt>。每一个容器类都是模板，而且可以被实例化去包含任何类型的对象。例如你可以使用<span>vector&lt;int&gt;</span>像使用一个原生的<span>C</span>数组，出此之外<span>vector</span>还消除了一些手动动态内存管理的琐碎事情。</font><br><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>vector&lt;int&gt; v(3);<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>// Declare a vector of 3 elements.</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>v[0] = 7;</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>v[1] = v[0] + 3;</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>v[2] = v[0] + v[1];<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>// v[0] == 7, v[1] == 10, v[2] == 17<span style="mso-spacerun: yes">  </span></font></font></span></pre><pre><font size="3"><font face="宋体"><span><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>vector&lt;int&gt; v(3);<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>// </span>声明一个包含三个元素的<span>vector.</span></font></font></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>v[0] = 7;</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>v[1] = v[0] + 3;</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>v[2] = v[0] + v[1];<span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>// v[0] == 7, v[1] == 10, v[2] == 17<span style="mso-spacerun: yes">  </span></font></font></span></pre><pre><span><font face="宋体" size="3"> </font></span></pre><br><br><span><font face="宋体" size="3">The STL also includes a large collection of <em>algorithms</em> that manipulate the data stored in containers. You can reverse the order of elements in a <tt>vector</tt>, for example, by using the <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></tt> algorithm. </font></span><br><br><font size="3"><font face="宋体"><span>STL</span>也包括一个很大的算法集合用于处理存储在容器的数据。例如你可以通过使用<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>算法</tt>倒序保存在<span>vector</span>中的元素。</font></font><br><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>reverse(v.begin(), v.end()); // v[0] == 17, v[1] == 10, v[2] == 7</font></font></span></pre><br><br><span><font size="3"><font face="宋体">There are two important points to notice about this call to <tt>reverse</tt>. First, it is a global function, not a member function. Second, it takes two arguments rather than one: it operates on a <em>range</em> of elements, rather than on a container. In this particular case the range happens to be the entire container <tt>v.</tt></font></font></span><br><br><font face="宋体" size="3">在使用<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>时</tt>有两个重要点值得注意<span>,</span>第一点是它是一个全局函数，而不是一个成员函数；第二点是它包括两个参数而不是一个参数，容器元素的边界而不是容器。在我们这个例子中，边界即为整个容器。</font>

<span><font face="宋体" size="3">The reason for both of these facts is the same: <tt>reverse</tt>, like other STL algorithms, is decoupled from the STL container classes. This means that <tt>reverse</tt> can be used not only to reverse elements in vectors, but also to reverse elements in lists, and even elements in C arrays. The following program is also valid.</font></span>

<font size="3"><font face="宋体">这两点其实是一样的：<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>，像其他的<span>STL</span>算法，是与<span>STL</span>容器类，这意味这<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>不仅可以用于倒序<span>vectors</span>中的元素，还可以用于<span>lists</span>，甚至用于<span>C</span>数组。下面的程序是合法的。</tt></font></font><br><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>double A[6] = { 1.2, 1.3, 1.4, 1.5, 1.6, 1.7 };</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>reverse(A, A + 6);</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>for (int i = 0; i &lt; 6; ++i)</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>cout &lt;&lt; “A[“ &lt;&lt; i &lt;&lt; “] = “ &lt;&lt; A[i];</font></font></span></pre><br><br><span><font face="宋体" size="3">This example uses a <em>range</em>, just like the example of reversing a <tt>vector</tt>: the first argument to reverse is a pointer to the beginning of the range, and the second argument points one element past the end of the range. This range is denoted <tt>[A, A + 6)</tt>; the asymmetrical notation is a reminder that the two endpoints are different, that the first is the beginning of the range and the second is <em>one past</em> the end of the range. </font></span><br><br><font face="宋体" size="3">这个例子中使用的区间，就像在倒序<span>vector</span>中使用的：第一个参数是指向倒序的区间的开始，第二个参数是指向超过区间的第一个元素。这个区间表示的是<span>[A</span>，<span>A+6],</span>非对称的符号提示两点区间端点是不同的，第一个端点是区间的起始点，第二个是超过区间的第一个点。</font>

<h2 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a><span><font face="宋体">Iterators</font></span></h2><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a><font face="宋体">迭代器</font></h2><span><font face="宋体" size="3">In the example of reversing a C array, the arguments to <tt>reverse</tt> are clearly of type <tt>double*</tt>. What are the arguments to reverse if you are reversing a <tt>vector</tt>, though, or a <tt>list</tt>? That is, what exactly does <tt>reverse</tt> declare its arguments to be, and what exactly do <tt>v.begin()</tt> and <tt>v.end()</tt> return? </font></span>

<font size="3"><font face="宋体">在倒序<span>C</span>数组的例子中，传递给<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>的参数比较清晰就是<span>double*</span>。那么当你倒序一个<span>vector</span>或者<span>list</span>时传递给<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>的参数是什么呢？也就是，<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>声明的参数类型到底是什么，<span>v.begin()</span>和<span>v.end()</span>返回的是什么呢？</tt></font></font>

<span><font face="宋体" size="3">The answer is that the arguments to <tt>reverse</tt> are <em>iterators</em>, which are a generalization of pointers. Pointers themselves are iterators, which is why it is possible to reverse the elements of a C array. Similarly, <tt>vector</tt> declares the nested types <tt>iterator</tt> and <tt>const_iterator</tt>. In the example above, the type returned by <tt>v.begin()</tt> and <tt>v.end()</tt> is <tt>vector&lt;int&gt;::iterator</tt>. There are also some iterators, such as <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/istream_iterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>istream_iterator</u></font></a></tt> and <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/ostream_iterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>ostream_iterator</u></font></a></tt>, that aren’t associated with containers at all. </font></span>

<font size="3"><font face="宋体">答案是传递给<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>reverse</u></font></a></span>的参数是迭代器，一个泛型指针。指向它们自己的是迭代器，为什么可以倒序<span>C</span>数组中的元素呢。类似地，<span>vector</span>声明了内嵌类型的<span>iterator</span></tt><span> and <tt>const_iterator</tt></span>。在上面的例子中，<tt><span>v.begin()</span></tt>和<tt><span>v.end()</span>返回的类型是<span>vector&lt;int&gt;::iterator</span>。还有一些其他的迭代器，比如<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/istream_iterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>istream_iterator</u></font></a></span></tt>和<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/ostream_iterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>ostream_iterator</u></font></a></span>，它们并没有和容器相关联。</tt></font></font>

<span><font face="宋体" size="3">Iterators are the mechanism that makes it possible to decouple algorithms from containers: algorithms are templates, and are parameterized by the type of iterator, so they are not restricted to a single type of container. Consider, for example, how to write an algorithm that performs linear search through a range. This is the STL’s <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></tt> algorithm. </font></span>

<font size="3"><font face="宋体">迭代器是一种使得算法与容器分离的机制：算法是模板，被迭代器的类型参数化，所以他们没有限制非要在一个单独类型的容器上。考虑这样一个例子，怎么写一个算法实现在一个区间上线性查找。<span>STL</span>的<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></span>即是这样的算法：<span></span></tt></font></font>

<span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>template &lt;class InputIterator, class T&gt;</font></font></span><br><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>InputIterator find(InputIterator first, InputIterator last, const T&amp; value) {</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>while (first != last &amp;&amp; <em>first != value) ++first;</em></font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>return first;</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>}</font></font></span></pre><pre><tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font face="宋体" color="#0000ee" size="3"><u>find</u></font></a></span><font face="宋体" size="3">要求三个参数：两个迭代器定义了一个区间，一个<span>value</span>用于在区间中查找。它在区间<span>[first,last)</span>中检查每一个迭代器，从开始到结束，在找到一个指向<span>value</span>的迭代器或者到达区间尾时停止。</font></tt></pre><br><br><font size="3"><font face="宋体"><tt><span>Find</span></tt><span> takes three arguments: two iterators that define a range, and a value to search for in that range. It examines each iterator in the range <tt>[first, last)</tt>, proceeding from the beginning to the end, and stops either when it finds an iterator that points to <tt>value</tt> or when it reaches the end of the range. </span></font></font><br><br><font size="3"><font face="宋体"><tt><span>First</span></tt><span> and <tt>last</tt> are declared to be of type <tt>InputIterator</tt>, and <tt>InputIterator</tt> is a template parameter. That is, there isn’t actually any type called <tt>InputIterator</tt>: when you call <tt>find</tt>, the compiler substitutes the actual type of the arguments for the formal type parameters <tt>InputIterator</tt> and <tt>T</tt>. If the first two arguments to <tt>find</tt> are of type <tt>int</tt> and the third is of type <tt>int</tt>, then it is as if you had called the following function.</span></font></font><br><br><font size="3"><font face="宋体"><span>First</span>和<span>last</span>被声明为<span>InputIterator</span>类型，是一个模板参数类型。实际上并没有叫做<span>InputItearot</span>的类型：当你调用<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></span>时，编译器会用实参类型替换型参<span>InputIteartor</span>和<span>T</span>。假如传递给<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></span>的前面两个参数是<span>int<em></em></span>，第三个参数是<span>int</span>的话，实际上你调用的函数是下面这样的：</tt></font></font><br><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>int find(int<em> first, int</em> last, const int&amp; value) {</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>while (first != last &amp;&amp; *first != value) ++first;</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>return first;</font></font></span></pre><pre><span><font size="3"><font face="宋体"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  </span>}</font></font></span></pre><br><br>## <span><font face="宋体">Concepts and Modeling</font></span>

<h2 id="概念和模型"><a href="#概念和模型" class="headerlink" title="概念和模型"></a><font face="宋体">概念和模型</font></h2><span><font face="宋体" size="3">One very important question to ask about any template function, not just about STL algorithms, is what the set of types is that may correctly be substituted for the formal template parameters. Clearly, for example, <tt>int<em></em></tt> or <tt>double</tt> may be substituted for <tt>find</tt>‘s formal template parameter <tt>InputIterator</tt>. Equally clearly, <tt>int</tt> or <tt>double</tt> may not: <tt>find</tt> uses the expression <tt>*first</tt>, and the dereference operator makes no sense for an object of type <tt>int</tt> or of type <tt>double</tt>. The basic answer, then, is that <tt>find</tt> implicitly defines a set of requirements on types, and that it may be instantiated with any type that satisfies those requirements. Whatever type is substituted for <tt>InputIterator</tt> must provide certain operations: it must be possible to compare two objects of that type for equality, it must be possible to increment an object of that type, it must be possible to dereference an object of that type to obtain the object that it points to, and so on. </font></span>

<font size="3"><font face="宋体">一个关于模板函数的非常重要的问题，不仅仅是<span>STL</span>算法，是正确的替换形式模板参。明显地，例如，<span>int<em></em></span>和<span>double</span>也许会替换<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></span>的形式模板参数<span>Input-</span></tt></font></font>

<tt><font size="3"><font face="宋体"><span>Iterato</span>。同样地，<span>int</span>或者<span>double</span>也许不会：<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></span>使用表达式<span>*first</span>，解引用运算符对一个<span>int</span>或者<span>double</span>类型没有任何意义。一个简单的答案是，<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></span>也许显示定义了一个需求类型集合，它会这些参数能满足需求的时候被实例化（也就是不满足要求的会报错了）。能够替换<span>InputIterator</span>的参数必须提供能够以下操作：它必须可以比较两个类型是否相等，它必须可以自增，而且还可以解引用获得它指向的元素，等等。</font></font></tt>

<font size="3"><font face="宋体"><tt><span>Find</span></tt><span> isn’t the only STL algorithm that has such a set of requirements; the arguments to <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/for_each.html" target="_blank" rel="noopener"><font color="#0000ee"><u>for_each</u></font></a></tt> and <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/count.html" target="_blank" rel="noopener"><font color="#0000ee"><u>count</u></font></a></tt>, and other algorithms, must satisfy the same requirements. These requirements are sufficiently important that we give them a name: we call such a set of type requirements a <em>concept</em>, and we call this particular concept <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/InputIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Input Iterator</u></font></a></strong>. We say that a type <em>conforms to a concept</em>, or that it <em>is a model of a concept</em>, if it satisfies all of those requirements. We say that <tt>int<em></em></tt> is a model of <strong>Input Iterator</strong> because <tt>int</tt> provides all of the operations that are specified by the <strong>Input Iterator</strong> requirements. </span></font></font>

<font size="3"><font face="宋体"><span>STL</span>算法中并不是只要<span>Find</span>有这样的一个需求集合，<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/for_each.html" target="_blank" rel="noopener"><font color="#0000ee"><u>for_each</u></font></a></span></tt>和<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/count.html" target="_blank" rel="noopener"><font color="#0000ee"><u>count</u></font></a></span>的参数，还要其他的算法同样需要满足同样的要求。这些需求是足够重要的，我们给他们起个名字：我们称这样的类型需求集合为概念，这样一个特殊的概念叫做输入迭代器。我们称满足这样要求的概念为一个模型。<span>Int<em></em></span>是一个</tt><strong><span>Input Iterator</span></strong>因为<span>int</span>提供了所有<strong><span>Input Iterator</span></strong>要求的的操作。</font></font>

<span><font face="宋体" size="3">Concepts are not a part of the C++ language; there is no way to declare a concept in a program, or to declare that a particular type is a model of a concept. Nevertheless, concepts are an extremely important part of the STL. Using concepts makes it possible to write programs that cleanly separate interface from implementation: the author of <tt>find</tt> only has to consider the interface specified by the concept <strong>Input Iterator</strong>, rather than the implementation of every possible type that conforms to that concept. Similarly, if you want to use <tt>find</tt>, you need only to ensure that the arguments you pass to it are models of <strong>Input Iterator. </strong>This is the reason why <tt>find</tt> and <tt>reverse</tt> can be used with <tt>list</tt>s, <tt>vector</tt>s, C arrays, and many other types: programming in terms of concepts, rather than in terms of specific types, makes it possible to reuse software components and to combine components together. </font></span>

<h2 id="Refinement"><a href="#Refinement" class="headerlink" title="Refinement"></a><span><font face="宋体">Refinement</font></span></h2><h2 id="精巧"><a href="#精巧" class="headerlink" title="精巧"></a><font face="宋体">精巧</font></h2><font size="3"><font face="宋体"><strong><span>Input Iterator</span></strong><span> is, in fact, a rather weak concept: that is, it imposes very few requirements. An <strong>Input Iterator</strong> must support a subset of pointer arithmetic (it must be possible to increment an <strong>Input Iterator</strong> using prefix and postfix <tt>operator++</tt>), but need not support all operations of pointer arithmetic. This is sufficient for <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/find.html" target="_blank" rel="noopener"><font color="#0000ee"><u>find</u></font></a></tt>, but some other algorithms require that their arguments satisfy additional requirements. <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Reverse</u></font></a></tt>, for example, must be able to decrement its arguments as well as increment them; it uses the expression <tt>–last</tt>. In terms of concepts, we say that <tt>reverse</tt>‘s arguments must be models of <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/BidirectionalIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Bidirectional Iterator</u></font></a></strong> rather than <strong>Input Iterator</strong>. </span></font></font>

<font size="3"><font face="宋体"><strong><span>Input Iterator</span></strong>事实上是一个非常弱的概念：它强加了很少的要求。一个<strong><span>Input Iterator</span></strong>必须提供一个指针算术的子集（它必须可以去通过前缀或者后缀的<span>++</span>递增一个<strong><span>Input Iterator</span></strong>），但是不需要提供所以的指针运算。这些对于<span>find</span>来说已经足够了，但是其他的一些算法需要一些额外的要求。例如<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Reverse</u></font></a></span>必须可以通过<span>–</span>实现递减。按照概念的说法，我们说<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/reverse.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Reverse</u></font></a></span>的参数为</tt><strong><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/BidirectionalIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Bidirectional Iterator</u></font></a></span></strong>模型而非<strong><span>Input Iterator</span></strong>。</font></font>

<span><font face="宋体" size="3">The <strong>Bidirectional Iterator</strong> concept is very similar to the <strong>Input Iterator</strong> concept: it simply imposes some additional requirements. The types that are models of <strong>Bidirectional Iterator</strong> are a subset of the types that are models of<strong> Input Iterator</strong>: every type that is a model of <strong>Bidirectional Iterator</strong> is also a model of <strong>Input Iterator</strong>. <tt>Int*</tt>, for example, is both a model of <strong>Bidirectional Iterator</strong> and a model of <strong>Input Iterator</strong>, but <tt><a href="http://hi.baidu.com/fc/桌面/SGI-STL/istream_iterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>istream_iterator</u></font></a></tt>, is only a model of <strong>Input Iterator</strong>: it does not conform to the more stringent <strong>Bidirectional Iterator</strong> requirements. </font></span>

<font size="3"><font face="宋体"><strong><span>Bidirectional Iterator</span></strong>的概念和<strong><span>Input Iterator</span></strong>非常相似<span>: </span>它仅仅加了一些额外的要求。<strong><span>Bidirectional Iterator</span></strong>的模型也是一个<strong><span>Input Iterator</span></strong>的子集<span>: </span></font></font>

<font face="宋体" size="3">任何<strong><span>Bidirectional Iterator</span></strong><span> </span>的模型同时也是一个<strong><span>Input Iterator</span></strong><span> </span>的模型。 例如<span>,<tt> Int*</tt>,</span>既是 <strong><span>Bidirectional Iterator</span></strong><span> </span>的模型也是一个<strong><span>Input Iterator </span></strong>的模型<span>, </span>但是<tt><span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/istream_iterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>istream_iterator</u></font></a></span></tt>仅仅是一个的模型<strong><span>Input Iterator</span></strong><span>: </span>它并没有符合<strong><span>Bidirectional Iterator</span></strong>更严格的要求。</font>

<span><font face="宋体" size="3">We describe the relationship between <strong>Input Iterator</strong> and <strong>Bidirectional Iterator</strong> by saying that <strong>Bidirectional Iterator</strong> is a <em>refinement</em> of <strong>Input Iterator</strong>. Refinement of concepts is very much like inheritance of C++ classes; the main reason we use a different word, instead of just calling it “inheritance”, is to emphasize that refinement applies to concepts rather than to actual types.</font></span>

<font face="宋体" size="3">我们描述<strong><span>Input Iterator</span></strong>和<strong><span>Bidirectional Iterator</span></strong>的关系时说<strong><span>Bidirectional Iterator</span></strong>是一个更精巧的<strong><span>InputIterator</span></strong>。精巧概念非常像<span>C++</span>类的派生，我们用一个不同的词的主要原因是强调精巧是应用与概念而不是实际的类型。</font>

<span><font face="宋体" size="3">There are actually three more iterator concepts in addition to the two that we have already discussed: the five iterator concepts are <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/OutputIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Output Iterator</u></font></a></strong>, <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/InputIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Input Iterator</u></font></a></strong>, <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/ForwardIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Forward Iterator</u></font></a></strong>, <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/BidirectionalIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Bidirectional Iterator</u></font></a></strong>, and <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/RandomAccessIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Random Access Iterator</u></font></a>;</strong> <strong>Forward Iterator</strong> is a refinement of <strong>Input Iterator</strong>, <strong>Bidirectional Iterator</strong> is a refinement of <strong>Forward Iterator</strong>, and <strong>Random Access Iterator</strong> is a refinement of <strong>Bidirectional Iterator</strong>. (<strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/OutputIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Output Iterator</u></font></a></strong> is related to the other four concepts, but it is not part of the hierarchy of refinement: it is not a refinement of any of the other iterator concepts, and none of the other iterator concepts are refinements of it.) The <em><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Iterators.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Iterator Overview</u></font></a></em> has more information about iterators in general. </font></span>

<font size="3"><font face="宋体">除了我们已经讨论的两个外实际上还要更多的迭代器类型：五种迭代器类型分别为<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/OutputIterator.html" target="_blank" rel="noopener"><strong><font color="#0000ee"><u>Output Iterator</u></font></strong></a>, <a href="http://hi.baidu.com/fc/桌面/SGI-STL/InputIterator.html" target="_blank" rel="noopener"><strong><font color="#0000ee"><u>Input Iterator</u></font></strong></a>, <a href="http://hi.baidu.com/fc/桌面/SGI-STL/ForwardIterator.html" target="_blank" rel="noopener"><strong><font color="#0000ee"><u>Forward Iterator</u></font></strong></a>, <a href="http://hi.baidu.com/fc/桌面/SGI-STL/BidirectionalIterator.html" target="_blank" rel="noopener"><strong><font color="#0000ee"><u>Bidirectional Iterator</u></font></strong></a></span>和<span><a href="http://hi.baidu.com/fc/桌面/SGI-STL/RandomAccessIterator.html" target="_blank" rel="noopener"><strong><font color="#0000ee"><u>Random Access Iterator</u></font></strong></a>; <strong>Forward Iterator</strong> </span>是一个精巧的<strong><span>Input Itearot</span></strong><span>,<strong> Bidirectional Iterator</strong></span>是一个更精巧的 <strong><span>Forward Iterator</span></strong><span>, <strong>Random Access Iterator</strong> </span>是一个更精巧的<strong><span>Bidirectional Iterator</span></strong><span>. (<strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/OutputIterator.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Output Iterator</u></font></a></strong> </span>和其他四中迭代器相关，但不是派生和精巧关系<span>) <em><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Iterators.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Iterator Overview</u></font></a></em> </span>有更多的关于<span>iterators</span>的一般信息<span>. </span></font></font>

<span><font face="Times New Roman"></font></span>

<span><font face="宋体" size="3">Container classes, like iterators, are organized into a hierarchy of concepts. All containers are models of the concept <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Container.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Container</u></font></a></strong>; more refined concepts, such as <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Sequence.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Sequence</u></font></a></strong> and <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/AssociativeContainer.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Associative Container</u></font></a></strong>, describe specific types of containers. </font></span>

<p><font face="宋体" size="3">容器类，像迭代器一样被组织进一个概念中。所以的容器都是概念<strong><span><a href="file:///E:/System_Document/桌面/SGI-STL/Container.html" target="_blank" rel="noopener"><font color="#800080"><u>Container</u></font></a></span></strong>的模型；更加精巧的概念，比如说<strong><span><a href="file:///E:/System_Document/桌面/SGI-STL/Sequence.html" target="_blank" rel="noopener"><font color="#800080"><u>Sequence</u></font></a></span></strong><span> and <strong><a href="file:///E:/System_Document/桌面/SGI-STL/AssociativeContainer.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Associative Container</u></font></a></strong>, </span>描述了更特别的容器。</font></p>
<font size="3">

<p>## </p>
<h2 id="下面这部分暂时不翻译，以后看需要时在看。"><a href="#下面这部分暂时不翻译，以后看需要时在看。" class="headerlink" title="下面这部分暂时不翻译，以后看需要时在看。"></a><span><font face="宋体">下面这部分暂时不翻译，以后看需要时在看。</font></span></h2><h2 id="Other-parts-of-the-STL"><a href="#Other-parts-of-the-STL" class="headerlink" title="Other parts of the STL"></a><span><font face="宋体">Other parts of the STL</font></span></h2><span><font face="宋体">If you understand algorithms, iterators, and containers, then you understand almost everything there is to know about the STL. The STL does, however, include several other types of components. </font></span>

<span><font face="宋体">First, the STL includes several <em>utilities</em>: very basic concepts and functions that are used in many different parts of the library. The concept<strong> <a href="http://hi.baidu.com/fc/桌面/SGI-STL/Assignable.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Assignable</u></font></a></strong>, for example, describes types that have assignment operators and copy constructors; almost all STL classes are models of <strong>Assignable</strong>, and almost all STL algorithms require their arguments to be models of <strong>Assignable</strong>. </font></span>

<span><font face="宋体">Second, the STL includes some low-level mechanisms for allocating and deallocating memory. <em><a href="http://hi.baidu.com/fc/桌面/SGI-STL/Allocators.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Allocators</u></font></a></em> are very specialized, and you can safely ignore them for almost all purposes. </font></span>

<p><span><font face="宋体">Finally, the STL includes a large collection of <em><a href="http://hi.baidu.com/fc/桌面/SGI-STL/functors.html" target="_blank" rel="noopener"><font color="#0000ee"><u>function objects</u></font></a></em>, also known as <em>functors</em>. Just as iterators are a generalization of pointers, function objects are a generalization of functions: a function object is anything that you can call using the ordinary function call syntax. There are several different concepts relating to function objects, including <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/UnaryFunction.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Unary Function</u></font></a></strong> (a function object that takes a single argument, <em>i.e.</em> one that is called as <tt>f(x)</tt>) and <strong><a href="http://hi.baidu.com/fc/桌面/SGI-STL/BinaryFunction.html" target="_blank" rel="noopener"><font color="#0000ee"><u>Binary Function</u></font></a></strong> (a function object that takes two arguments, <em>i.e.</em> one that is called as <tt>f(x, y)</tt>). Function objects are an important part of generic programming because they allow abstraction not only over the types of objects, but also over the operations that are being performed.</font></span><br></p></font><br><p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/04/13/循环不变式-发表日期2008-04-13-0151/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2008/04/13/循环不变式-发表日期2008-04-13-0151/" itemprop="url">循环不变式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-04-13T01:51:00+08:00">
                2008-04-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <div id="blog_text" class="cnt"><br><pre class="brush:cpp">//invariant:we have written r rows so far.<br>int r=0;<br>//setting r to 0 makes the invariant true<br>while(r!=rows)<br>{<br>//we can assume that the invariant is true here<br>//writting a row of output makes the invariant false<br>std::cout&lt;&lt;std::endl;<br>//incrementing i makes the invarian true again<br>++r;<br>}</pre><br>上面这个循环很简单，就是要使循环体执行n次，但是从中我们可以发现一个循环不变式，那就是“we have written r rows so far”，循环不变式要成立只需当1while开始之前循环不变式成立，2当我们执行到循环体尾部时循环不变式成立。当我们将i设为0时，此时我们一次都没有循环显然循环不变式成立，因为我们此时还没有输出一行，当我们输出一行后，此时循环不变式即为假了，但是++r使得循环不变式又为真了，因此我们可以得出此循环不变式是成立的，当最后跳出循环体时，r==rows了，即我们已经输出了rows行了！<br><br>PS:从Accelerated C++上面看到一个概念，真的是一本不错的书。<br><br></div>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2008/03/02/又是指针和数组/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2008/03/02/又是指针和数组/" itemprop="url">又是指针和数组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2008-03-02T18:23:00+08:00">
                2008-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index">
                    <span itemprop="name">C++</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;TABLE style=&quot;TABLE-LAYOUT: fixed&quot;&gt;
</code></pre><p><tbody></tbody></p>
<p><tr></tr></p>
<p><td></td></p>
<p><div class="cnt" id="blog_text"></div></p>
<div>

<p>#include &lt;stdio.h&gt;<br>int main()<br>{<br>int a[5]={1,2,3,4,5};<br>int i;<br>int <em>ptr=(int</em>)(&amp;a+1);<br>printf(“ptr=%p/n”,ptr);<br>for(i=0;i&lt;5;i++)<br>&nbsp;&nbsp; printf(“%p/n”,a+i);<br>printf(“%d,%d/n”,<em>(a+1),</em>(ptr-1));<br>}</p>
<p>以下是输出</p>
<p>ptr=0013FF64<br>0013FF50<br>0013FF54<br>0013FF58<br>0013FF5C<br>0013FF60<br>2,5</p>
<p>哎，想了半天才发现是&amp;a+1而不是a+1真是粗心啊！<br></p></div><br><p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2007/11/21/mfc-is-back-发布日期：2007-11-21/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="billowqiu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="taocoding">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/11/21/mfc-is-back-发布日期：2007-11-21/" itemprop="url">MFC is back</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-11-21T18:38:00+08:00">
                2007-11-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/VC/" itemprop="url" rel="index">
                    <span itemprop="name">VC</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <pre><code>&lt;TABLE style=&quot;TABLE-LAYOUT: fixed&quot;&gt;
</code></pre><p><tbody></tbody></p>
<p><tr></tr></p>
<p><td></td></p>
<div class="cnt" id="blog_text">

<span style="FONT-SIZE: 11pt"><font face="Tahoma">Hello again. My name is Ale Contenti, and I’m the Dev Lead for the VC++ Libraries. I’m writing this blog entry from my hotel room in Barcelona. Steve Teixeira and I are here for TechEd Developers Europe. Let me tell you that the atmosphere here is just great! Lots of people and a lot of Visual Studio and C++ users. Lots of interest in Visual Studio 2008 and all the new features and functionality we’ve added to the product.</font></span>

<span style="FONT-SIZE: 11pt; COLOR: #1f497d"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt; COLOR: #1f497d"><a href="http://www.gregcons.com/KateBlog/" target="_blank" rel="noopener"><font face="Tahoma" color="#0000ff"><u>Kate Gregory</u></font></a><font face="Tahoma">, </font><a href="http://blogs.msdn.com/texblog/" target="_blank" rel="noopener"><font face="Tahoma" color="#800080"><u>Steve</u></font></a><font face="Tahoma"> </font></span><span style="FONT-SIZE: 11pt"><font face="Tahoma">and I covered more than 7 talks about different C++ topics, ranging from debugging to interop to MFC. My main talk was about “MFC Updates for Visual Studio 2008 and Beyond”. &nbsp;&nbsp; In this session I introduced the major new features we’re implementing for MFC. With these features, developers will be able to create modern applications that leverage the “look and feel” of Microsoft Office, Internet Explorer and Visual Studio.</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">My MFC talk was in a pretty big room, and the audience was extremely interested! It was great to show the demos and look at the code together! I had a lot of fun and the Q&amp;A session was just perfect, with a lot of great questions and (hopefully) satisfying answers from me </font></span><span style="FONT-SIZE: 11pt">J</span><span style="FONT-SIZE: 11pt"><font face="Tahoma">.</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">Let me share with you some of the comments from the attendees:</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><span style="mso-list: Ignore">·<span style="FONT: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="FONT-SIZE: 11pt"><font face="Tahoma">“Great session! At last, MFC is back!”</font></span>

<span style="FONT-SIZE: 11pt"><span style="mso-list: Ignore">·<span style="FONT: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="FONT-SIZE: 11pt"><font face="Tahoma">“Good demo, great job with all these new control”</font></span>

<span style="FONT-SIZE: 11pt"><span style="mso-list: Ignore">·<span style="FONT: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="FONT-SIZE: 11pt"><font face="Tahoma">“I am really glad to see the future of MFC/VC++ and the commitment to the native programmer. This was a great session and a nice glimpse of the things to come. Keep up the good work. Also, nice to see so many C++ topics this year with really great presenters.”</font></span>

<span style="FONT-SIZE: 11pt"><span style="mso-list: Ignore">·<span style="FONT: 7pt Times New Roman">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="FONT-SIZE: 11pt"><font face="Tahoma">“Very surprised on all the work that has been done to MFC, having been in the situation where MFC seemed to have been left behind (visually at least)”</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">I was really happy to have the opportunity to present these updates to the MFC Libraries! Special thanks to the VC++ Libraries Team!</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">Kate and I also talked about C++0x and TR1 during a couple of “interactive sessions” or “chalk talk”. Again, great interest on the new TR1 extensions and on what will come from the C++ Standard.</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">During the talks, I had time to meet with a lot of customers and MVPs in the VS2008 Ask The Expert (ATE) booth. I really like to listen to our customers scenarios: It really forces me to think outside the box and to realize how many different “field” problems our customers need to face every day!</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">Last but not least, Charles from Channel9 found some time to interview Kate, Steve and I about C++, customers and what’s next for VC.</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">Heading to Germany, now, for more customer visits!</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">Adios!</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma"></font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">Ale Contenti</font></span>

<span style="FONT-SIZE: 11pt"><font face="Tahoma">VC++ Libraries Dev Lead</font></span>

<p><span style="FONT-SIZE: 11pt"><font face="Tahoma">以上摘自<a href="http://blogs.msdn.com/vcblog/default.aspx" target="_blank" rel="noopener"><u><font color="#0000ff">Visual C++ Team Blog</font></u></a>上的一篇文章，终于看到MS更新MFC了，:-)。</font></span><br></p></div><br><p></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/13/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/15/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">billowqiu</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">156</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/billowqiu" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="mailto:billowqiu@163.com" target="_blank" title="E-Mail">
                    
                      <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">billowqiu</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
